-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | λΠ-calculus implemented in a few different ways.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/fizruk/free-foil#readme</a>
@package lambda-pi
@version 0.2.0


-- | The abstract syntax of language Syntax.
module Language.LambdaPi.Syntax.Abs
type Program = Program' BNFC'Position
data Program' a
AProgram :: a -> [Command' a] -> Program' a
type Command = Command' BNFC'Position
data Command' a
CommandCheck :: a -> Term' a -> Term' a -> Command' a
CommandCompute :: a -> Term' a -> Term' a -> Command' a
type Term = Term' BNFC'Position
data Term' a
Var :: a -> VarIdent -> Term' a
Pi :: a -> Pattern' a -> Term' a -> ScopedTerm' a -> Term' a
Lam :: a -> Pattern' a -> ScopedTerm' a -> Term' a
App :: a -> Term' a -> Term' a -> Term' a
Product :: a -> Term' a -> Term' a -> Term' a
Pair :: a -> Term' a -> Term' a -> Term' a
First :: a -> Term' a -> Term' a
Second :: a -> Term' a -> Term' a
Universe :: a -> Term' a
type ScopedTerm = ScopedTerm' BNFC'Position
data ScopedTerm' a
AScopedTerm :: a -> Term' a -> ScopedTerm' a
type Pattern = Pattern' BNFC'Position
data Pattern' a
PatternWildcard :: a -> Pattern' a
PatternVar :: a -> VarIdent -> Pattern' a
PatternPair :: a -> Pattern' a -> Pattern' a -> Pattern' a
newtype VarIdent
VarIdent :: String -> VarIdent

-- | Start position (line, column) of something.
type BNFC'Position = Maybe (Int, Int)
pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'Position :: Int -> Int -> BNFC'Position

-- | Get the start position of something.
class HasPosition a
hasPosition :: HasPosition a => a -> BNFC'Position
instance Data.Data.Data a => Data.Data.Data (Language.LambdaPi.Syntax.Abs.Command' a)
instance Data.Data.Data a => Data.Data.Data (Language.LambdaPi.Syntax.Abs.Pattern' a)
instance Data.Data.Data a => Data.Data.Data (Language.LambdaPi.Syntax.Abs.Program' a)
instance Data.Data.Data a => Data.Data.Data (Language.LambdaPi.Syntax.Abs.ScopedTerm' a)
instance Data.Data.Data a => Data.Data.Data (Language.LambdaPi.Syntax.Abs.Term' a)
instance Data.Data.Data Language.LambdaPi.Syntax.Abs.VarIdent
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.LambdaPi.Syntax.Abs.Command' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.LambdaPi.Syntax.Abs.Pattern' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.LambdaPi.Syntax.Abs.Program' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.LambdaPi.Syntax.Abs.ScopedTerm' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.LambdaPi.Syntax.Abs.Term' a)
instance GHC.Classes.Eq Language.LambdaPi.Syntax.Abs.VarIdent
instance Data.Foldable.Foldable Language.LambdaPi.Syntax.Abs.Command'
instance Data.Foldable.Foldable Language.LambdaPi.Syntax.Abs.Pattern'
instance Data.Foldable.Foldable Language.LambdaPi.Syntax.Abs.Program'
instance Data.Foldable.Foldable Language.LambdaPi.Syntax.Abs.ScopedTerm'
instance Data.Foldable.Foldable Language.LambdaPi.Syntax.Abs.Term'
instance GHC.Base.Functor Language.LambdaPi.Syntax.Abs.Command'
instance GHC.Base.Functor Language.LambdaPi.Syntax.Abs.Pattern'
instance GHC.Base.Functor Language.LambdaPi.Syntax.Abs.Program'
instance GHC.Base.Functor Language.LambdaPi.Syntax.Abs.ScopedTerm'
instance GHC.Base.Functor Language.LambdaPi.Syntax.Abs.Term'
instance GHC.Generics.Generic (Language.LambdaPi.Syntax.Abs.Command' a)
instance GHC.Generics.Generic (Language.LambdaPi.Syntax.Abs.Pattern' a)
instance GHC.Generics.Generic (Language.LambdaPi.Syntax.Abs.Program' a)
instance GHC.Generics.Generic (Language.LambdaPi.Syntax.Abs.ScopedTerm' a)
instance GHC.Generics.Generic (Language.LambdaPi.Syntax.Abs.Term' a)
instance GHC.Generics.Generic Language.LambdaPi.Syntax.Abs.VarIdent
instance Language.LambdaPi.Syntax.Abs.HasPosition Language.LambdaPi.Syntax.Abs.Command
instance Language.LambdaPi.Syntax.Abs.HasPosition Language.LambdaPi.Syntax.Abs.Pattern
instance Language.LambdaPi.Syntax.Abs.HasPosition Language.LambdaPi.Syntax.Abs.Program
instance Language.LambdaPi.Syntax.Abs.HasPosition Language.LambdaPi.Syntax.Abs.ScopedTerm
instance Language.LambdaPi.Syntax.Abs.HasPosition Language.LambdaPi.Syntax.Abs.Term
instance Data.String.IsString Language.LambdaPi.Syntax.Abs.VarIdent
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.LambdaPi.Syntax.Abs.Command' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.LambdaPi.Syntax.Abs.Pattern' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.LambdaPi.Syntax.Abs.Program' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.LambdaPi.Syntax.Abs.ScopedTerm' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.LambdaPi.Syntax.Abs.Term' a)
instance GHC.Classes.Ord Language.LambdaPi.Syntax.Abs.VarIdent
instance GHC.Read.Read a => GHC.Read.Read (Language.LambdaPi.Syntax.Abs.Command' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.LambdaPi.Syntax.Abs.Pattern' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.LambdaPi.Syntax.Abs.Program' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.LambdaPi.Syntax.Abs.ScopedTerm' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.LambdaPi.Syntax.Abs.Term' a)
instance GHC.Read.Read Language.LambdaPi.Syntax.Abs.VarIdent
instance GHC.Show.Show a => GHC.Show.Show (Language.LambdaPi.Syntax.Abs.Command' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.LambdaPi.Syntax.Abs.Pattern' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.LambdaPi.Syntax.Abs.Program' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.LambdaPi.Syntax.Abs.ScopedTerm' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.LambdaPi.Syntax.Abs.Term' a)
instance GHC.Show.Show Language.LambdaPi.Syntax.Abs.VarIdent
instance Data.Traversable.Traversable Language.LambdaPi.Syntax.Abs.Command'
instance Data.Traversable.Traversable Language.LambdaPi.Syntax.Abs.Pattern'
instance Data.Traversable.Traversable Language.LambdaPi.Syntax.Abs.Program'
instance Data.Traversable.Traversable Language.LambdaPi.Syntax.Abs.ScopedTerm'
instance Data.Traversable.Traversable Language.LambdaPi.Syntax.Abs.Term'

module Language.LambdaPi.Syntax.Lex
alex_tab_size :: Int
alex_base :: AlexAddr
alex_table :: AlexAddr
alex_check :: AlexAddr
alex_deflt :: AlexAddr
alex_accept :: Array Int (AlexAcc user)
alex_actions :: Array Int (Posn -> String -> Token)
alex_action_3 :: Posn -> String -> Token
alex_action_4 :: Posn -> String -> Token
alex_action_5 :: Posn -> String -> Token
data AlexAddr
AlexA# :: Addr# -> AlexAddr
alexIndexInt16OffAddr :: AlexAddr -> Int# -> Int#
alexIndexInt32OffAddr :: AlexAddr -> Int# -> Int#
quickIndex :: Array Int (AlexAcc (Any :: Type)) -> Int -> AlexAcc (Any :: Type)
data AlexReturn a
AlexEOF :: AlexReturn a
AlexError :: !AlexInput -> AlexReturn a
AlexSkip :: !AlexInput -> !Int -> AlexReturn a
AlexToken :: !AlexInput -> !Int -> a -> AlexReturn a
alexScan :: (Posn, Char, [Byte], String) -> Int -> AlexReturn (Posn -> String -> Token)
alexScanUser :: t -> (Posn, Char, [Byte], String) -> Int -> AlexReturn (Posn -> String -> Token)
alex_scan_tkn :: t1 -> t2 -> Int# -> AlexInput -> Int# -> AlexLastAcc -> (AlexLastAcc, AlexInput)
data AlexLastAcc
AlexNone :: AlexLastAcc
AlexLastAcc :: !Int -> !AlexInput -> !Int -> AlexLastAcc
AlexLastSkip :: !AlexInput -> !Int -> AlexLastAcc
data AlexAcc user
AlexAccNone :: AlexAcc user
AlexAcc :: Int -> AlexAcc user
AlexAccSkip :: AlexAcc user

-- | Create a token with position.
tok :: (String -> Tok) -> Posn -> String -> Token

-- | Token without position.
data Tok

-- | Reserved word or symbol.
TK :: {-# UNPACK #-} !TokSymbol -> Tok

-- | String literal.
TL :: !String -> Tok

-- | Integer literal.
TI :: !String -> Tok

-- | Identifier.
TV :: !String -> Tok

-- | Float literal.
TD :: !String -> Tok

-- | Character literal.
TC :: !String -> Tok
T_VarIdent :: !String -> Tok

-- | Smart constructor for <a>Tok</a> for the sake of backwards
--   compatibility.
pattern TS :: String -> Int -> Tok

-- | Keyword or symbol tokens have a unique ID.
data TokSymbol
TokSymbol :: String -> !Int -> TokSymbol

-- | Keyword or symbol text.
[tsText] :: TokSymbol -> String

-- | Unique ID.
[tsID] :: TokSymbol -> !Int

-- | Token with position.
data Token
PT :: Posn -> Tok -> Token
Err :: Posn -> Token

-- | Pretty print a position.
printPosn :: Posn -> String

-- | Pretty print the position of the first token in the list.
tokenPos :: [Token] -> String

-- | Get the position of a token.
tokenPosn :: Token -> Posn

-- | Get line and column of a token.
tokenLineCol :: Token -> (Int, Int)

-- | Get line and column of a position.
posLineCol :: Posn -> (Int, Int)

-- | Convert a token into "position token" form.
mkPosToken :: Token -> ((Int, Int), String)

-- | Convert a token to its text.
tokenText :: Token -> String

-- | Convert a token to a string.
prToken :: Token -> String

-- | Finite map from text to token organized as binary search tree.
data BTree

-- | Nil (leaf).
N :: BTree

-- | Binary node.
B :: String -> Tok -> BTree -> BTree -> BTree

-- | Convert potential keyword into token or use fallback conversion.
eitherResIdent :: (String -> Tok) -> String -> Tok

-- | The keywords and symbols of the language organized as binary search
--   tree.
resWords :: BTree

-- | Unquote string literal.
unescapeInitTail :: String -> String
data Posn
Pn :: !Int -> !Int -> !Int -> Posn
alexStartPos :: Posn
alexMove :: Posn -> Char -> Posn
type Byte = Word8
type AlexInput = (Posn, Char, [Byte], String)
tokens :: String -> [Token]
alexGetByte :: AlexInput -> Maybe (Byte, AlexInput)
alexInputPrevChar :: AlexInput -> Char

-- | Encode a Haskell String to a list of Word8 values, in UTF8 format.
utf8Encode :: Char -> [Word8]
instance GHC.Classes.Eq Language.LambdaPi.Syntax.Lex.Posn
instance GHC.Classes.Eq Language.LambdaPi.Syntax.Lex.Tok
instance GHC.Classes.Eq Language.LambdaPi.Syntax.Lex.TokSymbol
instance GHC.Classes.Eq Language.LambdaPi.Syntax.Lex.Token
instance GHC.Classes.Ord Language.LambdaPi.Syntax.Lex.Posn
instance GHC.Classes.Ord Language.LambdaPi.Syntax.Lex.Tok
instance GHC.Classes.Ord Language.LambdaPi.Syntax.Lex.TokSymbol
instance GHC.Classes.Ord Language.LambdaPi.Syntax.Lex.Token
instance GHC.Show.Show Language.LambdaPi.Syntax.Lex.BTree
instance GHC.Show.Show Language.LambdaPi.Syntax.Lex.Posn
instance GHC.Show.Show Language.LambdaPi.Syntax.Lex.Tok
instance GHC.Show.Show Language.LambdaPi.Syntax.Lex.TokSymbol
instance GHC.Show.Show Language.LambdaPi.Syntax.Lex.Token

module Language.LambdaPi.Syntax.Layout
data LayoutDelimiters
LayoutDelimiters :: TokSymbol -> Maybe TokSymbol -> Maybe TokSymbol -> LayoutDelimiters
[delimSep] :: LayoutDelimiters -> TokSymbol

-- | Nothing for toplevel layout.
[delimOpen] :: LayoutDelimiters -> Maybe TokSymbol

-- | Nothing for toplevel layout.
[delimClose] :: LayoutDelimiters -> Maybe TokSymbol
layoutWords :: [(TokSymbol, LayoutDelimiters)]
layoutStopWords :: [TokSymbol]
layoutOpen :: [TokSymbol]
layoutClose :: [TokSymbol]
layoutSep :: [TokSymbol]
parenOpen :: [TokSymbol]
parenClose :: [TokSymbol]

-- | Report an error during layout resolution.
layoutError :: [Token] -> String -> a

-- | Replace layout syntax with explicit layout tokens.
resolveLayout :: Bool -> [Token] -> [Token]
type Position = Posn
type Line = Int
type Column = Int

-- | Entry of the layout stack.
data Block

-- | An implicit layout block with its start column.
Implicit :: LayoutDelimiters -> Status -> Column -> Block
Explicit :: Block

-- | Get current indentation. 0 if we are in an explicit block.
indentation :: Block -> Column

-- | Check if s block is implicit.
isImplicit :: Block -> Bool
data Status

-- | A layout column that has not been confirmed by a line break
Tentative :: Status

-- | A layout column that has been confirmed by a line break.
Definitive :: Status

-- | Add a new implicit layout block.
addImplicit :: LayoutDelimiters -> Position -> Position -> [Block] -> [Block]

-- | Confirm tentative blocks that are not more indented than <tt>col</tt>.
confirm :: Column -> [Block] -> [Block]

-- | Get the position immediately to the right of the given token. If no
--   token is given, gets the first position in the file.
afterPrev :: Maybe Token -> Position

-- | Get the position immediately to the right of the given token.
nextPos :: Token -> Position

-- | Get the number of characters in the token.
tokenLength :: Token -> Int

-- | Create a position symbol token.
sToken :: Position -> TokSymbol -> Token

-- | Get the line number of a token.
line :: Token -> Line

-- | Get the column number of a token.
column :: Token -> Column

-- | Is the following token on a new line?
newLine :: Maybe Token -> Token -> Bool

-- | Check if a word is a layout start token.
isLayout :: Token -> Maybe LayoutDelimiters

-- | Check if a token is one of the given symbols.
isTokenIn :: [TokSymbol] -> Token -> Bool

-- | Check if a token is a layout stop token.
isStop :: Token -> Bool

-- | Check if a token is the layout open token.
isLayoutOpen :: Token -> Bool

-- | Check if a token is the layout separator token.
isLayoutSep :: Token -> Bool

-- | Check if a token is the layout close token.
isLayoutClose :: Token -> Bool

-- | Check if a token is an opening parenthesis.
isParenOpen :: Token -> Bool

-- | Check if a token is a closing parenthesis.
isParenClose :: Token -> Bool

module Language.LambdaPi.Syntax.Par
happyError :: [Token] -> Err a
myLexer :: String -> [Token]
pProgram :: [Token] -> Err Program
pCommand :: [Token] -> Err Command
pListCommand :: [Token] -> Err [Command]
pTerm2 :: [Token] -> Err Term
pTerm :: [Token] -> Err Term
pTerm1 :: [Token] -> Err Term
pScopedTerm :: [Token] -> Err ScopedTerm
pPattern :: [Token] -> Err Pattern


-- | Pretty-printer for Language.
module Language.LambdaPi.Syntax.Print

-- | The top-level printing method.
printTree :: Print a => a -> String
type Doc = [ShowS] -> [ShowS]
doc :: ShowS -> Doc
render :: Doc -> String
parenth :: Doc -> Doc
concatS :: [ShowS] -> ShowS
concatD :: [Doc] -> Doc
replicateS :: Int -> ShowS -> ShowS

-- | The printer class does the job.
class Print a
prt :: Print a => Int -> a -> Doc
printString :: String -> Doc
mkEsc :: Char -> Char -> ShowS
prPrec :: Int -> Int -> Doc -> Doc
instance Language.LambdaPi.Syntax.Print.Print GHC.Types.Char
instance Language.LambdaPi.Syntax.Print.Print (Language.LambdaPi.Syntax.Abs.Command' a)
instance Language.LambdaPi.Syntax.Print.Print GHC.Types.Double
instance Language.LambdaPi.Syntax.Print.Print GHC.Num.Integer.Integer
instance Language.LambdaPi.Syntax.Print.Print a => Language.LambdaPi.Syntax.Print.Print [a]
instance Language.LambdaPi.Syntax.Print.Print GHC.Base.String
instance Language.LambdaPi.Syntax.Print.Print [Language.LambdaPi.Syntax.Abs.Command' a]
instance Language.LambdaPi.Syntax.Print.Print (Language.LambdaPi.Syntax.Abs.Pattern' a)
instance Language.LambdaPi.Syntax.Print.Print (Language.LambdaPi.Syntax.Abs.Program' a)
instance Language.LambdaPi.Syntax.Print.Print (Language.LambdaPi.Syntax.Abs.ScopedTerm' a)
instance Language.LambdaPi.Syntax.Print.Print (Language.LambdaPi.Syntax.Abs.Term' a)
instance Language.LambdaPi.Syntax.Print.Print Language.LambdaPi.Syntax.Abs.VarIdent


-- | Free foil implementation of the &lt;math&gt;-calculus (with pairs).
--   
--   Free foil provides <b>general</b> definitions or implementations for
--   the following:
--   
--   <ol>
--   <li>Freely generated (from a simple signature) scope-safe AST.</li>
--   <li>Correct capture-avoiding substitution (see
--   <a>substitute</a>).</li>
--   <li>Correct &lt;math&gt;-equivalence checks (see <a>alphaEquiv</a> and
--   <a>alphaEquivRefreshed</a>) as well as &lt;math&gt;-normalization (see
--   <a>refreshAST</a>).</li>
--   <li>Conversion helpers (see <a>convertToAST</a> and
--   <a>convertFromAST</a>).</li>
--   </ol>
--   
--   The following is provided via <b>generic</b> representation via
--   <a>kind-generics</a> (see <a>Generics.Kind</a>): 1. <tt>ZipMatch</tt>
--   instances for signatures (enabling general &lt;math&gt;-equivalence).
--   2. <tt>Sinkable</tt> instances for terms. 3. <tt>CoSinkable</tt>
--   instances for patterns.
--   
--   The following is <b>generated</b> using Template Haskell:
--   
--   <ol>
--   <li>Signature bifunctor for terms.</li>
--   <li>Convenient pattern synonyms.</li>
--   <li>Conversion between scope-safe and raw term representation.</li>
--   </ol>
--   
--   The following is implemented <b>manually</b> in this module:
--   
--   <ol>
--   <li>Computation of weak head normal form (WHNF), see <a>whnf</a>.</li>
--   <li>Entry point, gluing everything together. See
--   <a>defaultMain</a>.</li>
--   </ol>
--   
--   <b>Note:</b> free foil does not (easily) support patterns at the
--   moment, so only wildcard patterns and variable patterns are handled in
--   this implementation.
module Language.LambdaPi.Impl.FreeFoilTH

-- | <i>Generated</i> with <a>mkSignature</a>. A signature bifunctor,
--   specifying the nodes of a syntax tree corresponding to <a>Term'</a>.
data Term'Sig a scope term

-- | Corresponds to <a>Pi</a>.
PiSig :: a -> term -> scope -> Term'Sig a scope term

-- | Corresponds to <a>Lam</a>.
LamSig :: a -> scope -> Term'Sig a scope term

-- | Corresponds to <a>App</a>.
AppSig :: a -> term -> term -> Term'Sig a scope term

-- | Corresponds to <a>Product</a>.
ProductSig :: a -> term -> term -> Term'Sig a scope term

-- | Corresponds to <a>Pair</a>.
PairSig :: a -> term -> term -> Term'Sig a scope term

-- | Corresponds to <a>First</a>.
FirstSig :: a -> term -> Term'Sig a scope term

-- | Corresponds to <a>Second</a>.
SecondSig :: a -> term -> Term'Sig a scope term

-- | Corresponds to <a>Universe</a>.
UniverseSig :: a -> Term'Sig a scope term

-- | <i>Generated</i> with <a>mkPatternSynonyms</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>UniverseSig</a>.
pattern Universe :: a -> AST binder (Term'Sig a) n

-- | <i>Generated</i> with <a>mkPatternSynonyms</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>SecondSig</a>.
pattern Second :: a -> AST binder (Term'Sig a) n -> AST binder (Term'Sig a) n

-- | <i>Generated</i> with <a>mkPatternSynonyms</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>FirstSig</a>.
pattern First :: a -> AST binder (Term'Sig a) n -> AST binder (Term'Sig a) n

-- | <i>Generated</i> with <a>mkPatternSynonyms</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>PairSig</a>.
pattern Pair :: a -> AST binder (Term'Sig a) n -> AST binder (Term'Sig a) n -> AST binder (Term'Sig a) n

-- | <i>Generated</i> with <a>mkPatternSynonyms</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>ProductSig</a>.
pattern Product :: a -> AST binder (Term'Sig a) n -> AST binder (Term'Sig a) n -> AST binder (Term'Sig a) n

-- | <i>Generated</i> with <a>mkPatternSynonyms</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>AppSig</a>.
pattern App :: a -> AST binder (Term'Sig a) n -> AST binder (Term'Sig a) n -> AST binder (Term'Sig a) n

-- | <i>Generated</i> with <a>mkPatternSynonyms</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>LamSig</a>.
pattern Lam :: () => a -> binder n l1 -> AST binder (Term'Sig a) l1 -> AST binder (Term'Sig a) n

-- | <i>Generated</i> with <a>mkPatternSynonyms</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>PiSig</a>.
pattern Pi :: () => a -> AST binder (Term'Sig a) n -> binder n l2 -> AST binder (Term'Sig a) l2 -> AST binder (Term'Sig a) n

-- | <i>Generated</i> with <a>mkConvertToSig</a>. Perform one step of
--   converting <a>Term'</a>, peeling off one node of type <a>Term'Sig</a>.
convertToTerm'Sig :: Term' a -> Either VarIdent (Term'Sig a (Pattern' a, ScopedTerm' a) (Term' a))

-- | <i>Generated</i> with <a>mkGetPatternBinder</a>. Extract at most one
--   binder from a pattern or <b>crash</b>.
getPattern'Binder :: Pattern' a -> Maybe VarIdent

-- | <i>Generated</i> with <a>mkGetScopedTerm</a>. Extract scoped term or
--   <b>crash</b>.
getTerm'FromScopedTerm' :: ScopedTerm' a -> Term' a

-- | <i>Generated</i> with <a>mkConvertFromSig</a>. Perform one step of
--   converting <a>Term'</a>, peeling off one node of type <a>Term'Sig</a>.
convertFromTerm'Sig :: Term'Sig a (Pattern' a, ScopedTerm' a) (Term' a) -> Term' a

-- | <i>Generated</i> with <a>mkFoilPattern</a>. A scope-safe version of
--   <a>Pattern'</a>.
data FoilPattern' a (n :: S) (l :: S)

-- | Corresponds to <a>PatternWildcard</a>.
[FoilPatternWildcard] :: forall a (n :: S). a -> FoilPattern' a n n

-- | Corresponds to <a>PatternVar</a>.
[FoilPatternVar] :: forall a (n :: S) (l :: S). a -> NameBinder n l -> FoilPattern' a n l

-- | Corresponds to <a>PatternPair</a>.
[FoilPatternPair] :: forall a (n :: S) (n2 :: S) (l :: S). a -> FoilPattern' a n n2 -> FoilPattern' a n2 l -> FoilPattern' a n l

-- | <i>Generated</i> with <a>mkToFoilPattern</a>. Convert a raw pattern
--   into a scope-safe pattern.
toFoilPattern' :: forall (n :: S) a r. Distinct n => Scope n -> Map VarIdent (Name n) -> Pattern' a -> (forall (l :: S). DExt n l => FoilPattern' a n l -> Map VarIdent (Name l) -> r) -> r

-- | <i>Generated</i> with <a>mkFromFoilPattern</a>. Convert a scope-safe
--   pattern into a raw pattern.
fromFoilPattern' :: forall a (n :: S) (l :: S). (Int -> VarIdent) -> FoilPattern' a n l -> Pattern' a

-- | Generic annotated scope-safe &lt;math&gt;-terms with patterns.
type Term' a = AST FoilPattern' a Term'Sig a

-- | Scode-safe &lt;math&gt;-terms annotated with source code position.
type Term = Term' BNFC'Position

-- | Scope-safe patterns annotated with source code position.
type FoilPattern = FoilPattern' BNFC'Position

-- | Convert <a>Term'</a> into a scope-safe term. This is a special case of
--   <a>convertToAST</a>.
toTerm' :: forall (n :: S) a. Distinct n => Scope n -> Map VarIdent (Name n) -> Term' a -> Term' a n

-- | Convert <a>Term'</a> into a closed scope-safe term. This is a special
--   case of <a>toTerm'</a>.
toTerm'Closed :: Term' a -> Term' a 'VoidS

-- | Convert a scope-safe representation back into <a>Term'</a>. This is a
--   special case of <a>convertFromAST</a>.
--   
--   <a>VarIdent</a> names are generated based on the raw identifiers in
--   the underlying foil representation.
--   
--   This function does not recover location information for variables,
--   patterns, or scoped terms.
fromTerm' :: forall a (n :: S). Term' a n -> Term' a

-- | Match a pattern against an term.
matchPattern :: forall (n :: S) (l :: S). FoilPattern n l -> Term n -> Substitution Term l n

-- | Compute weak head normal form (WHNF) of a &lt;math&gt;-term.
--   
--   <pre>
--   &gt;&gt;&gt; whnf Foil.emptyScope "(λx.(λ_.x)(λy.x))(λ(y,z).z)"
--   λ (x0, x1) . x1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; whnf Foil.emptyScope "(λs.λz.s(s(z)))(λs.λz.s(s(z)))"
--   λ x1 . (λ x0 . λ x1 . x0 (x0 x1)) ((λ x0 . λ x1 . x0 (x0 x1)) x1)
--   </pre>
--   
--   Note that during computation bound variables can become unordered in
--   the sense that binders may easily repeat or decrease. For example, in
--   the following expression, inner binder has lower index that the outer
--   one:
--   
--   <pre>
--   &gt;&gt;&gt; whnf Foil.emptyScope "(λx.λy.x)(λx.x)"
--   λ x1 . λ x0 . x0
--   </pre>
--   
--   At the same time, without substitution, we get regular, increasing
--   binder indices:
--   
--   <pre>
--   &gt;&gt;&gt; "λx.λy.y" :: Term Foil.VoidS
--   λ x0 . λ x1 . x1
--   </pre>
--   
--   To compare terms for &lt;math&gt;-equivalence, we may use
--   <a>alphaEquiv</a>:
--   
--   <pre>
--   &gt;&gt;&gt; alphaEquiv Foil.emptyScope (whnf Foil.emptyScope "(λx.λy.x)(λx.x)") "λx.λy.y"
--   True
--   </pre>
--   
--   We may also normalize binders using <a>refreshAST</a>:
--   
--   <pre>
--   &gt;&gt;&gt; refreshAST Foil.emptyScope (whnf Foil.emptyScope "(λx.λy.x)(λx.x)")
--   λ x0 . λ x1 . x1
--   </pre>
whnf :: forall (n :: S). Distinct n => Scope n -> Term n -> Term n

-- | Interpret a &lt;math&gt; command.
interpretCommand :: Command -> IO ()

-- | Interpret a &lt;math&gt; program.
interpretProgram :: Program -> IO ()

-- | A &lt;math&gt; interpreter implemented via the free foil.
defaultMain :: IO ()
instance Data.Bifoldable.Bifoldable (Language.LambdaPi.Impl.FreeFoilTH.Term'Sig a)
instance Data.Bifunctor.Bifunctor (Language.LambdaPi.Impl.FreeFoilTH.Term'Sig a)
instance Data.Bitraversable.Bitraversable (Language.LambdaPi.Impl.FreeFoilTH.Term'Sig a)
instance Control.Monad.Foil.Internal.CoSinkable (Language.LambdaPi.Impl.FreeFoilTH.FoilPattern' a)
instance Data.Foldable.Foldable (Language.LambdaPi.Impl.FreeFoilTH.Term'Sig a scope)
instance GHC.Base.Functor (Language.LambdaPi.Impl.FreeFoilTH.Term'Sig a scope)
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FreeFoilTH.FoilPattern' a n)
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FreeFoilTH.FoilPattern' a)
instance Generics.Kind.GenericK Language.LambdaPi.Impl.FreeFoilTH.FoilPattern'
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FreeFoilTH.Term'Sig a scope)
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FreeFoilTH.Term'Sig a)
instance Generics.Kind.GenericK Language.LambdaPi.Impl.FreeFoilTH.Term'Sig
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FreeFoilTH.FoilPattern' a n l)
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FreeFoilTH.Term'Sig a scope term)
instance GHC.Generics.Generic (Language.LambdaPi.Impl.FreeFoilTH.Term'Sig a scope term)
instance Control.Monad.Foil.Internal.HasNameBinders (Language.LambdaPi.Impl.FreeFoilTH.FoilPattern' a)
instance Data.String.IsString (Control.Monad.Free.Foil.AST Language.LambdaPi.Impl.FreeFoilTH.FoilPattern (Language.LambdaPi.Impl.FreeFoilTH.Term'Sig Language.LambdaPi.Syntax.Abs.BNFC'Position) 'Control.Monad.Foil.Internal.VoidS)
instance GHC.Show.Show (Control.Monad.Free.Foil.AST (Language.LambdaPi.Impl.FreeFoilTH.FoilPattern' a) (Language.LambdaPi.Impl.FreeFoilTH.Term'Sig a) 'Control.Monad.Foil.Internal.VoidS)
instance Control.Monad.Foil.Internal.SinkableK (Language.LambdaPi.Impl.FreeFoilTH.FoilPattern' a)
instance Data.Traversable.Traversable (Language.LambdaPi.Impl.FreeFoilTH.Term'Sig a scope)
instance Control.Monad.Foil.Internal.UnifiableInPattern Language.LambdaPi.Syntax.Abs.BNFC'Position
instance Control.Monad.Foil.Internal.UnifiablePattern (Language.LambdaPi.Impl.FreeFoilTH.FoilPattern' a)
instance Data.ZipMatchK.Generic.ZipMatchK a => Data.ZipMatchK.Generic.ZipMatchK (Language.LambdaPi.Impl.FreeFoilTH.Term'Sig a)
instance Data.ZipMatchK.Generic.ZipMatchK Language.LambdaPi.Syntax.Abs.BNFC'Position


-- | Free foil implementation of the &lt;math&gt;-calculus (with pairs).
--   
--   Free foil provides <b>general</b> definitions or implementations for
--   the following:
--   
--   <ol>
--   <li>Freely generated (from a simple signature) scope-safe AST.</li>
--   <li>Correct capture-avoiding substitution (see
--   <a>substitute</a>).</li>
--   <li>Correct &lt;math&gt;-equivalence checks (see <a>alphaEquiv</a> and
--   <a>alphaEquivRefreshed</a>) as well as &lt;math&gt;-normalization (see
--   <a>refreshAST</a>).</li>
--   <li>Conversion helpers (see <a>convertToAST</a> and
--   <a>convertFromAST</a>).</li>
--   </ol>
--   
--   The following is implemented <b>manually</b> in this module:
--   
--   <ol>
--   <li>Convenient pattern synonyms.</li>
--   <li><tt>ZipMatch</tt> instances (enabling general
--   &lt;math&gt;-equivalence).</li>
--   <li>Conversion between scope-safe and raw term representation (the
--   latter is generated via BNFC), see <a>toLambdaPi</a> and
--   <a>fromLambdaPi</a>.</li>
--   <li>Computation of weak head normal form (WHNF), see <a>whnf</a>.</li>
--   <li>Entry point, gluing everything together. See
--   <a>defaultMain</a>.</li>
--   </ol>
--   
--   <b>Note:</b> free foil does not (easily) support patterns at the
--   moment, so only wildcard patterns and variable patterns are handled in
--   this implementation.
--   
--   See <a>Language.LambdaPi.Impl.FreeFoilTH</a> for a variation of this
--   with more automation via Template Haskell.
module Language.LambdaPi.Impl.FreeFoil

-- | The signature <tt>Bifunctor</tt> for the &lt;math&gt;.
data LambdaPiF scope term

-- | Application: &lt;math&gt;
AppF :: term -> term -> LambdaPiF scope term

-- | Abstraction: &lt;math&gt;
LamF :: scope -> LambdaPiF scope term

-- | Dependent function type: &lt;math&gt;
PiF :: term -> scope -> LambdaPiF scope term

-- | Universe (type of types): &lt;math&gt;
UniverseF :: LambdaPiF scope term

-- | The signature <tt>Bifunctor</tt> for pairs.
data PairF scope term

-- | Pair: &lt;math&gt;
PairF :: term -> term -> PairF scope term

-- | First projection: &lt;math&gt;
FirstF :: term -> PairF scope term

-- | Second projection: &lt;math&gt;
SecondF :: term -> PairF scope term

-- | Product type (non-dependent): &lt;math&gt;
ProductF :: term -> term -> PairF scope term

-- | Sum of signature bifunctors.
type (:+:) = Sum :: Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type

-- | &lt;math&gt;-terms in scope <tt>n</tt>, freely generated from the sum
--   of signatures <a>LambdaPiF</a> and <a>PairF</a>.
type LambdaPi (n :: S) = AST NameBinder LambdaPiF :+: PairF n
pattern App :: LambdaPi n -> LambdaPi n -> LambdaPi n
pattern Lam :: () => NameBinder n l -> LambdaPi l -> LambdaPi n
pattern Pi :: () => NameBinder n l -> LambdaPi n -> LambdaPi l -> LambdaPi n
pattern Pair :: LambdaPi n -> LambdaPi n -> LambdaPi n
pattern First :: LambdaPi n -> LambdaPi n
pattern Second :: LambdaPi n -> LambdaPi n
pattern Product :: LambdaPi n -> LambdaPi n -> LambdaPi n
pattern Universe :: LambdaPi n

-- | Compute weak head normal form (WHNF) of a &lt;math&gt;-term.
--   
--   <pre>
--   &gt;&gt;&gt; whnf Foil.emptyScope "(λx.(λ_.x)(λy.x))(λy.λz.z)"
--   λ x0 . λ x1 . x1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; whnf Foil.emptyScope "(λs.λz.s(s(z)))(λs.λz.s(s(z)))"
--   λ x1 . (λ x0 . λ x1 . x0 (x0 x1)) ((λ x0 . λ x1 . x0 (x0 x1)) x1)
--   </pre>
--   
--   Note that during computation bound variables can become unordered in
--   the sense that binders may easily repeat or decrease. For example, in
--   the following expression, inner binder has lower index that the outer
--   one:
--   
--   <pre>
--   &gt;&gt;&gt; whnf Foil.emptyScope "(λx.λy.x)(λx.x)"
--   λ x1 . λ x0 . x0
--   </pre>
--   
--   At the same time, without substitution, we get regular, increasing
--   binder indices:
--   
--   <pre>
--   &gt;&gt;&gt; "λx.λy.y" :: LambdaPi Foil.VoidS
--   λ x0 . λ x1 . x1
--   </pre>
--   
--   To compare terms for &lt;math&gt;-equivalence, we may use
--   <a>alphaEquiv</a>:
--   
--   <pre>
--   &gt;&gt;&gt; alphaEquiv Foil.emptyScope (whnf Foil.emptyScope "(λx.λy.x)(λx.x)") "λx.λy.y"
--   True
--   </pre>
--   
--   We may also normalize binders using <a>refreshAST</a>:
--   
--   <pre>
--   &gt;&gt;&gt; refreshAST Foil.emptyScope (whnf Foil.emptyScope "(λx.λy.x)(λx.x)")
--   λ x0 . λ x1 . x1
--   </pre>
whnf :: forall (n :: S). Distinct n => Scope n -> LambdaPi n -> LambdaPi n

-- | Convert a raw &lt;math&gt;-abstraction into a scope-safe
--   &lt;math&gt;-term.
toLambdaPiLam :: forall (n :: S). Distinct n => Scope n -> Map VarIdent (Name n) -> Pattern -> ScopedTerm -> LambdaPi n

-- | Convert a raw &lt;math&gt;-type into a scope-safe &lt;math&gt;-term.
toLambdaPiPi :: forall (n :: S). Distinct n => Scope n -> Map VarIdent (Name n) -> Pattern -> Term -> ScopedTerm -> LambdaPi n

-- | Convert a raw expression into a scope-safe &lt;math&gt;-term.
toLambdaPi :: forall (n :: S). Distinct n => Scope n -> Map VarIdent (Name n) -> Term -> LambdaPi n

-- | Convert a raw expression into a <i>closed</i> scope-safe
--   &lt;math&gt;-term.
toLambdaPiClosed :: Term -> LambdaPi 'VoidS

-- | Convert back from a scope-safe &lt;math&gt;-term into a raw expression
--   or type.
fromLambdaPi :: forall (n :: S). [VarIdent] -> NameMap n VarIdent -> LambdaPi n -> Term

-- | Convert back from a scope-safe &lt;math&gt;-term into a raw expression
--   or type.
--   
--   In contrast to <a>fromLambdaPi</a>, this function uses the raw foil
--   identifiers (integers) to generate names for the variables. This makes
--   them transparent when printing.
fromLambdaPi' :: forall (n :: S). LambdaPi n -> Term

-- | Pretty-print a <i>closed</i> &lt;math&gt;-term.
ppLambdaPi :: LambdaPi 'VoidS -> String

-- | Interpret a &lt;math&gt; command.
interpretCommand :: Command -> IO ()

-- | Interpret a &lt;math&gt; program.
interpretProgram :: Program -> IO ()

-- | A &lt;math&gt; interpreter implemented via the free foil.
defaultMain :: IO ()
instance Data.Bifoldable.Bifoldable Language.LambdaPi.Impl.FreeFoil.LambdaPiF
instance Data.Bifoldable.Bifoldable Language.LambdaPi.Impl.FreeFoil.PairF
instance Data.Bifunctor.Bifunctor Language.LambdaPi.Impl.FreeFoil.LambdaPiF
instance Data.Bifunctor.Bifunctor Language.LambdaPi.Impl.FreeFoil.PairF
instance Data.Bitraversable.Bitraversable Language.LambdaPi.Impl.FreeFoil.LambdaPiF
instance Data.Bitraversable.Bitraversable Language.LambdaPi.Impl.FreeFoil.PairF
instance (GHC.Classes.Eq term, GHC.Classes.Eq scope) => GHC.Classes.Eq (Language.LambdaPi.Impl.FreeFoil.LambdaPiF scope term)
instance GHC.Classes.Eq term => GHC.Classes.Eq (Language.LambdaPi.Impl.FreeFoil.PairF scope term)
instance Data.Foldable.Foldable (Language.LambdaPi.Impl.FreeFoil.LambdaPiF scope)
instance Data.Foldable.Foldable (Language.LambdaPi.Impl.FreeFoil.PairF scope)
instance GHC.Base.Functor (Language.LambdaPi.Impl.FreeFoil.LambdaPiF scope)
instance GHC.Base.Functor (Language.LambdaPi.Impl.FreeFoil.PairF scope)
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FreeFoil.LambdaPiF scope)
instance Generics.Kind.GenericK Language.LambdaPi.Impl.FreeFoil.LambdaPiF
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FreeFoil.PairF scope)
instance Generics.Kind.GenericK Language.LambdaPi.Impl.FreeFoil.PairF
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FreeFoil.LambdaPiF scope term)
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FreeFoil.PairF scope term)
instance Data.String.IsString (Language.LambdaPi.Impl.FreeFoil.LambdaPi 'Control.Monad.Foil.Internal.VoidS)
instance GHC.Show.Show (Language.LambdaPi.Impl.FreeFoil.LambdaPi 'Control.Monad.Foil.Internal.VoidS)
instance (GHC.Show.Show term, GHC.Show.Show scope) => GHC.Show.Show (Language.LambdaPi.Impl.FreeFoil.LambdaPiF scope term)
instance GHC.Show.Show term => GHC.Show.Show (Language.LambdaPi.Impl.FreeFoil.PairF scope term)
instance Data.Traversable.Traversable (Language.LambdaPi.Impl.FreeFoil.LambdaPiF scope)
instance Data.Traversable.Traversable (Language.LambdaPi.Impl.FreeFoil.PairF scope)
instance Data.ZipMatchK.Generic.ZipMatchK Language.LambdaPi.Impl.FreeFoil.LambdaPiF
instance Data.ZipMatchK.Generic.ZipMatchK Language.LambdaPi.Impl.FreeFoil.PairF


-- | Foil implementation of the &lt;math&gt;-calculus (with pairs) using
--   Template Haskell and <a>Generics.Kind</a> to reduce boilerplate.
--   
--   Template Haskell helpers <b>generate</b> the following:
--   
--   <ol>
--   <li>Scope-safe AST, generated from a raw definition. See
--   <a>FoilTerm</a>, <tt>FoilScopedTerm</tt>, and <a>FoilPattern</a>.</li>
--   <li>Conversion between scope-safe and raw term representation (the
--   latter is generated via BNFC), see <a>toFoilTerm'</a> and
--   <a>fromFoilTerm'</a>.</li>
--   <li>Helper functions for patterns. See <a>extendScopeFoilPattern'</a>
--   and <a>withRefreshedFoilPattern'</a>.</li>
--   </ol>
--   
--   The following is provided via kind-polymophic generics (see
--   <a>Generics.Kind</a>):
--   
--   <ol>
--   <li><a>Sinkable</a> instance for <a>FoilTerm'</a>.</li>
--   <li><a>CoSinkable</a> instance for <a>FoilPattern'</a>, giving access
--   to <a>extendScopePattern</a> and <a>withRefreshedPattern</a> (among
--   other utilities).</li>
--   </ol>
--   
--   The following is implemented <b>manually</b> in this module:
--   
--   <ol>
--   <li>Correct capture-avoiding substitution (see
--   <a>substitute</a>).</li>
--   <li>Computation of weak head normal form (WHNF), see <a>whnf</a>.</li>
--   <li>Entry point, gluing everything together. See
--   <a>defaultMain</a>.</li>
--   </ol>
--   
--   The following is <b>not implemented</b>:
--   
--   <ol>
--   <li>&lt;math&gt;-equivalence checks and &lt;math&gt;-normalization
--   helpers.</li>
--   </ol>
--   
--   This implementation supports (nested) patterns for pairs.
module Language.LambdaPi.Impl.FoilTH

-- | <i>Generated</i> with <a>mkFoilPattern</a>. A scope-safe version of
--   <a>Pattern'</a>.
data FoilPattern' a (n :: S) (l :: S)

-- | Corresponds to <a>PatternWildcard</a>.
[FoilPatternWildcard] :: forall a (n :: S). a -> FoilPattern' a n n

-- | Corresponds to <a>PatternVar</a>.
[FoilPatternVar] :: forall a (n :: S) (l :: S). a -> NameBinder n l -> FoilPattern' a n l

-- | Corresponds to <a>PatternPair</a>.
[FoilPatternPair] :: forall a (n :: S) (n2 :: S) (l :: S). a -> FoilPattern' a n n2 -> FoilPattern' a n2 l -> FoilPattern' a n l

-- | <i>Generated</i> with <a>mkFoilData</a>. A scope-safe version of
--   <a>ScopedTerm'</a>.
data FoilScopedTerm' a (n :: S)
FoilAScopedTerm :: a -> FoilTerm' a n -> FoilScopedTerm' a (n :: S)

-- | <i>Generated</i> with <a>mkFoilData</a>. A scope-safe version of
--   <a>Term'</a>.
data FoilTerm' a (n :: S)
[FoilVar] :: forall a (n :: S). a -> Name n -> FoilTerm' a n
[FoilPi] :: forall a (n :: S) (l :: S). a -> FoilPattern' a n l -> FoilTerm' a n -> FoilScopedTerm' a l -> FoilTerm' a n
[FoilLam] :: forall a (n :: S) (l :: S). a -> FoilPattern' a n l -> FoilScopedTerm' a l -> FoilTerm' a n
[FoilApp] :: forall a (n :: S). a -> FoilTerm' a n -> FoilTerm' a n -> FoilTerm' a n
[FoilProduct] :: forall a (n :: S). a -> FoilTerm' a n -> FoilTerm' a n -> FoilTerm' a n
[FoilPair] :: forall a (n :: S). a -> FoilTerm' a n -> FoilTerm' a n -> FoilTerm' a n
[FoilFirst] :: forall a (n :: S). a -> FoilTerm' a n -> FoilTerm' a n
[FoilSecond] :: forall a (n :: S). a -> FoilTerm' a n -> FoilTerm' a n
[FoilUniverse] :: forall a (n :: S). a -> FoilTerm' a n

-- | <i>Generated</i> with <a>mkExtendScopeFoilPattern</a>. Extend a scope
--   with the names bound by the given pattern. This is a more flexible
--   version of <a>extendScope</a>.
extendScopeFoilPattern' :: forall a (n :: S) (l :: S). FoilPattern' a n l -> Scope n -> Scope l

-- | <i>Generated</i> with <a>mkWithRefreshedFoilPattern</a>. Refresh (if
--   needed) bound variables introduced in a pattern. This is a more
--   flexible version of <a>withRefreshed</a>.
withRefreshedFoilPattern' :: forall a (o :: S) (e :: S -> Type) (n :: S) (l :: S) r. (Distinct o, InjectName e, Sinkable e) => Scope o -> FoilPattern' a n l -> (forall (o' :: S). DExt o o' => (Substitution e n o -> Substitution e l o') -> FoilPattern' a o o' -> r) -> r

-- | <i>Generated</i> with <a>mkToFoilTerm</a>. Convert a raw term into a
--   scope-safe term.
toFoilTerm' :: forall (n :: S) a. Distinct n => Scope n -> Map VarIdent (Name n) -> Term' a -> FoilTerm' a n

-- | <i>Generated</i> with <a>mkToFoilTerm</a>. Convert a raw pattern into
--   a scope-safe pattern.
toFoilPattern' :: forall (n :: S) a r. Distinct n => Scope n -> Map VarIdent (Name n) -> Pattern' a -> (forall (l :: S). DExt n l => FoilPattern' a n l -> Map VarIdent (Name l) -> r) -> r

-- | <i>Generated</i> with <a>mkToFoilTerm</a>. Convert a raw scoped term
--   into a scope-safe scoped term.
toFoilScopedTerm' :: forall (n :: S) a. Distinct n => Scope n -> Map VarIdent (Name n) -> ScopedTerm' a -> FoilScopedTerm' a n

-- | <i>Generated</i> with <a>mkFromFoil</a>. Convert a scope-safe term
--   into a raw term.
fromFoilTerm' :: forall (n :: S) a. [VarIdent] -> NameMap n VarIdent -> FoilTerm' a n -> Term' a

-- | <i>Generated</i> with <a>mkFromFoil</a>. Convert a scope-safe pattern
--   into a raw pattern.
fromFoilPattern' :: forall (n :: S) a (l :: S) r. [VarIdent] -> NameMap n VarIdent -> FoilPattern' a n l -> ([VarIdent] -> NameMap l VarIdent -> Pattern' a -> r) -> r

-- | <i>Generated</i> with <a>mkFromFoil</a>. Convert a scope-safe scoped
--   term into a raw scoped term.
fromFoilScopedTerm' :: forall (n :: S) a. [VarIdent] -> NameMap n VarIdent -> FoilScopedTerm' a n -> ScopedTerm' a
type FoilTerm = FoilTerm' BNFC'Position
type FoilPattern = FoilPattern' BNFC'Position

-- | Convert a <i>closed</i> scope-safe term into a raw term.
fromFoilTermClosed :: [VarIdent] -> FoilTerm 'VoidS -> Term

-- | Perform substitution in a &lt;math&gt;-term.
substitute :: forall (o :: S) (i :: S). Distinct o => Scope o -> Substitution FoilTerm i o -> FoilTerm i -> FoilTerm o

-- | Match a pattern against an expression.
matchPattern :: forall (n :: S) (l :: S). FoilPattern n l -> FoilTerm n -> Substitution FoilTerm l n

-- | Compute weak head normal form (WHNF).
whnf :: forall (n :: S). Distinct n => Scope n -> FoilTerm n -> FoilTerm n

-- | Interpret a &lt;math&gt; command.
interpretCommand :: Command -> IO ()

-- | Interpret a &lt;math&gt; program.
interpretProgram :: Program -> IO ()

-- | Default interpreter program. Reads a &lt;math&gt; program from the
--   standard input and runs the commands.
defaultMain :: IO ()

-- | Pretty-print a <i>closed</i> scode-safe &lt;math&gt;-term using
--   BNFC-generated printer (via <a>Term</a>).
printFoilTerm :: FoilTerm 'VoidS -> String
instance Control.Monad.Foil.Internal.CoSinkable (Language.LambdaPi.Impl.FoilTH.FoilPattern' a)
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FoilTH.FoilPattern' a n)
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FoilTH.FoilPattern' a)
instance Generics.Kind.GenericK Language.LambdaPi.Impl.FoilTH.FoilPattern'
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FoilTH.FoilScopedTerm' a)
instance Generics.Kind.GenericK Language.LambdaPi.Impl.FoilTH.FoilScopedTerm'
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FoilTH.FoilTerm' a)
instance Generics.Kind.GenericK Language.LambdaPi.Impl.FoilTH.FoilTerm'
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FoilTH.FoilPattern' a n l)
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FoilTH.FoilScopedTerm' a n)
instance Generics.Kind.GenericK (Language.LambdaPi.Impl.FoilTH.FoilTerm' a n)
instance Control.Monad.Foil.Internal.HasNameBinders (Language.LambdaPi.Impl.FoilTH.FoilPattern' a)
instance Control.Monad.Foil.Internal.InjectName (Language.LambdaPi.Impl.FoilTH.FoilTerm' a)
instance Control.Monad.Foil.Internal.Sinkable (Language.LambdaPi.Impl.FoilTH.FoilTerm' a)
instance Control.Monad.Foil.Internal.SinkableK (Language.LambdaPi.Impl.FoilTH.FoilPattern' a)
instance Control.Monad.Foil.Internal.SinkableK (Language.LambdaPi.Impl.FoilTH.FoilScopedTerm' a)
instance Control.Monad.Foil.Internal.SinkableK (Language.LambdaPi.Impl.FoilTH.FoilTerm' a)


-- | Foil implementation of the &lt;math&gt;-calculus (with pairs).
--   
--   The following is implemented <b>manually</b> in this module:
--   
--   <ol>
--   <li>Scope-safe AST for &lt;math&gt;-terms.</li>
--   <li>Correct capture-avoiding substitution (see
--   <a>substitute</a>).</li>
--   <li>Conversion between scope-safe and raw term representation (the
--   latter is generated via BNFC), see <a>toFoilTerm</a> and
--   <a>fromFoilTerm</a>.</li>
--   <li>Helper functions for patterns. See <a>extendScopePattern</a> and
--   <a>withRefreshedPattern</a>.</li>
--   <li>&lt;math&gt;-equivalence checks (<a>alphaEquiv</a> and
--   <a>alphaEquivRefreshed</a>) and &lt;math&gt;-normalization helpers
--   (<a>refreshExpr</a>).</li>
--   <li>Computation of weak head normal form (WHNF) and normal form (NF),
--   see <a>whnf</a> and <tt>nf</tt>.</li>
--   <li>Entry point, gluing everything together. See
--   <a>defaultMain</a>.</li>
--   </ol>
--   
--   This implementation supports (nested) patterns for pairs.
--   
--   This is a baseline implementation, see other examples for partial
--   automation:
--   
--   <ol>
--   <li><a>Language.LambdaPi.Impl.FreeFoil</a> allows to reuse generalized
--   substitution and &lt;math&gt;-equivalence (and, in theory, more
--   complicated algorithms).</li>
--   <li><a>Language.LambdaPi.Impl.FoilTH</a> works well with patterns and
--   generates conversion functions and helpers for patterns.</li>
--   <li><a>Language.LambdaPi.Impl.FreeFoilTH</a> combines the benefits of
--   the above, when it is possible to generate the signature
--   automatically.</li>
--   </ol>
module Language.LambdaPi.Impl.Foil

-- | Type of scope-safe &lt;math&gt;-terms with pairs.
data Expr (n :: S)

-- | Variables: &lt;math&gt;
[VarE] :: forall (n :: S). Name n -> Expr n

-- | Application: &lt;math&gt;
[AppE] :: forall (n :: S). Expr n -> Expr n -> Expr n

-- | Abstraction (with patterns): &lt;math&gt;
[LamE] :: forall (n :: S) (l :: S). Pattern n l -> Expr l -> Expr n

-- | &lt;math&gt;-types (with patterns): &lt;math&gt;
[PiE] :: forall (n :: S) (l :: S). Pattern n l -> Expr n -> Expr l -> Expr n

-- | Pair of terms: &lt;math&gt;
[PairE] :: forall (n :: S). Expr n -> Expr n -> Expr n

-- | First projection: &lt;math&gt;
[FirstE] :: forall (n :: S). Expr n -> Expr n

-- | Second projection: &lt;math&gt;
[SecondE] :: forall (n :: S). Expr n -> Expr n

-- | Product type (non-dependent): &lt;math&gt;
[ProductE] :: forall (n :: S). Expr n -> Expr n -> Expr n

-- | Universe (type of types): &lt;math&gt;
[UniverseE] :: forall (n :: S). Expr n

-- | Patterns.
data Pattern (n :: S) (l :: S)

-- | Wildcard pattern: &lt;math&gt;
[PatternWildcard] :: forall (n :: S). Pattern n n

-- | Variable pattern: &lt;math&gt;
[PatternVar] :: forall (n :: S) (l :: S). NameBinder n l -> Pattern n l

-- | Pair pattern: &lt;math&gt;
[PatternPair] :: forall (n :: S) (i :: S) (l :: S). Pattern n i -> Pattern i l -> Pattern n l

-- | Default way to print a name using its internal <tt>Id</tt>.
ppName :: forall (n :: S). Name n -> String

-- | Pretty-print a &lt;math&gt;-term directly (without converting to raw
--   term).
--   
--   <pre>
--   &gt;&gt;&gt; ppExpr identity
--   "\955x0. x0"
--   
--   &gt;&gt;&gt; ppExpr (churchN 2)
--   "\955x0. \955x1. x0 (x0 (x1))"
--   </pre>
ppExpr :: forall (n :: S). Expr n -> String

-- | Pretty-print a pattern in a &lt;math&gt;-term (without converting to
--   raw pattern)..
ppPattern :: forall (n :: S) (l :: S). Pattern n l -> String

-- | Pretty-print a <i>closed</i> scode-safe &lt;math&gt;-term using
--   BNFC-generated printer (via <a>Term</a>).
printExpr :: Expr 'VoidS -> String

-- | Perform substitution in a &lt;math&gt;-term.
substitute :: forall (o :: S) (i :: S). Distinct o => Scope o -> Substitution Expr i o -> Expr i -> Expr o

-- | Perform substitution in a &lt;math&gt;-term and normalize binders in
--   the process.
substituteRefresh :: forall (o :: S) (i :: S). Distinct o => Scope o -> Substitution Expr i o -> Expr i -> Expr o

-- | Convert a raw pattern into a scope-safe one.
toFoilPattern :: forall (n :: S) r. Distinct n => Scope n -> Map VarIdent (Name n) -> Pattern -> (forall (l :: S). DExt n l => Pattern n l -> Map VarIdent (Name l) -> r) -> r

-- | Convert a raw term into a scope-safe &lt;math&gt;-term.
toFoilTerm :: forall (n :: S). Distinct n => Scope n -> Map VarIdent (Name n) -> Term -> Expr n

-- | Convert a raw term into a closed scope-safe term.
toFoilTermClosed :: Term -> Expr 'VoidS

-- | Convert a scope-safe pattern into a raw pattern.
fromFoilPattern :: forall (n :: S) (l :: S) r. [VarIdent] -> NameMap n VarIdent -> Pattern n l -> ([VarIdent] -> NameMap l VarIdent -> Pattern -> r) -> r

-- | Convert a scope-safe term into a raw term.
fromFoilTerm :: forall (n :: S). [VarIdent] -> NameMap n VarIdent -> Expr n -> Term

-- | Convert a <i>closed</i> scope-safe term into a raw term.
fromFoilTermClosed :: [VarIdent] -> Expr 'VoidS -> Term

-- | Convert a scope-safe pattern into a raw pattern converting raw
--   identifiers directly into <a>VarIdent</a>
fromFoilPattern' :: forall (n :: S) (l :: S). Pattern n l -> Pattern

-- | Convert a scope-safe term into a raw term converting raw identifiers
--   directly into <a>VarIdent</a>.
fromFoilTerm' :: forall (n :: S). Expr n -> Term

-- | Match a pattern against an expression.
matchPattern :: forall (n :: S) (l :: S). Pattern n l -> Expr n -> Substitution Expr l n

-- | Compute weak head normal form (WHNF).
--   
--   <pre>
--   &gt;&gt;&gt; whnf emptyScope "(λx.(λ_.x)(λy.x))(λy.λz.z)"
--   λ x0 . λ x1 . x1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; whnf emptyScope "(λs.λz.s(s(z)))(λs.λz.s(s(z)))"
--   λ x1 . (λ x0 . λ x1 . x0 (x0 x1)) ((λ x0 . λ x1 . x0 (x0 x1)) x1)
--   </pre>
--   
--   Note that during computation bound variables can become unordered in
--   the sense that binders may easily repeat or decrease. For example, in
--   the following expression, inner binder has lower index that the outer
--   one:
--   
--   <pre>
--   &gt;&gt;&gt; whnf emptyScope "(λx.λy.x)(λx.x)"
--   λ x1 . λ x0 . x0
--   </pre>
--   
--   At the same time, without substitution, we get regular, increasing
--   binder indices:
--   
--   <pre>
--   &gt;&gt;&gt; "λx.λy.y" :: Expr VoidS
--   λ x0 . λ x1 . x1
--   </pre>
--   
--   To compare terms for &lt;math&gt;-equivalence, we may use
--   <a>alphaEquiv</a>:
--   
--   <pre>
--   &gt;&gt;&gt; alphaEquiv emptyScope (whnf emptyScope "(λx.λy.x)(λx.x)") "λx.λy.y"
--   True
--   </pre>
--   
--   We may also normalize binders using <a>refreshExpr</a>:
--   
--   <pre>
--   &gt;&gt;&gt; refreshExpr emptyScope (whnf emptyScope "(λx.λy.x)(λx.x)")
--   λ x0 . λ x1 . x1
--   </pre>
whnf :: forall (n :: S). Distinct n => Scope n -> Expr n -> Expr n

-- | Normalize all binder identifiers in an expression.
refreshExpr :: forall (n :: S). Distinct n => Scope n -> Expr n -> Expr n

-- | &lt;math&gt;-equivalence check for two terms in one scope via
--   normalization of bound identifiers (via <a>refreshExpr</a>).
--   
--   This function may perform some unnecessary changes of bound variables
--   when the binders are the same on both sides.
alphaEquivRefreshed :: forall (n :: S). Distinct n => Scope n -> Expr n -> Expr n -> Bool

-- | Unsafely check for equality of two <a>Pattern</a>s.
--   
--   This <b>does not</b> include &lt;math&gt;-equivalence!
unsafeEqPattern :: forall (n :: S) (l :: S) (n' :: S) (l' :: S). Pattern n l -> Pattern n' l' -> Bool

-- | Unsafely check for equality of two <a>Expr</a>s.
--   
--   This <b>does not</b> include &lt;math&gt;-equivalence!
unsafeEqExpr :: forall (n :: S) (l :: S). Expr n -> Expr l -> Bool

-- | &lt;math&gt;-equivalence check for two terms in one scope via
--   unification of bound variables (via <a>unifyNameBinders</a>).
--   
--   Compared to <a>alphaEquivRefreshed</a>, this function might skip
--   unnecessary changes of bound variables when both binders in two
--   matching scoped terms coincide.
alphaEquiv :: forall (n :: S). Distinct n => Scope n -> Expr n -> Expr n -> Bool

-- | Interpret a &lt;math&gt; command.
interpretCommand :: Command -> IO ()

-- | Interpret a &lt;math&gt; program.
interpretProgram :: Program -> IO ()

-- | Default interpreter program. Reads a &lt;math&gt; program from the
--   standard input and runs the commands.
defaultMain :: IO ()

-- | A helper for constructing &lt;math&gt;-abstractions.
lam :: forall (n :: S). Distinct n => Scope n -> (forall (l :: S). DExt n l => Scope l -> NameBinder n l -> Expr l) -> Expr n

-- | An identity function as a &lt;math&gt;-term:
--   
--   <pre>
--   &gt;&gt;&gt; identity
--   λ x0 . x0
--   </pre>
identity :: Expr 'VoidS

-- | Church-encoding of a natural number &lt;math&gt;.
--   
--   <pre>
--   &gt;&gt;&gt; churchN 0
--   λ x0 . λ x1 . x1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; churchN 3
--   λ x0 . λ x1 . x0 (x0 (x0 x1))
--   </pre>
churchN :: Int -> Expr 'VoidS
instance Control.Monad.Foil.Internal.CoSinkable Language.LambdaPi.Impl.Foil.Pattern
instance Control.Monad.Foil.Internal.InjectName Language.LambdaPi.Impl.Foil.Expr
instance Data.String.IsString (Language.LambdaPi.Impl.Foil.Expr 'Control.Monad.Foil.Internal.VoidS)
instance Control.Monad.Foil.Relative.RelMonad Control.Monad.Foil.Internal.Name Language.LambdaPi.Impl.Foil.Expr
instance GHC.Show.Show (Language.LambdaPi.Impl.Foil.Expr 'Control.Monad.Foil.Internal.VoidS)
instance Control.Monad.Foil.Internal.Sinkable Language.LambdaPi.Impl.Foil.Expr
instance Control.Monad.Foil.Internal.UnifiablePattern Language.LambdaPi.Impl.Foil.Pattern
