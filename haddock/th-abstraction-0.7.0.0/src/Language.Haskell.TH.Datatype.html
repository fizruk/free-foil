<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="local-6989586621679072816"><span id="local-6989586621679072817"><span id="local-6989586621679072818"><span id="local-6989586621679072819"><span id="local-6989586621679072820"><span id="local-6989586621679072821"><span id="local-6989586621679072822"><span id="local-6989586621679072823"><span id="local-6989586621679072824"><span id="local-6989586621679072825"><span id="local-6989586621679072826"><span id="local-6989586621679072827"><span id="local-6989586621679072828"><span id="local-6989586621679072829"><span id="local-6989586621679072830"><span id="local-6989586621679072831"><span id="local-6989586621679072832"><span id="local-6989586621679072833"><span id="local-6989586621679072834"><span id="local-6989586621679072835"><span id="local-6989586621679072836"><span id="local-6989586621679072837"><span id="local-6989586621679072838"><span id="local-6989586621679072839"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-pragma">{-# Language CPP, DeriveDataTypeable, ScopedTypeVariables, TupleSections #-}</span><span class="hs-cpp">

#if MIN_VERSION_base(4,4,0)
</span><span class="hs-cpp">#define HAS_GENERICS
</span><span class="hs-pragma">{-# Language DeriveGeneric #-}</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,12,0)
</span><span class="hs-pragma">{-# Language Safe #-}</span><span class="hs-cpp">
#elif __GLASGOW_HASKELL__ &gt;= 702
</span><span class="hs-pragma">{-# Language Trustworthy #-}</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-14"></span><span class="annot"><span class="hs-comment">{-|
Module      : Language.Haskell.TH.Datatype
Description : Backwards-compatible interface to reified information about datatypes.
Copyright   : Eric Mertens 2017-2020
License     : ISC
Maintainer  : emertens@gmail.com

This module provides a flattened view of information about data types
and newtypes that can be supported uniformly across multiple versions
of the @template-haskell@ package.

Sample output for @'reifyDatatype' ''Maybe@

@
'DatatypeInfo'
 { 'datatypeContext'   = []
 , 'datatypeName'      = GHC.Base.Maybe
 , 'datatypeVars'      = [ 'KindedTV' a_3530822107858468866 () 'StarT' ]
 , 'datatypeInstTypes' = [ 'SigT' ('VarT' a_3530822107858468866) 'StarT' ]
 , 'datatypeVariant'   = 'Datatype'
 , 'datatypeReturnKind' = 'StarT'
 , 'datatypeCons'      =
     [ 'ConstructorInfo'
         { 'constructorName'       = GHC.Base.Nothing
         , 'constructorVars'       = []
         , 'constructorContext'    = []
         , 'constructorFields'     = []
         , 'constructorStrictness' = []
         , 'constructorVariant'    = 'NormalConstructor'
         }
     , 'ConstructorInfo'
         { 'constructorName'       = GHC.Base.Just
         , 'constructorVars'       = []
         , 'constructorContext'    = []
         , 'constructorFields'     = [ 'VarT' a_3530822107858468866 ]
         , 'constructorStrictness' = [ 'FieldStrictness'
                                         'UnspecifiedUnpackedness'
                                         'Lazy'
                                     ]
         , 'constructorVariant'    = 'NormalConstructor'
         }
     ]
 }
@

Datatypes declared with GADT syntax are normalized to constructors with existentially
quantified type variables and equality constraints.

-}</span></span><span>
</span><span id="line-63"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.TH.Datatype</span><span>
</span><span id="line-64"></span><span>  </span><span class="hs-special">(</span><span>
</span><span id="line-65"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Types</span></span><span>
</span><span id="line-66"></span><span>    </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier">DatatypeInfo</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-67"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier">ConstructorInfo</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-68"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier">DatatypeVariant</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-69"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorVariant"><span class="hs-identifier">ConstructorVariant</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-70"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier">FieldStrictness</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-71"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Unpackedness"><span class="hs-identifier">Unpackedness</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-72"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Strictness"><span class="hs-identifier">Strictness</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-73"></span><span>
</span><span id="line-74"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Normalization functions</span></span><span>
</span><span id="line-75"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyDatatype"><span class="hs-identifier">reifyDatatype</span></a></span><span>
</span><span id="line-76"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyConstructor"><span class="hs-identifier">reifyConstructor</span></a></span><span>
</span><span id="line-77"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyRecord"><span class="hs-identifier">reifyRecord</span></a></span><span>
</span><span id="line-78"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeInfo"><span class="hs-identifier">normalizeInfo</span></a></span><span>
</span><span id="line-79"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeDec"><span class="hs-identifier">normalizeDec</span></a></span><span>
</span><span id="line-80"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeCon"><span class="hs-identifier">normalizeCon</span></a></span><span>
</span><span id="line-81"></span><span>
</span><span id="line-82"></span><span>  </span><span class="annot"><span class="hs-comment">-- * 'DatatypeInfo' lookup functions</span></span><span>
</span><span id="line-83"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#lookupByConstructorName"><span class="hs-identifier">lookupByConstructorName</span></a></span><span>
</span><span id="line-84"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#lookupByRecordName"><span class="hs-identifier">lookupByRecordName</span></a></span><span>
</span><span id="line-85"></span><span>
</span><span id="line-86"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Type variable manipulation</span></span><span>
</span><span id="line-87"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier">TypeSubstitution</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-88"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#quantifyType"><span class="hs-identifier">quantifyType</span></a></span><span>
</span><span id="line-89"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier">freeVariablesWellScoped</span></a></span><span>
</span><span id="line-90"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#freshenFreeVariables"><span class="hs-identifier">freshenFreeVariables</span></a></span><span>
</span><span id="line-91"></span><span>
</span><span id="line-92"></span><span>  </span><span class="annot"><span class="hs-comment">-- * 'Pred' functions</span></span><span>
</span><span id="line-93"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#equalPred"><span class="hs-identifier">equalPred</span></a></span><span>
</span><span id="line-94"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#classPred"><span class="hs-identifier">classPred</span></a></span><span>
</span><span id="line-95"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#asEqualPred"><span class="hs-identifier">asEqualPred</span></a></span><span>
</span><span id="line-96"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#asClassPred"><span class="hs-identifier">asClassPred</span></a></span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Backward compatible data definitions</span></span><span>
</span><span id="line-99"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#dataDCompat"><span class="hs-identifier">dataDCompat</span></a></span><span>
</span><span id="line-100"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#newtypeDCompat"><span class="hs-identifier">newtypeDCompat</span></a></span><span>
</span><span id="line-101"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#tySynInstDCompat"><span class="hs-identifier">tySynInstDCompat</span></a></span><span>
</span><span id="line-102"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#pragLineDCompat"><span class="hs-identifier">pragLineDCompat</span></a></span><span>
</span><span id="line-103"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#arrowKCompat"><span class="hs-identifier">arrowKCompat</span></a></span><span>
</span><span id="line-104"></span><span>
</span><span id="line-105"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Strictness annotations</span></span><span>
</span><span id="line-106"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#isStrictAnnot"><span class="hs-identifier">isStrictAnnot</span></a></span><span>
</span><span id="line-107"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#notStrictAnnot"><span class="hs-identifier">notStrictAnnot</span></a></span><span>
</span><span id="line-108"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unpackedAnnot"><span class="hs-identifier">unpackedAnnot</span></a></span><span>
</span><span id="line-109"></span><span>
</span><span id="line-110"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Type simplification</span></span><span>
</span><span id="line-111"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier">resolveTypeSynonyms</span></a></span><span>
</span><span id="line-112"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier">resolveKindSynonyms</span></a></span><span>
</span><span id="line-113"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolvePredSynonyms"><span class="hs-identifier">resolvePredSynonyms</span></a></span><span>
</span><span id="line-114"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier">resolveInfixT</span></a></span><span>
</span><span id="line-115"></span><span>
</span><span id="line-116"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Fixities</span></span><span>
</span><span id="line-117"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyFixityCompat"><span class="hs-identifier">reifyFixityCompat</span></a></span><span>
</span><span id="line-118"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#showFixity"><span class="hs-identifier">showFixity</span></a></span><span>
</span><span id="line-119"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#showFixityDirection"><span class="hs-identifier">showFixityDirection</span></a></span><span>
</span><span id="line-120"></span><span>
</span><span id="line-121"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Convenience functions</span></span><span>
</span><span id="line-122"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unifyTypes"><span class="hs-identifier">unifyTypes</span></a></span><span>
</span><span id="line-123"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvName"><span class="hs-identifier">tvName</span></a></span><span>
</span><span id="line-124"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvKind"><span class="hs-identifier">tvKind</span></a></span><span>
</span><span id="line-125"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#datatypeType"><span class="hs-identifier">datatypeType</span></a></span><span>
</span><span id="line-126"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-127"></span><span>
</span><span id="line-128"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Data</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Data</span></span><span class="hs-special">)</span><span>
</span><span id="line-129"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">foldMap</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">foldl'</span></span><span class="hs-special">)</span><span>
</span><span id="line-130"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.List</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">mapAccumL</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">nub</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">find</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">union</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(\\)</span></span><span class="hs-special">)</span><span>
</span><span id="line-131"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Map</span></span><span class="hs-special">)</span><span>
</span><span id="line-132"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Map</span></span><span>
</span><span id="line-133"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span>
</span><span id="line-134"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Set</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Set</span></span><span>
</span><span id="line-135"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Set</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Set</span></span><span class="hs-special">)</span><span>
</span><span id="line-136"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Traversable</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">T</span></span><span>
</span><span id="line-137"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span>
</span><span id="line-138"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>                                     </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Extension</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Language.Haskell.TH.Datatype.Internal.html"><span class="hs-identifier">Language.Haskell.TH.Datatype.Internal</span></a></span><span>
</span><span id="line-143"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html"><span class="hs-identifier">Language.Haskell.TH.Datatype.TyVarBndr</span></a></span><span>
</span><span id="line-144"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Lib</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">arrowK</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">starK</span></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- needed for th-2.4</span><span class="hs-cpp">

#ifdef HAS_GENERICS
</span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">GHC.Generics</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Generic</span></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if !MIN_VERSION_base(4,8,0)
</span><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control.Applicative</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Applicative</span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator">&lt;$&gt;</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-152"></span><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data.Monoid</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Monoid</span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-155"></span><span class="hs-comment">-- | Normalized information about newtypes and data types.</span><span>
</span><span id="line-156"></span><span class="hs-comment">--</span><span>
</span><span id="line-157"></span><span class="hs-comment">-- 'DatatypeInfo' contains two fields, 'datatypeVars' and 'datatypeInstTypes',</span><span>
</span><span id="line-158"></span><span class="hs-comment">-- which encode information about the argument types. The simplest explanation</span><span>
</span><span id="line-159"></span><span class="hs-comment">-- is that 'datatypeVars' contains all the type /variables/ bound by the data</span><span>
</span><span id="line-160"></span><span class="hs-comment">-- type constructor, while 'datatypeInstTypes' contains the type /arguments/</span><span>
</span><span id="line-161"></span><span class="hs-comment">-- to the data type constructor. To be more precise:</span><span>
</span><span id="line-162"></span><span class="hs-comment">--</span><span>
</span><span id="line-163"></span><span class="hs-comment">-- * For ADTs declared with @data@ and @newtype@, it will likely be the case</span><span>
</span><span id="line-164"></span><span class="hs-comment">--   that 'datatypeVars' and 'datatypeInstTypes' coincide. For instance, given</span><span>
</span><span id="line-165"></span><span class="hs-comment">--   @newtype Id a = MkId a@, in the 'DatatypeInfo' for @Id@ we would</span><span>
</span><span id="line-166"></span><span class="hs-comment">--   have @'datatypeVars' = ['KindedTV' a () 'StarT']@ and</span><span>
</span><span id="line-167"></span><span class="hs-comment">--   @'datatypeInstVars' = ['SigT' ('VarT' a) 'StarT']@.</span><span>
</span><span id="line-168"></span><span class="hs-comment">--</span><span>
</span><span id="line-169"></span><span class="hs-comment">--   ADTs that leverage @PolyKinds@ may have more 'datatypeVars' than</span><span>
</span><span id="line-170"></span><span class="hs-comment">--   'datatypeInstTypes'. For instance, given @data Proxy (a :: k) = MkProxy@,</span><span>
</span><span id="line-171"></span><span class="hs-comment">--   in the 'DatatypeInfo' for @Proxy@ we would have</span><span>
</span><span id="line-172"></span><span class="hs-comment">--   @'datatypeVars' = ['KindedTV' k () 'StarT', 'KindedTV' a () ('VarT' k)]@</span><span>
</span><span id="line-173"></span><span class="hs-comment">--   (since there are two variables, @k@ and @a@), whereas</span><span>
</span><span id="line-174"></span><span class="hs-comment">--   @'datatypeInstTypes' = ['SigT' ('VarT' a) ('VarT' k)]@, since there is</span><span>
</span><span id="line-175"></span><span class="hs-comment">--   only one explicit type argument to @Proxy@.</span><span>
</span><span id="line-176"></span><span class="hs-comment">--</span><span>
</span><span id="line-177"></span><span class="hs-comment">--   The same outcome would occur if @Proxy@ were declared using</span><span>
</span><span id="line-178"></span><span class="hs-comment">--   @TypeAbstractions@, i.e., if it were declared as</span><span>
</span><span id="line-179"></span><span class="hs-comment">--   @data Proxy \@k (a :: k) = MkProxy@. The 'datatypeInstTypes' would /not/</span><span>
</span><span id="line-180"></span><span class="hs-comment">--   include a separate type for @\@k@.</span><span>
</span><span id="line-181"></span><span class="hs-comment">--</span><span>
</span><span id="line-182"></span><span class="hs-comment">-- * For @data instance@s and @newtype instance@s of data families,</span><span>
</span><span id="line-183"></span><span class="hs-comment">--   'datatypeVars' and 'datatypeInstTypes' can be quite different. Here is</span><span>
</span><span id="line-184"></span><span class="hs-comment">--   an example to illustrate the difference:</span><span>
</span><span id="line-185"></span><span class="hs-comment">--</span><span>
</span><span id="line-186"></span><span class="hs-comment">--   @</span><span>
</span><span id="line-187"></span><span class="hs-comment">--   data family F a b</span><span>
</span><span id="line-188"></span><span class="hs-comment">--   data instance F (Maybe c) (f x) = MkF c (f x)</span><span>
</span><span id="line-189"></span><span class="hs-comment">--   @</span><span>
</span><span id="line-190"></span><span class="hs-comment">--</span><span>
</span><span id="line-191"></span><span class="hs-comment">--   Then in the 'DatatypeInfo' for @F@'s data instance, we would have:</span><span>
</span><span id="line-192"></span><span class="hs-comment">--</span><span>
</span><span id="line-193"></span><span class="hs-comment">--   @</span><span>
</span><span id="line-194"></span><span class="hs-comment">--   'datatypeVars'      = [ 'KindedTV' c () 'StarT'</span><span>
</span><span id="line-195"></span><span class="hs-comment">--                         , 'KindedTV' f () 'StarT'</span><span>
</span><span id="line-196"></span><span class="hs-comment">--                         , 'KindedTV' x () 'StarT' ]</span><span>
</span><span id="line-197"></span><span class="hs-comment">--   'datatypeInstTypes' = [ 'AppT' ('ConT' ''Maybe) ('VarT' c)</span><span>
</span><span id="line-198"></span><span class="hs-comment">--                         , 'AppT' ('VarT' f) ('VarT' x) ]</span><span>
</span><span id="line-199"></span><span class="hs-comment">--   @</span><span>
</span><span id="line-200"></span><span class="hs-keyword">data</span><span> </span><span id="DatatypeInfo"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-var">DatatypeInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DatatypeInfo"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-var">DatatypeInfo</span></a></span></span><span>
</span><span id="line-201"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="datatypeContext"><span class="annot"><span class="annottext">DatatypeInfo -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeContext"><span class="hs-identifier hs-var hs-var">datatypeContext</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span>               </span><span class="annot"><span class="hs-comment">-- ^ Data type context (deprecated)</span></span><span>
</span><span id="line-202"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="datatypeName"><span class="annot"><span class="annottext">DatatypeInfo -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#datatypeName"><span class="hs-identifier hs-var hs-var">datatypeName</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>              </span><span class="annot"><span class="hs-comment">-- ^ Type constructor</span></span><span>
</span><span id="line-203"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="datatypeVars"><span class="annot"><span class="annottext">DatatypeInfo -&gt; [TyVarBndrUnit]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeVars"><span class="hs-identifier hs-var hs-var">datatypeVars</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span><span>   </span><span class="annot"><span class="hs-comment">-- ^ Type parameters</span></span><span>
</span><span id="line-204"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="datatypeInstTypes"><span class="annot"><span class="annottext">DatatypeInfo -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeInstTypes"><span class="hs-identifier hs-var hs-var">datatypeInstTypes</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>            </span><span class="annot"><span class="hs-comment">-- ^ Argument types</span></span><span>
</span><span id="line-205"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="datatypeVariant"><span class="annot"><span class="annottext">DatatypeInfo -&gt; DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#datatypeVariant"><span class="hs-identifier hs-var hs-var">datatypeVariant</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ Extra information</span></span><span>
</span><span id="line-206"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="datatypeReturnKind"><span class="annot"><span class="annottext">DatatypeInfo -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#datatypeReturnKind"><span class="hs-identifier hs-var hs-var">datatypeReturnKind</span></a></span></span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>              </span><span class="hs-comment">-- ^ Return 'Kind' of the type.</span><span>
</span><span id="line-207"></span><span>                                           </span><span class="hs-comment">--</span><span>
</span><span id="line-208"></span><span>                                           </span><span class="hs-comment">-- If normalization is unable to determine the return kind,</span><span>
</span><span id="line-209"></span><span>                                           </span><span class="hs-comment">-- then this is conservatively set to @StarT@.</span><span>
</span><span id="line-210"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="datatypeCons"><span class="annot"><span class="annottext">DatatypeInfo -&gt; [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var hs-var">datatypeCons</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ Normalize constructor information</span></span><span>
</span><span id="line-211"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-212"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679073202"><span id="local-6989586621679073217"><span id="local-6989586621679073221"><span class="annot"><span class="annottext">Int -&gt; DatatypeInfo -&gt; ShowS
[DatatypeInfo] -&gt; ShowS
DatatypeInfo -&gt; String
(Int -&gt; DatatypeInfo -&gt; ShowS)
-&gt; (DatatypeInfo -&gt; String)
-&gt; ([DatatypeInfo] -&gt; ShowS)
-&gt; Show DatatypeInfo
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; DatatypeInfo -&gt; ShowS
showsPrec :: Int -&gt; DatatypeInfo -&gt; ShowS
$cshow :: DatatypeInfo -&gt; String
show :: DatatypeInfo -&gt; String
$cshowList :: [DatatypeInfo] -&gt; ShowS
showList :: [DatatypeInfo] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073229"><span id="local-6989586621679073242"><span class="annot"><span class="annottext">DatatypeInfo -&gt; DatatypeInfo -&gt; Bool
(DatatypeInfo -&gt; DatatypeInfo -&gt; Bool)
-&gt; (DatatypeInfo -&gt; DatatypeInfo -&gt; Bool) -&gt; Eq DatatypeInfo
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: DatatypeInfo -&gt; DatatypeInfo -&gt; Bool
== :: DatatypeInfo -&gt; DatatypeInfo -&gt; Bool
$c/= :: DatatypeInfo -&gt; DatatypeInfo -&gt; Bool
/= :: DatatypeInfo -&gt; DatatypeInfo -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073253"><span id="local-6989586621679073268"><span id="local-6989586621679073279"><span id="local-6989586621679073281"><span id="local-6989586621679073283"><span id="local-6989586621679073289"><span id="local-6989586621679073294"><span id="local-6989586621679073297"><span id="local-6989586621679073300"><span id="local-6989586621679073303"><span id="local-6989586621679073306"><span id="local-6989586621679073309"><span id="local-6989586621679073314"><span id="local-6989586621679073319"><span class="annot"><span class="annottext">Typeable DatatypeInfo
Typeable DatatypeInfo =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; DatatypeInfo -&gt; c DatatypeInfo)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeInfo)
-&gt; (DatatypeInfo -&gt; Constr)
-&gt; (DatatypeInfo -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeInfo))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c DatatypeInfo))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DatatypeInfo -&gt; DatatypeInfo)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo)
-&gt; Data DatatypeInfo
DatatypeInfo -&gt; Constr
DatatypeInfo -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; DatatypeInfo -&gt; DatatypeInfo
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeInfo
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DatatypeInfo -&gt; c DatatypeInfo
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeInfo)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DatatypeInfo)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DatatypeInfo -&gt; c DatatypeInfo
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DatatypeInfo -&gt; c DatatypeInfo
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeInfo
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeInfo
$ctoConstr :: DatatypeInfo -&gt; Constr
toConstr :: DatatypeInfo -&gt; Constr
$cdataTypeOf :: DatatypeInfo -&gt; DataType
dataTypeOf :: DatatypeInfo -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeInfo)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeInfo)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DatatypeInfo)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DatatypeInfo)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DatatypeInfo -&gt; DatatypeInfo
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DatatypeInfo -&gt; DatatypeInfo
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-cpp">
#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span id="local-6989586621679073330"><span id="local-6989586621679073332"><span class="annot"><span class="annottext">(forall x. DatatypeInfo -&gt; Rep DatatypeInfo x)
-&gt; (forall x. Rep DatatypeInfo x -&gt; DatatypeInfo)
-&gt; Generic DatatypeInfo
forall x. Rep DatatypeInfo x -&gt; DatatypeInfo
forall x. DatatypeInfo -&gt; Rep DatatypeInfo x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. DatatypeInfo -&gt; Rep DatatypeInfo x
from :: forall x. DatatypeInfo -&gt; Rep DatatypeInfo x
$cto :: forall x. Rep DatatypeInfo x -&gt; DatatypeInfo
to :: forall x. Rep DatatypeInfo x -&gt; DatatypeInfo
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-cpp">
#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><span id="line-217"></span><span>
</span><span id="line-218"></span><span class="annot"><span class="hs-comment">-- | Possible variants of data type declarations.</span></span><span>
</span><span id="line-219"></span><span class="hs-keyword">data</span><span> </span><span id="DatatypeVariant"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-var">DatatypeVariant</span></a></span></span><span>
</span><span id="line-220"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="Datatype"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Datatype"><span class="hs-identifier hs-var">Datatype</span></a></span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ Type declared with @data@ or a primitive datatype.</span></span><span>
</span><span id="line-221"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Newtype"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Newtype"><span class="hs-identifier hs-var">Newtype</span></a></span></span><span>         </span><span class="hs-comment">-- ^ Type declared with @newtype@.</span><span>
</span><span id="line-222"></span><span>                    </span><span class="hs-comment">--</span><span>
</span><span id="line-223"></span><span>                    </span><span class="hs-comment">--   A 'DatatypeInfo' that uses 'Newtype' will uphold the</span><span>
</span><span id="line-224"></span><span>                    </span><span class="hs-comment">--   invariant that there will be exactly one</span><span>
</span><span id="line-225"></span><span>                    </span><span class="hs-comment">--   'ConstructorInfo' in the 'datatypeCons'.</span><span>
</span><span id="line-226"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DataInstance"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DataInstance"><span class="hs-identifier hs-var">DataInstance</span></a></span></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ Type declared with @data instance@.</span></span><span>
</span><span id="line-227"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NewtypeInstance"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NewtypeInstance"><span class="hs-identifier hs-var">NewtypeInstance</span></a></span></span><span> </span><span class="hs-comment">-- ^ Type declared with @newtype instance@.</span><span>
</span><span id="line-228"></span><span>                    </span><span class="hs-comment">--</span><span>
</span><span id="line-229"></span><span>                    </span><span class="hs-comment">--   A 'DatatypeInfo' that uses 'NewtypeInstance' will</span><span>
</span><span id="line-230"></span><span>                    </span><span class="hs-comment">--   uphold the invariant that there will be exactly one</span><span>
</span><span id="line-231"></span><span>                    </span><span class="hs-comment">--   'ConstructorInfo' in the 'datatypeCons'.</span><span>
</span><span id="line-232"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TypeData"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeData"><span class="hs-identifier hs-var">TypeData</span></a></span></span><span>        </span><span class="hs-comment">-- ^ Type declared with @type data@.</span><span>
</span><span id="line-233"></span><span>                    </span><span class="hs-comment">--</span><span>
</span><span id="line-234"></span><span>                    </span><span class="hs-comment">--   A 'DatatypeInfo' that uses 'TypeData' will uphold the</span><span>
</span><span id="line-235"></span><span>                    </span><span class="hs-comment">--   following invariants:</span><span>
</span><span id="line-236"></span><span>                    </span><span class="hs-comment">--</span><span>
</span><span id="line-237"></span><span>                    </span><span class="hs-comment">--   * The 'datatypeContext' will be empty.</span><span>
</span><span id="line-238"></span><span>                    </span><span class="hs-comment">--</span><span>
</span><span id="line-239"></span><span>                    </span><span class="hs-comment">--   * None of the 'constructorVariant's in any of the</span><span>
</span><span id="line-240"></span><span>                    </span><span class="hs-comment">--     'datatypeCons' will be 'RecordConstructor'.</span><span>
</span><span id="line-241"></span><span>                    </span><span class="hs-comment">--</span><span>
</span><span id="line-242"></span><span>                    </span><span class="hs-comment">--   * Each of the 'constructorStrictness' values in each</span><span>
</span><span id="line-243"></span><span>                    </span><span class="hs-comment">--     of the 'datatypeCons' will be equal to</span><span>
</span><span id="line-244"></span><span>                    </span><span class="hs-comment">--     'notStrictAnnot'.</span><span>
</span><span id="line-245"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679073341"><span id="local-6989586621679073343"><span id="local-6989586621679073346"><span class="annot"><span class="annottext">Int -&gt; DatatypeVariant -&gt; ShowS
[DatatypeVariant] -&gt; ShowS
DatatypeVariant -&gt; String
(Int -&gt; DatatypeVariant -&gt; ShowS)
-&gt; (DatatypeVariant -&gt; String)
-&gt; ([DatatypeVariant] -&gt; ShowS)
-&gt; Show DatatypeVariant
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; DatatypeVariant -&gt; ShowS
showsPrec :: Int -&gt; DatatypeVariant -&gt; ShowS
$cshow :: DatatypeVariant -&gt; String
show :: DatatypeVariant -&gt; String
$cshowList :: [DatatypeVariant] -&gt; ShowS
showList :: [DatatypeVariant] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073349"><span id="local-6989586621679073353"><span id="local-6989586621679073356"><span id="local-6989586621679073364"><span class="annot"><span class="annottext">ReadPrec [DatatypeVariant]
ReadPrec DatatypeVariant
Int -&gt; ReadS DatatypeVariant
ReadS [DatatypeVariant]
(Int -&gt; ReadS DatatypeVariant)
-&gt; ReadS [DatatypeVariant]
-&gt; ReadPrec DatatypeVariant
-&gt; ReadPrec [DatatypeVariant]
-&gt; Read DatatypeVariant
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
$creadsPrec :: Int -&gt; ReadS DatatypeVariant
readsPrec :: Int -&gt; ReadS DatatypeVariant
$creadList :: ReadS [DatatypeVariant]
readList :: ReadS [DatatypeVariant]
$creadPrec :: ReadPrec DatatypeVariant
readPrec :: ReadPrec DatatypeVariant
$creadListPrec :: ReadPrec [DatatypeVariant]
readListPrec :: ReadPrec [DatatypeVariant]
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073368"><span id="local-6989586621679073370"><span class="annot"><span class="annottext">DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
(DatatypeVariant -&gt; DatatypeVariant -&gt; Bool)
-&gt; (DatatypeVariant -&gt; DatatypeVariant -&gt; Bool)
-&gt; Eq DatatypeVariant
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
== :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
$c/= :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
/= :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073375"><span id="local-6989586621679073377"><span id="local-6989586621679073379"><span id="local-6989586621679073383"><span id="local-6989586621679073386"><span id="local-6989586621679073389"><span id="local-6989586621679073392"><span class="annot"><span class="annottext">Eq DatatypeVariant
Eq DatatypeVariant =&gt;
(DatatypeVariant -&gt; DatatypeVariant -&gt; Ordering)
-&gt; (DatatypeVariant -&gt; DatatypeVariant -&gt; Bool)
-&gt; (DatatypeVariant -&gt; DatatypeVariant -&gt; Bool)
-&gt; (DatatypeVariant -&gt; DatatypeVariant -&gt; Bool)
-&gt; (DatatypeVariant -&gt; DatatypeVariant -&gt; Bool)
-&gt; (DatatypeVariant -&gt; DatatypeVariant -&gt; DatatypeVariant)
-&gt; (DatatypeVariant -&gt; DatatypeVariant -&gt; DatatypeVariant)
-&gt; Ord DatatypeVariant
DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
DatatypeVariant -&gt; DatatypeVariant -&gt; Ordering
DatatypeVariant -&gt; DatatypeVariant -&gt; DatatypeVariant
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: DatatypeVariant -&gt; DatatypeVariant -&gt; Ordering
compare :: DatatypeVariant -&gt; DatatypeVariant -&gt; Ordering
$c&lt; :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
&lt; :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
$c&lt;= :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
&lt;= :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
$c&gt; :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
&gt; :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
$c&gt;= :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
&gt;= :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
$cmax :: DatatypeVariant -&gt; DatatypeVariant -&gt; DatatypeVariant
max :: DatatypeVariant -&gt; DatatypeVariant -&gt; DatatypeVariant
$cmin :: DatatypeVariant -&gt; DatatypeVariant -&gt; DatatypeVariant
min :: DatatypeVariant -&gt; DatatypeVariant -&gt; DatatypeVariant
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073398"><span id="local-6989586621679073400"><span id="local-6989586621679073402"><span id="local-6989586621679073404"><span id="local-6989586621679073406"><span id="local-6989586621679073411"><span id="local-6989586621679073416"><span id="local-6989586621679073419"><span id="local-6989586621679073422"><span id="local-6989586621679073425"><span id="local-6989586621679073428"><span id="local-6989586621679073431"><span id="local-6989586621679073436"><span id="local-6989586621679073441"><span class="annot"><span class="annottext">Typeable DatatypeVariant
Typeable DatatypeVariant =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; DatatypeVariant -&gt; c DatatypeVariant)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeVariant)
-&gt; (DatatypeVariant -&gt; Constr)
-&gt; (DatatypeVariant -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeVariant))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c DatatypeVariant))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; DatatypeVariant -&gt; DatatypeVariant)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DatatypeVariant -&gt; m DatatypeVariant)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DatatypeVariant -&gt; m DatatypeVariant)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DatatypeVariant -&gt; m DatatypeVariant)
-&gt; Data DatatypeVariant
DatatypeVariant -&gt; Constr
DatatypeVariant -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; DatatypeVariant -&gt; DatatypeVariant
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeVariant
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DatatypeVariant -&gt; c DatatypeVariant
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeVariant)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DatatypeVariant)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DatatypeVariant -&gt; c DatatypeVariant
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DatatypeVariant -&gt; c DatatypeVariant
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeVariant
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeVariant
$ctoConstr :: DatatypeVariant -&gt; Constr
toConstr :: DatatypeVariant -&gt; Constr
$cdataTypeOf :: DatatypeVariant -&gt; DataType
dataTypeOf :: DatatypeVariant -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeVariant)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeVariant)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DatatypeVariant)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DatatypeVariant)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DatatypeVariant -&gt; DatatypeVariant
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DatatypeVariant -&gt; DatatypeVariant
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-cpp">
#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span id="local-6989586621679073446"><span id="local-6989586621679073448"><span class="annot"><span class="annottext">(forall x. DatatypeVariant -&gt; Rep DatatypeVariant x)
-&gt; (forall x. Rep DatatypeVariant x -&gt; DatatypeVariant)
-&gt; Generic DatatypeVariant
forall x. Rep DatatypeVariant x -&gt; DatatypeVariant
forall x. DatatypeVariant -&gt; Rep DatatypeVariant x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. DatatypeVariant -&gt; Rep DatatypeVariant x
from :: forall x. DatatypeVariant -&gt; Rep DatatypeVariant x
$cto :: forall x. Rep DatatypeVariant x -&gt; DatatypeVariant
to :: forall x. Rep DatatypeVariant x -&gt; DatatypeVariant
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-cpp">
#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><span id="line-250"></span><span>
</span><span id="line-251"></span><span class="hs-comment">-- | Normalized information about constructors associated with newtypes and</span><span>
</span><span id="line-252"></span><span class="hs-comment">-- data types.</span><span>
</span><span id="line-253"></span><span class="hs-keyword">data</span><span> </span><span id="ConstructorInfo"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ConstructorInfo"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a></span></span><span>
</span><span id="line-254"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="constructorName"><span class="annot"><span class="annottext">ConstructorInfo -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#constructorName"><span class="hs-identifier hs-var hs-var">constructorName</span></a></span></span><span>       </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>               </span><span class="annot"><span class="hs-comment">-- ^ Constructor name</span></span><span>
</span><span id="line-255"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="constructorVars"><span class="annot"><span class="annottext">ConstructorInfo -&gt; [TyVarBndrUnit]
</span><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var hs-var">constructorVars</span></a></span></span><span>       </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span><span>    </span><span class="annot"><span class="hs-comment">-- ^ Constructor type parameters</span></span><span>
</span><span id="line-256"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="constructorContext"><span class="annot"><span class="annottext">ConstructorInfo -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#constructorContext"><span class="hs-identifier hs-var hs-var">constructorContext</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span>                </span><span class="annot"><span class="hs-comment">-- ^ Constructor constraints</span></span><span>
</span><span id="line-257"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="constructorFields"><span class="annot"><span class="annottext">ConstructorInfo -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#constructorFields"><span class="hs-identifier hs-var hs-var">constructorFields</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>             </span><span class="annot"><span class="hs-comment">-- ^ Constructor fields</span></span><span>
</span><span id="line-258"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="constructorStrictness"><span class="annot"><span class="annottext">ConstructorInfo -&gt; [FieldStrictness]
</span><a href="Language.Haskell.TH.Datatype.html#constructorStrictness"><span class="hs-identifier hs-var hs-var">constructorStrictness</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a></span><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- ^ Constructor fields' strictness</span><span>
</span><span id="line-259"></span><span>                                                </span><span class="hs-comment">--   (Invariant: has the same length</span><span>
</span><span id="line-260"></span><span>                                                </span><span class="hs-comment">--   as constructorFields)</span><span>
</span><span id="line-261"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="constructorVariant"><span class="annot"><span class="annottext">ConstructorInfo -&gt; ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#constructorVariant"><span class="hs-identifier hs-var hs-var">constructorVariant</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorVariant"><span class="hs-identifier hs-type">ConstructorVariant</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ Extra information</span></span><span>
</span><span id="line-262"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-263"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679073451"><span id="local-6989586621679073463"><span id="local-6989586621679073466"><span class="annot"><span class="annottext">Int -&gt; ConstructorInfo -&gt; ShowS
[ConstructorInfo] -&gt; ShowS
ConstructorInfo -&gt; String
(Int -&gt; ConstructorInfo -&gt; ShowS)
-&gt; (ConstructorInfo -&gt; String)
-&gt; ([ConstructorInfo] -&gt; ShowS)
-&gt; Show ConstructorInfo
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; ConstructorInfo -&gt; ShowS
showsPrec :: Int -&gt; ConstructorInfo -&gt; ShowS
$cshow :: ConstructorInfo -&gt; String
show :: ConstructorInfo -&gt; String
$cshowList :: [ConstructorInfo] -&gt; ShowS
showList :: [ConstructorInfo] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073471"><span id="local-6989586621679073482"><span class="annot"><span class="annottext">ConstructorInfo -&gt; ConstructorInfo -&gt; Bool
(ConstructorInfo -&gt; ConstructorInfo -&gt; Bool)
-&gt; (ConstructorInfo -&gt; ConstructorInfo -&gt; Bool)
-&gt; Eq ConstructorInfo
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: ConstructorInfo -&gt; ConstructorInfo -&gt; Bool
== :: ConstructorInfo -&gt; ConstructorInfo -&gt; Bool
$c/= :: ConstructorInfo -&gt; ConstructorInfo -&gt; Bool
/= :: ConstructorInfo -&gt; ConstructorInfo -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073489"><span id="local-6989586621679073501"><span id="local-6989586621679073512"><span id="local-6989586621679073514"><span id="local-6989586621679073516"><span id="local-6989586621679073521"><span id="local-6989586621679073526"><span id="local-6989586621679073529"><span id="local-6989586621679073532"><span id="local-6989586621679073535"><span id="local-6989586621679073538"><span id="local-6989586621679073541"><span id="local-6989586621679073546"><span id="local-6989586621679073551"><span class="annot"><span class="annottext">Typeable ConstructorInfo
Typeable ConstructorInfo =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; ConstructorInfo -&gt; c ConstructorInfo)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorInfo)
-&gt; (ConstructorInfo -&gt; Constr)
-&gt; (ConstructorInfo -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorInfo))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c ConstructorInfo))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; ConstructorInfo -&gt; ConstructorInfo)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ConstructorInfo -&gt; m ConstructorInfo)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ConstructorInfo -&gt; m ConstructorInfo)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ConstructorInfo -&gt; m ConstructorInfo)
-&gt; Data ConstructorInfo
ConstructorInfo -&gt; Constr
ConstructorInfo -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; ConstructorInfo -&gt; ConstructorInfo
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorInfo
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ConstructorInfo -&gt; c ConstructorInfo
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorInfo)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c ConstructorInfo)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ConstructorInfo -&gt; c ConstructorInfo
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ConstructorInfo -&gt; c ConstructorInfo
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorInfo
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorInfo
$ctoConstr :: ConstructorInfo -&gt; Constr
toConstr :: ConstructorInfo -&gt; Constr
$cdataTypeOf :: ConstructorInfo -&gt; DataType
dataTypeOf :: ConstructorInfo -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorInfo)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorInfo)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c ConstructorInfo)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c ConstructorInfo)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ConstructorInfo -&gt; ConstructorInfo
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ConstructorInfo -&gt; ConstructorInfo
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-cpp">
#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span id="local-6989586621679073559"><span id="local-6989586621679073561"><span class="annot"><span class="annottext">(forall x. ConstructorInfo -&gt; Rep ConstructorInfo x)
-&gt; (forall x. Rep ConstructorInfo x -&gt; ConstructorInfo)
-&gt; Generic ConstructorInfo
forall x. Rep ConstructorInfo x -&gt; ConstructorInfo
forall x. ConstructorInfo -&gt; Rep ConstructorInfo x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. ConstructorInfo -&gt; Rep ConstructorInfo x
from :: forall x. ConstructorInfo -&gt; Rep ConstructorInfo x
$cto :: forall x. Rep ConstructorInfo x -&gt; ConstructorInfo
to :: forall x. Rep ConstructorInfo x -&gt; ConstructorInfo
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-cpp">
#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><span id="line-268"></span><span>
</span><span id="line-269"></span><span class="annot"><span class="hs-comment">-- | Possible variants of data constructors.</span></span><span>
</span><span id="line-270"></span><span class="hs-keyword">data</span><span> </span><span id="ConstructorVariant"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorVariant"><span class="hs-identifier hs-var">ConstructorVariant</span></a></span></span><span>
</span><span id="line-271"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="NormalConstructor"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NormalConstructor"><span class="hs-identifier hs-var">NormalConstructor</span></a></span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ Constructor without field names</span></span><span>
</span><span id="line-272"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InfixConstructor"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixConstructor"><span class="hs-identifier hs-var">InfixConstructor</span></a></span></span><span>         </span><span class="hs-comment">-- ^ Constructor without field names that is</span><span>
</span><span id="line-273"></span><span>                             </span><span class="hs-comment">--   declared infix</span><span>
</span><span id="line-274"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecordConstructor"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#RecordConstructor"><span class="hs-identifier hs-var">RecordConstructor</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ Constructor with field names</span></span><span>
</span><span id="line-275"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679073565"><span id="local-6989586621679073570"><span id="local-6989586621679073573"><span class="annot"><span class="annottext">Int -&gt; ConstructorVariant -&gt; ShowS
[ConstructorVariant] -&gt; ShowS
ConstructorVariant -&gt; String
(Int -&gt; ConstructorVariant -&gt; ShowS)
-&gt; (ConstructorVariant -&gt; String)
-&gt; ([ConstructorVariant] -&gt; ShowS)
-&gt; Show ConstructorVariant
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; ConstructorVariant -&gt; ShowS
showsPrec :: Int -&gt; ConstructorVariant -&gt; ShowS
$cshow :: ConstructorVariant -&gt; String
show :: ConstructorVariant -&gt; String
$cshowList :: [ConstructorVariant] -&gt; ShowS
showList :: [ConstructorVariant] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073576"><span id="local-6989586621679073579"><span class="annot"><span class="annottext">ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
(ConstructorVariant -&gt; ConstructorVariant -&gt; Bool)
-&gt; (ConstructorVariant -&gt; ConstructorVariant -&gt; Bool)
-&gt; Eq ConstructorVariant
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
== :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
$c/= :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
/= :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073584"><span id="local-6989586621679073588"><span id="local-6989586621679073591"><span id="local-6989586621679073595"><span id="local-6989586621679073598"><span id="local-6989586621679073601"><span id="local-6989586621679073604"><span class="annot"><span class="annottext">Eq ConstructorVariant
Eq ConstructorVariant =&gt;
(ConstructorVariant -&gt; ConstructorVariant -&gt; Ordering)
-&gt; (ConstructorVariant -&gt; ConstructorVariant -&gt; Bool)
-&gt; (ConstructorVariant -&gt; ConstructorVariant -&gt; Bool)
-&gt; (ConstructorVariant -&gt; ConstructorVariant -&gt; Bool)
-&gt; (ConstructorVariant -&gt; ConstructorVariant -&gt; Bool)
-&gt; (ConstructorVariant -&gt; ConstructorVariant -&gt; ConstructorVariant)
-&gt; (ConstructorVariant -&gt; ConstructorVariant -&gt; ConstructorVariant)
-&gt; Ord ConstructorVariant
ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
ConstructorVariant -&gt; ConstructorVariant -&gt; Ordering
ConstructorVariant -&gt; ConstructorVariant -&gt; ConstructorVariant
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: ConstructorVariant -&gt; ConstructorVariant -&gt; Ordering
compare :: ConstructorVariant -&gt; ConstructorVariant -&gt; Ordering
$c&lt; :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
&lt; :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
$c&lt;= :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
&lt;= :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
$c&gt; :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
&gt; :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
$c&gt;= :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
&gt;= :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
$cmax :: ConstructorVariant -&gt; ConstructorVariant -&gt; ConstructorVariant
max :: ConstructorVariant -&gt; ConstructorVariant -&gt; ConstructorVariant
$cmin :: ConstructorVariant -&gt; ConstructorVariant -&gt; ConstructorVariant
min :: ConstructorVariant -&gt; ConstructorVariant -&gt; ConstructorVariant
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073609"><span id="local-6989586621679073613"><span id="local-6989586621679073617"><span id="local-6989586621679073619"><span id="local-6989586621679073621"><span id="local-6989586621679073626"><span id="local-6989586621679073631"><span id="local-6989586621679073634"><span id="local-6989586621679073637"><span id="local-6989586621679073640"><span id="local-6989586621679073643"><span id="local-6989586621679073646"><span id="local-6989586621679073651"><span id="local-6989586621679073656"><span class="annot"><span class="annottext">Typeable ConstructorVariant
Typeable ConstructorVariant =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g)
 -&gt; ConstructorVariant
 -&gt; c ConstructorVariant)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorVariant)
-&gt; (ConstructorVariant -&gt; Constr)
-&gt; (ConstructorVariant -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorVariant))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c ConstructorVariant))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; ConstructorVariant -&gt; ConstructorVariant)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ConstructorVariant -&gt; m ConstructorVariant)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ConstructorVariant -&gt; m ConstructorVariant)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ConstructorVariant -&gt; m ConstructorVariant)
-&gt; Data ConstructorVariant
ConstructorVariant -&gt; Constr
ConstructorVariant -&gt; DataType
(forall b. Data b =&gt; b -&gt; b)
-&gt; ConstructorVariant -&gt; ConstructorVariant
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorVariant
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; ConstructorVariant
-&gt; c ConstructorVariant
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorVariant)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c ConstructorVariant)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; ConstructorVariant
-&gt; c ConstructorVariant
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; ConstructorVariant
-&gt; c ConstructorVariant
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorVariant
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorVariant
$ctoConstr :: ConstructorVariant -&gt; Constr
toConstr :: ConstructorVariant -&gt; Constr
$cdataTypeOf :: ConstructorVariant -&gt; DataType
dataTypeOf :: ConstructorVariant -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorVariant)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorVariant)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c ConstructorVariant)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c ConstructorVariant)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; ConstructorVariant -&gt; ConstructorVariant
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; ConstructorVariant -&gt; ConstructorVariant
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-cpp">
#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span id="local-6989586621679073661"><span id="local-6989586621679073663"><span class="annot"><span class="annottext">(forall x. ConstructorVariant -&gt; Rep ConstructorVariant x)
-&gt; (forall x. Rep ConstructorVariant x -&gt; ConstructorVariant)
-&gt; Generic ConstructorVariant
forall x. Rep ConstructorVariant x -&gt; ConstructorVariant
forall x. ConstructorVariant -&gt; Rep ConstructorVariant x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. ConstructorVariant -&gt; Rep ConstructorVariant x
from :: forall x. ConstructorVariant -&gt; Rep ConstructorVariant x
$cto :: forall x. Rep ConstructorVariant x -&gt; ConstructorVariant
to :: forall x. Rep ConstructorVariant x -&gt; ConstructorVariant
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-cpp">
#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><span id="line-280"></span><span>
</span><span id="line-281"></span><span class="hs-comment">-- | Normalized information about a constructor field's @UNPACK@ and</span><span>
</span><span id="line-282"></span><span class="hs-comment">-- strictness annotations.</span><span>
</span><span id="line-283"></span><span class="hs-comment">--</span><span>
</span><span id="line-284"></span><span class="hs-comment">-- Note that the interface for reifying strictness in Template Haskell changed</span><span>
</span><span id="line-285"></span><span class="hs-comment">-- considerably in GHC 8.0. The presentation in this library mirrors that which</span><span>
</span><span id="line-286"></span><span class="hs-comment">-- can be found in GHC 8.0 or later, whereas previously, unpackedness and</span><span>
</span><span id="line-287"></span><span class="hs-comment">-- strictness were represented with a single data type:</span><span>
</span><span id="line-288"></span><span class="hs-comment">--</span><span>
</span><span id="line-289"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-290"></span><span class="hs-comment">-- data Strict</span><span>
</span><span id="line-291"></span><span class="hs-comment">--   = IsStrict</span><span>
</span><span id="line-292"></span><span class="hs-comment">--   | NotStrict</span><span>
</span><span id="line-293"></span><span class="hs-comment">--   | Unpacked -- On GHC 7.4 or later</span><span>
</span><span id="line-294"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-295"></span><span class="hs-comment">--</span><span>
</span><span id="line-296"></span><span class="hs-comment">-- For backwards compatibility, we retrofit these constructors onto the</span><span>
</span><span id="line-297"></span><span class="hs-comment">-- following three values, respectively:</span><span>
</span><span id="line-298"></span><span class="hs-comment">--</span><span>
</span><span id="line-299"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-300"></span><span class="hs-comment">-- 'isStrictAnnot'  = 'FieldStrictness' 'UnspecifiedUnpackedness' 'Strict'</span><span>
</span><span id="line-301"></span><span class="hs-comment">-- 'notStrictAnnot' = 'FieldStrictness' 'UnspecifiedUnpackedness' 'UnspecifiedStrictness'</span><span>
</span><span id="line-302"></span><span class="hs-comment">-- 'unpackedAnnot'  = 'FieldStrictness' 'Unpack' 'Strict'</span><span>
</span><span id="line-303"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-304"></span><span class="hs-keyword">data</span><span> </span><span id="FieldStrictness"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="FieldStrictness"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a></span></span><span>
</span><span id="line-305"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="fieldUnpackedness"><span class="annot"><span class="annottext">FieldStrictness -&gt; Unpackedness
</span><a href="Language.Haskell.TH.Datatype.html#fieldUnpackedness"><span class="hs-identifier hs-var hs-var">fieldUnpackedness</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Unpackedness"><span class="hs-identifier hs-type">Unpackedness</span></a></span><span>
</span><span id="line-306"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="fieldStrictness"><span class="annot"><span class="annottext">FieldStrictness -&gt; Strictness
</span><a href="Language.Haskell.TH.Datatype.html#fieldStrictness"><span class="hs-identifier hs-var hs-var">fieldStrictness</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Strictness"><span class="hs-identifier hs-type">Strictness</span></a></span><span>
</span><span id="line-307"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-308"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679073672"><span id="local-6989586621679073679"><span id="local-6989586621679073682"><span class="annot"><span class="annottext">Int -&gt; FieldStrictness -&gt; ShowS
[FieldStrictness] -&gt; ShowS
FieldStrictness -&gt; String
(Int -&gt; FieldStrictness -&gt; ShowS)
-&gt; (FieldStrictness -&gt; String)
-&gt; ([FieldStrictness] -&gt; ShowS)
-&gt; Show FieldStrictness
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; FieldStrictness -&gt; ShowS
showsPrec :: Int -&gt; FieldStrictness -&gt; ShowS
$cshow :: FieldStrictness -&gt; String
show :: FieldStrictness -&gt; String
$cshowList :: [FieldStrictness] -&gt; ShowS
showList :: [FieldStrictness] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073685"><span id="local-6989586621679073691"><span class="annot"><span class="annottext">FieldStrictness -&gt; FieldStrictness -&gt; Bool
(FieldStrictness -&gt; FieldStrictness -&gt; Bool)
-&gt; (FieldStrictness -&gt; FieldStrictness -&gt; Bool)
-&gt; Eq FieldStrictness
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
== :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
$c/= :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
/= :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073696"><span id="local-6989586621679073702"><span id="local-6989586621679073706"><span id="local-6989586621679073710"><span id="local-6989586621679073713"><span id="local-6989586621679073716"><span id="local-6989586621679073719"><span class="annot"><span class="annottext">Eq FieldStrictness
Eq FieldStrictness =&gt;
(FieldStrictness -&gt; FieldStrictness -&gt; Ordering)
-&gt; (FieldStrictness -&gt; FieldStrictness -&gt; Bool)
-&gt; (FieldStrictness -&gt; FieldStrictness -&gt; Bool)
-&gt; (FieldStrictness -&gt; FieldStrictness -&gt; Bool)
-&gt; (FieldStrictness -&gt; FieldStrictness -&gt; Bool)
-&gt; (FieldStrictness -&gt; FieldStrictness -&gt; FieldStrictness)
-&gt; (FieldStrictness -&gt; FieldStrictness -&gt; FieldStrictness)
-&gt; Ord FieldStrictness
FieldStrictness -&gt; FieldStrictness -&gt; Bool
FieldStrictness -&gt; FieldStrictness -&gt; Ordering
FieldStrictness -&gt; FieldStrictness -&gt; FieldStrictness
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: FieldStrictness -&gt; FieldStrictness -&gt; Ordering
compare :: FieldStrictness -&gt; FieldStrictness -&gt; Ordering
$c&lt; :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
&lt; :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
$c&lt;= :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
&lt;= :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
$c&gt; :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
&gt; :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
$c&gt;= :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
&gt;= :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
$cmax :: FieldStrictness -&gt; FieldStrictness -&gt; FieldStrictness
max :: FieldStrictness -&gt; FieldStrictness -&gt; FieldStrictness
$cmin :: FieldStrictness -&gt; FieldStrictness -&gt; FieldStrictness
min :: FieldStrictness -&gt; FieldStrictness -&gt; FieldStrictness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073724"><span id="local-6989586621679073730"><span id="local-6989586621679073734"><span id="local-6989586621679073736"><span id="local-6989586621679073738"><span id="local-6989586621679073743"><span id="local-6989586621679073748"><span id="local-6989586621679073751"><span id="local-6989586621679073754"><span id="local-6989586621679073757"><span id="local-6989586621679073760"><span id="local-6989586621679073763"><span id="local-6989586621679073768"><span id="local-6989586621679073773"><span class="annot"><span class="annottext">Typeable FieldStrictness
Typeable FieldStrictness =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; FieldStrictness -&gt; c FieldStrictness)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FieldStrictness)
-&gt; (FieldStrictness -&gt; Constr)
-&gt; (FieldStrictness -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FieldStrictness))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c FieldStrictness))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; FieldStrictness -&gt; FieldStrictness)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; FieldStrictness -&gt; m FieldStrictness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; FieldStrictness -&gt; m FieldStrictness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; FieldStrictness -&gt; m FieldStrictness)
-&gt; Data FieldStrictness
FieldStrictness -&gt; Constr
FieldStrictness -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; FieldStrictness -&gt; FieldStrictness
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FieldStrictness
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FieldStrictness -&gt; c FieldStrictness
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FieldStrictness)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c FieldStrictness)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FieldStrictness -&gt; c FieldStrictness
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FieldStrictness -&gt; c FieldStrictness
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FieldStrictness
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FieldStrictness
$ctoConstr :: FieldStrictness -&gt; Constr
toConstr :: FieldStrictness -&gt; Constr
$cdataTypeOf :: FieldStrictness -&gt; DataType
dataTypeOf :: FieldStrictness -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FieldStrictness)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FieldStrictness)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c FieldStrictness)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c FieldStrictness)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; FieldStrictness -&gt; FieldStrictness
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; FieldStrictness -&gt; FieldStrictness
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-cpp">
#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span id="local-6989586621679073778"><span id="local-6989586621679073780"><span class="annot"><span class="annottext">(forall x. FieldStrictness -&gt; Rep FieldStrictness x)
-&gt; (forall x. Rep FieldStrictness x -&gt; FieldStrictness)
-&gt; Generic FieldStrictness
forall x. Rep FieldStrictness x -&gt; FieldStrictness
forall x. FieldStrictness -&gt; Rep FieldStrictness x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. FieldStrictness -&gt; Rep FieldStrictness x
from :: forall x. FieldStrictness -&gt; Rep FieldStrictness x
$cto :: forall x. Rep FieldStrictness x -&gt; FieldStrictness
to :: forall x. Rep FieldStrictness x -&gt; FieldStrictness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-cpp">
#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><span id="line-313"></span><span>
</span><span id="line-314"></span><span class="annot"><span class="hs-comment">-- | Information about a constructor field's unpackedness annotation.</span></span><span>
</span><span id="line-315"></span><span class="hs-keyword">data</span><span> </span><span id="Unpackedness"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Unpackedness"><span class="hs-identifier hs-var">Unpackedness</span></a></span></span><span>
</span><span id="line-316"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="UnspecifiedUnpackedness"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#UnspecifiedUnpackedness"><span class="hs-identifier hs-var">UnspecifiedUnpackedness</span></a></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ No annotation whatsoever</span></span><span>
</span><span id="line-317"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NoUnpack"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NoUnpack"><span class="hs-identifier hs-var">NoUnpack</span></a></span></span><span>                </span><span class="annot"><span class="hs-comment">-- ^ Annotated with @{\-\# NOUNPACK \#-\}@</span></span><span>
</span><span id="line-318"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Unpack"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Unpack"><span class="hs-identifier hs-var">Unpack</span></a></span></span><span>                  </span><span class="annot"><span class="hs-comment">-- ^ Annotated with @{\-\# UNPACK \#-\}@</span></span><span>
</span><span id="line-319"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679073784"><span id="local-6989586621679073786"><span id="local-6989586621679073789"><span class="annot"><span class="annottext">Int -&gt; Unpackedness -&gt; ShowS
[Unpackedness] -&gt; ShowS
Unpackedness -&gt; String
(Int -&gt; Unpackedness -&gt; ShowS)
-&gt; (Unpackedness -&gt; String)
-&gt; ([Unpackedness] -&gt; ShowS)
-&gt; Show Unpackedness
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; Unpackedness -&gt; ShowS
showsPrec :: Int -&gt; Unpackedness -&gt; ShowS
$cshow :: Unpackedness -&gt; String
show :: Unpackedness -&gt; String
$cshowList :: [Unpackedness] -&gt; ShowS
showList :: [Unpackedness] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073792"><span id="local-6989586621679073794"><span class="annot"><span class="annottext">Unpackedness -&gt; Unpackedness -&gt; Bool
(Unpackedness -&gt; Unpackedness -&gt; Bool)
-&gt; (Unpackedness -&gt; Unpackedness -&gt; Bool) -&gt; Eq Unpackedness
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Unpackedness -&gt; Unpackedness -&gt; Bool
== :: Unpackedness -&gt; Unpackedness -&gt; Bool
$c/= :: Unpackedness -&gt; Unpackedness -&gt; Bool
/= :: Unpackedness -&gt; Unpackedness -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073799"><span id="local-6989586621679073801"><span id="local-6989586621679073803"><span id="local-6989586621679073806"><span id="local-6989586621679073809"><span id="local-6989586621679073812"><span id="local-6989586621679073815"><span class="annot"><span class="annottext">Eq Unpackedness
Eq Unpackedness =&gt;
(Unpackedness -&gt; Unpackedness -&gt; Ordering)
-&gt; (Unpackedness -&gt; Unpackedness -&gt; Bool)
-&gt; (Unpackedness -&gt; Unpackedness -&gt; Bool)
-&gt; (Unpackedness -&gt; Unpackedness -&gt; Bool)
-&gt; (Unpackedness -&gt; Unpackedness -&gt; Bool)
-&gt; (Unpackedness -&gt; Unpackedness -&gt; Unpackedness)
-&gt; (Unpackedness -&gt; Unpackedness -&gt; Unpackedness)
-&gt; Ord Unpackedness
Unpackedness -&gt; Unpackedness -&gt; Bool
Unpackedness -&gt; Unpackedness -&gt; Ordering
Unpackedness -&gt; Unpackedness -&gt; Unpackedness
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Unpackedness -&gt; Unpackedness -&gt; Ordering
compare :: Unpackedness -&gt; Unpackedness -&gt; Ordering
$c&lt; :: Unpackedness -&gt; Unpackedness -&gt; Bool
&lt; :: Unpackedness -&gt; Unpackedness -&gt; Bool
$c&lt;= :: Unpackedness -&gt; Unpackedness -&gt; Bool
&lt;= :: Unpackedness -&gt; Unpackedness -&gt; Bool
$c&gt; :: Unpackedness -&gt; Unpackedness -&gt; Bool
&gt; :: Unpackedness -&gt; Unpackedness -&gt; Bool
$c&gt;= :: Unpackedness -&gt; Unpackedness -&gt; Bool
&gt;= :: Unpackedness -&gt; Unpackedness -&gt; Bool
$cmax :: Unpackedness -&gt; Unpackedness -&gt; Unpackedness
max :: Unpackedness -&gt; Unpackedness -&gt; Unpackedness
$cmin :: Unpackedness -&gt; Unpackedness -&gt; Unpackedness
min :: Unpackedness -&gt; Unpackedness -&gt; Unpackedness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073820"><span id="local-6989586621679073822"><span id="local-6989586621679073824"><span id="local-6989586621679073826"><span id="local-6989586621679073828"><span id="local-6989586621679073833"><span id="local-6989586621679073838"><span id="local-6989586621679073841"><span id="local-6989586621679073844"><span id="local-6989586621679073847"><span id="local-6989586621679073850"><span id="local-6989586621679073853"><span id="local-6989586621679073858"><span id="local-6989586621679073863"><span class="annot"><span class="annottext">Typeable Unpackedness
Typeable Unpackedness =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Unpackedness -&gt; c Unpackedness)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Unpackedness)
-&gt; (Unpackedness -&gt; Constr)
-&gt; (Unpackedness -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Unpackedness))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c Unpackedness))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Unpackedness -&gt; Unpackedness)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness)
-&gt; Data Unpackedness
Unpackedness -&gt; Constr
Unpackedness -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Unpackedness -&gt; Unpackedness
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Unpackedness
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Unpackedness -&gt; c Unpackedness
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Unpackedness)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c Unpackedness)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Unpackedness -&gt; c Unpackedness
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Unpackedness -&gt; c Unpackedness
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Unpackedness
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Unpackedness
$ctoConstr :: Unpackedness -&gt; Constr
toConstr :: Unpackedness -&gt; Constr
$cdataTypeOf :: Unpackedness -&gt; DataType
dataTypeOf :: Unpackedness -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Unpackedness)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Unpackedness)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c Unpackedness)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c Unpackedness)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Unpackedness -&gt; Unpackedness
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Unpackedness -&gt; Unpackedness
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-cpp">
#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span id="local-6989586621679073868"><span id="local-6989586621679073870"><span class="annot"><span class="annottext">(forall x. Unpackedness -&gt; Rep Unpackedness x)
-&gt; (forall x. Rep Unpackedness x -&gt; Unpackedness)
-&gt; Generic Unpackedness
forall x. Rep Unpackedness x -&gt; Unpackedness
forall x. Unpackedness -&gt; Rep Unpackedness x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Unpackedness -&gt; Rep Unpackedness x
from :: forall x. Unpackedness -&gt; Rep Unpackedness x
$cto :: forall x. Rep Unpackedness x -&gt; Unpackedness
to :: forall x. Rep Unpackedness x -&gt; Unpackedness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-cpp">
#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><span id="line-324"></span><span>
</span><span id="line-325"></span><span class="annot"><span class="hs-comment">-- | Information about a constructor field's strictness annotation.</span></span><span>
</span><span id="line-326"></span><span class="hs-keyword">data</span><span> </span><span id="Strictness"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Strictness"><span class="hs-identifier hs-var">Strictness</span></a></span></span><span>
</span><span id="line-327"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="UnspecifiedStrictness"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#UnspecifiedStrictness"><span class="hs-identifier hs-var">UnspecifiedStrictness</span></a></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ No annotation whatsoever</span></span><span>
</span><span id="line-328"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Lazy"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Lazy"><span class="hs-identifier hs-var">Lazy</span></a></span></span><span>                  </span><span class="annot"><span class="hs-comment">-- ^ Annotated with @~@</span></span><span>
</span><span id="line-329"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Strict"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Strict"><span class="hs-identifier hs-var">Strict</span></a></span></span><span>                </span><span class="annot"><span class="hs-comment">-- ^ Annotated with @!@</span></span><span>
</span><span id="line-330"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679073873"><span id="local-6989586621679073875"><span id="local-6989586621679073878"><span class="annot"><span class="annottext">Int -&gt; Strictness -&gt; ShowS
[Strictness] -&gt; ShowS
Strictness -&gt; String
(Int -&gt; Strictness -&gt; ShowS)
-&gt; (Strictness -&gt; String)
-&gt; ([Strictness] -&gt; ShowS)
-&gt; Show Strictness
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; Strictness -&gt; ShowS
showsPrec :: Int -&gt; Strictness -&gt; ShowS
$cshow :: Strictness -&gt; String
show :: Strictness -&gt; String
$cshowList :: [Strictness] -&gt; ShowS
showList :: [Strictness] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073881"><span id="local-6989586621679073883"><span class="annot"><span class="annottext">Strictness -&gt; Strictness -&gt; Bool
(Strictness -&gt; Strictness -&gt; Bool)
-&gt; (Strictness -&gt; Strictness -&gt; Bool) -&gt; Eq Strictness
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Strictness -&gt; Strictness -&gt; Bool
== :: Strictness -&gt; Strictness -&gt; Bool
$c/= :: Strictness -&gt; Strictness -&gt; Bool
/= :: Strictness -&gt; Strictness -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073888"><span id="local-6989586621679073890"><span id="local-6989586621679073892"><span id="local-6989586621679073895"><span id="local-6989586621679073898"><span id="local-6989586621679073901"><span id="local-6989586621679073904"><span class="annot"><span class="annottext">Eq Strictness
Eq Strictness =&gt;
(Strictness -&gt; Strictness -&gt; Ordering)
-&gt; (Strictness -&gt; Strictness -&gt; Bool)
-&gt; (Strictness -&gt; Strictness -&gt; Bool)
-&gt; (Strictness -&gt; Strictness -&gt; Bool)
-&gt; (Strictness -&gt; Strictness -&gt; Bool)
-&gt; (Strictness -&gt; Strictness -&gt; Strictness)
-&gt; (Strictness -&gt; Strictness -&gt; Strictness)
-&gt; Ord Strictness
Strictness -&gt; Strictness -&gt; Bool
Strictness -&gt; Strictness -&gt; Ordering
Strictness -&gt; Strictness -&gt; Strictness
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Strictness -&gt; Strictness -&gt; Ordering
compare :: Strictness -&gt; Strictness -&gt; Ordering
$c&lt; :: Strictness -&gt; Strictness -&gt; Bool
&lt; :: Strictness -&gt; Strictness -&gt; Bool
$c&lt;= :: Strictness -&gt; Strictness -&gt; Bool
&lt;= :: Strictness -&gt; Strictness -&gt; Bool
$c&gt; :: Strictness -&gt; Strictness -&gt; Bool
&gt; :: Strictness -&gt; Strictness -&gt; Bool
$c&gt;= :: Strictness -&gt; Strictness -&gt; Bool
&gt;= :: Strictness -&gt; Strictness -&gt; Bool
$cmax :: Strictness -&gt; Strictness -&gt; Strictness
max :: Strictness -&gt; Strictness -&gt; Strictness
$cmin :: Strictness -&gt; Strictness -&gt; Strictness
min :: Strictness -&gt; Strictness -&gt; Strictness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679073909"><span id="local-6989586621679073911"><span id="local-6989586621679073913"><span id="local-6989586621679073915"><span id="local-6989586621679073917"><span id="local-6989586621679073922"><span id="local-6989586621679073927"><span id="local-6989586621679073930"><span id="local-6989586621679073933"><span id="local-6989586621679073936"><span id="local-6989586621679073939"><span id="local-6989586621679073942"><span id="local-6989586621679073947"><span id="local-6989586621679073952"><span class="annot"><span class="annottext">Typeable Strictness
Typeable Strictness =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Strictness -&gt; c Strictness)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Strictness)
-&gt; (Strictness -&gt; Constr)
-&gt; (Strictness -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Strictness))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c Strictness))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Strictness -&gt; Strictness)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness)
-&gt; Data Strictness
Strictness -&gt; Constr
Strictness -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Strictness -&gt; Strictness
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Strictness
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Strictness -&gt; c Strictness
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Strictness)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Strictness)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Strictness -&gt; c Strictness
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Strictness -&gt; c Strictness
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Strictness
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Strictness
$ctoConstr :: Strictness -&gt; Constr
toConstr :: Strictness -&gt; Constr
$cdataTypeOf :: Strictness -&gt; DataType
dataTypeOf :: Strictness -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Strictness)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Strictness)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Strictness)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Strictness)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Strictness -&gt; Strictness
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Strictness -&gt; Strictness
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-cpp">
#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span id="local-6989586621679073957"><span id="local-6989586621679073959"><span class="annot"><span class="annottext">(forall x. Strictness -&gt; Rep Strictness x)
-&gt; (forall x. Rep Strictness x -&gt; Strictness) -&gt; Generic Strictness
forall x. Rep Strictness x -&gt; Strictness
forall x. Strictness -&gt; Rep Strictness x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Strictness -&gt; Rep Strictness x
from :: forall x. Strictness -&gt; Rep Strictness x
$cto :: forall x. Rep Strictness x -&gt; Strictness
to :: forall x. Rep Strictness x -&gt; Strictness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-cpp">
#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><span id="line-335"></span><span>
</span><span id="line-336"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#isStrictAnnot"><span class="hs-identifier hs-type">isStrictAnnot</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#notStrictAnnot"><span class="hs-identifier hs-type">notStrictAnnot</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unpackedAnnot"><span class="hs-identifier hs-type">unpackedAnnot</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a></span><span>
</span><span id="line-337"></span><span id="isStrictAnnot"><span class="annot"><span class="annottext">isStrictAnnot :: FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#isStrictAnnot"><span class="hs-identifier hs-var hs-var">isStrictAnnot</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Unpackedness -&gt; Strictness -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">Unpackedness
</span><a href="Language.Haskell.TH.Datatype.html#UnspecifiedUnpackedness"><span class="hs-identifier hs-var">UnspecifiedUnpackedness</span></a></span><span> </span><span class="annot"><span class="annottext">Strictness
</span><a href="Language.Haskell.TH.Datatype.html#Strict"><span class="hs-identifier hs-var">Strict</span></a></span><span>
</span><span id="line-338"></span><span id="notStrictAnnot"><span class="annot"><span class="annottext">notStrictAnnot :: FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#notStrictAnnot"><span class="hs-identifier hs-var hs-var">notStrictAnnot</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Unpackedness -&gt; Strictness -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">Unpackedness
</span><a href="Language.Haskell.TH.Datatype.html#UnspecifiedUnpackedness"><span class="hs-identifier hs-var">UnspecifiedUnpackedness</span></a></span><span> </span><span class="annot"><span class="annottext">Strictness
</span><a href="Language.Haskell.TH.Datatype.html#UnspecifiedStrictness"><span class="hs-identifier hs-var">UnspecifiedStrictness</span></a></span><span>
</span><span id="line-339"></span><span id="unpackedAnnot"><span class="annot"><span class="annottext">unpackedAnnot :: FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#unpackedAnnot"><span class="hs-identifier hs-var hs-var">unpackedAnnot</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Unpackedness -&gt; Strictness -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">Unpackedness
</span><a href="Language.Haskell.TH.Datatype.html#Unpack"><span class="hs-identifier hs-var">Unpack</span></a></span><span> </span><span class="annot"><span class="annottext">Strictness
</span><a href="Language.Haskell.TH.Datatype.html#Strict"><span class="hs-identifier hs-var">Strict</span></a></span><span>
</span><span id="line-340"></span><span>
</span><span id="line-341"></span><span class="hs-comment">-- | Construct a Type using the datatype's type constructor and type</span><span>
</span><span id="line-342"></span><span class="hs-comment">-- parameters. Kind signatures are removed.</span><span>
</span><span id="line-343"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#datatypeType"><span class="hs-identifier hs-type">datatypeType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-344"></span><span id="datatypeType"><span class="annot"><span class="annottext">datatypeType :: DatatypeInfo -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#datatypeType"><span class="hs-identifier hs-var hs-var">datatypeType</span></a></span></span><span> </span><span id="local-6989586621679073961"><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679073961"><span class="hs-identifier hs-var">di</span></a></span></span><span>
</span><span id="line-345"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type -&gt; Type) -&gt; Type -&gt; [Type] -&gt; Type
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">ConT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#datatypeName"><span class="hs-identifier hs-var">datatypeName</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679073961"><span class="hs-identifier hs-var">di</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-346"></span><span>  </span><span class="annot"><span class="annottext">([Type] -&gt; Type) -&gt; [Type] -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; [Type] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#stripSigT"><span class="hs-identifier hs-var">stripSigT</span></a></span><span>
</span><span id="line-347"></span><span>  </span><span class="annot"><span class="annottext">([Type] -&gt; [Type]) -&gt; [Type] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeInstTypes"><span class="hs-identifier hs-var">datatypeInstTypes</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679073961"><span class="hs-identifier hs-var">di</span></a></span><span>
</span><span id="line-348"></span><span>
</span><span id="line-349"></span><span>
</span><span id="line-350"></span><span class="hs-comment">-- | Compute a normalized view of the metadata about a data type or newtype</span><span>
</span><span id="line-351"></span><span class="hs-comment">-- given a constructor.</span><span>
</span><span id="line-352"></span><span class="hs-comment">--</span><span>
</span><span id="line-353"></span><span class="hs-comment">-- This function will accept any constructor (value or type) for a type</span><span>
</span><span id="line-354"></span><span class="hs-comment">-- declared with newtype or data. Value constructors must be used to</span><span>
</span><span id="line-355"></span><span class="hs-comment">-- lookup datatype information about /data instances/ and /newtype instances/,</span><span>
</span><span id="line-356"></span><span class="hs-comment">-- as giving the type constructor of a data family is often not enough to</span><span>
</span><span id="line-357"></span><span class="hs-comment">-- determine a particular data family instance.</span><span>
</span><span id="line-358"></span><span class="hs-comment">--</span><span>
</span><span id="line-359"></span><span class="hs-comment">-- In addition, this function will also accept a record selector for a</span><span>
</span><span id="line-360"></span><span class="hs-comment">-- data type with a constructor which uses that record.</span><span>
</span><span id="line-361"></span><span class="hs-comment">--</span><span>
</span><span id="line-362"></span><span class="hs-comment">-- GADT constructors are normalized into datatypes with explicit equality</span><span>
</span><span id="line-363"></span><span class="hs-comment">-- constraints. Note that no effort is made to distinguish between equalities of</span><span>
</span><span id="line-364"></span><span class="hs-comment">-- the same (homogeneous) kind and equalities between different (heterogeneous)</span><span>
</span><span id="line-365"></span><span class="hs-comment">-- kinds. For instance, the following GADT's constructors:</span><span>
</span><span id="line-366"></span><span class="hs-comment">--</span><span>
</span><span id="line-367"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-368"></span><span class="hs-comment">-- data T (a :: k -&gt; *) where</span><span>
</span><span id="line-369"></span><span class="hs-comment">--   MkT1 :: T Proxy</span><span>
</span><span id="line-370"></span><span class="hs-comment">--   MkT2 :: T Maybe</span><span>
</span><span id="line-371"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-372"></span><span class="hs-comment">--</span><span>
</span><span id="line-373"></span><span class="hs-comment">-- will be normalized to the following equality constraints:</span><span>
</span><span id="line-374"></span><span class="hs-comment">--</span><span>
</span><span id="line-375"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-376"></span><span class="hs-comment">-- AppT (AppT EqualityT (VarT a)) (ConT Proxy) -- MkT1</span><span>
</span><span id="line-377"></span><span class="hs-comment">-- AppT (AppT EqualityT (VarT a)) (ConT Maybe) -- MkT2</span><span>
</span><span id="line-378"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-379"></span><span class="hs-comment">--</span><span>
</span><span id="line-380"></span><span class="hs-comment">-- But only the first equality constraint is well kinded, since in the second</span><span>
</span><span id="line-381"></span><span class="hs-comment">-- constraint, the kinds of @(a :: k -&gt; *)@ and @(Maybe :: * -&gt; *)@ are different.</span><span>
</span><span id="line-382"></span><span class="hs-comment">-- Trying to categorize which constraints need homogeneous or heterogeneous</span><span>
</span><span id="line-383"></span><span class="hs-comment">-- equality is tricky, so we leave that task to users of this library.</span><span>
</span><span id="line-384"></span><span class="hs-comment">--</span><span>
</span><span id="line-385"></span><span class="hs-comment">-- Primitive types (other than unboxed sums and tuples) will have</span><span>
</span><span id="line-386"></span><span class="hs-comment">-- no @datatypeCons@ in their normalization.</span><span>
</span><span id="line-387"></span><span class="hs-comment">--</span><span>
</span><span id="line-388"></span><span class="hs-comment">-- This function will apply various bug-fixes to the output of the underlying</span><span>
</span><span id="line-389"></span><span class="hs-comment">-- @template-haskell@ library in order to provide a view of datatypes in</span><span>
</span><span id="line-390"></span><span class="hs-comment">-- as uniform a way as possible.</span><span>
</span><span id="line-391"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyDatatype"><span class="hs-identifier hs-type">reifyDatatype</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-392"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-comment">{- ^ data type or constructor name -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-393"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-394"></span><span id="reifyDatatype"><span class="annot"><span class="annottext">reifyDatatype :: Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyDatatype"><span class="hs-identifier hs-var hs-var">reifyDatatype</span></a></span></span><span> </span><span id="local-6989586621679073964"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073964"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Bool -&gt; Info -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeInfo%27"><span class="hs-identifier hs-var">normalizeInfo'</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;reifyDatatype&quot;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="Language.Haskell.TH.Datatype.html#isReified"><span class="hs-identifier hs-var">isReified</span></a></span><span> </span><span class="annot"><span class="annottext">(Info -&gt; Q DatatypeInfo) -&gt; Q Info -&gt; Q DatatypeInfo
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q Info
</span><span class="hs-identifier hs-var">reify</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073964"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-395"></span><span>
</span><span id="line-396"></span><span class="hs-comment">-- | Compute a normalized view of the metadata about a constructor given its</span><span>
</span><span id="line-397"></span><span class="hs-comment">-- 'Name'. This is useful for scenarios when you don't care about the info for</span><span>
</span><span id="line-398"></span><span class="hs-comment">-- the enclosing data type.</span><span>
</span><span id="line-399"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyConstructor"><span class="hs-identifier hs-type">reifyConstructor</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-400"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-comment">{- ^ constructor name -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-401"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span>
</span><span id="line-402"></span><span id="reifyConstructor"><span class="annot"><span class="annottext">reifyConstructor :: Name -&gt; Q ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyConstructor"><span class="hs-identifier hs-var hs-var">reifyConstructor</span></a></span></span><span> </span><span id="local-6989586621679073969"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073969"><span class="hs-identifier hs-var">conName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-403"></span><span>  </span><span id="local-6989586621679073970"><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679073970"><span class="hs-identifier hs-var">dataInfo</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyDatatype"><span class="hs-identifier hs-var">reifyDatatype</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073969"><span class="hs-identifier hs-var">conName</span></a></span><span>
</span><span id="line-404"></span><span>  </span><span class="annot"><span class="annottext">ConstructorInfo -&gt; Q ConstructorInfo
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(ConstructorInfo -&gt; Q ConstructorInfo)
-&gt; ConstructorInfo -&gt; Q ConstructorInfo
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; DatatypeInfo -&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#lookupByConstructorName"><span class="hs-identifier hs-var">lookupByConstructorName</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073969"><span class="hs-identifier hs-var">conName</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679073970"><span class="hs-identifier hs-var">dataInfo</span></a></span><span>
</span><span id="line-405"></span><span>
</span><span id="line-406"></span><span class="hs-comment">-- | Compute a normalized view of the metadata about a constructor given the</span><span>
</span><span id="line-407"></span><span class="hs-comment">-- 'Name' of one of its record selectors. This is useful for scenarios when you</span><span>
</span><span id="line-408"></span><span class="hs-comment">-- don't care about the info for the enclosing data type.</span><span>
</span><span id="line-409"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyRecord"><span class="hs-identifier hs-type">reifyRecord</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-410"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-comment">{- ^ record name -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-411"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span>
</span><span id="line-412"></span><span id="reifyRecord"><span class="annot"><span class="annottext">reifyRecord :: Name -&gt; Q ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyRecord"><span class="hs-identifier hs-var hs-var">reifyRecord</span></a></span></span><span> </span><span id="local-6989586621679073971"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073971"><span class="hs-identifier hs-var">recordName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-413"></span><span>  </span><span id="local-6989586621679073972"><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679073972"><span class="hs-identifier hs-var">dataInfo</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyDatatype"><span class="hs-identifier hs-var">reifyDatatype</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073971"><span class="hs-identifier hs-var">recordName</span></a></span><span>
</span><span id="line-414"></span><span>  </span><span class="annot"><span class="annottext">ConstructorInfo -&gt; Q ConstructorInfo
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(ConstructorInfo -&gt; Q ConstructorInfo)
-&gt; ConstructorInfo -&gt; Q ConstructorInfo
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; DatatypeInfo -&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#lookupByRecordName"><span class="hs-identifier hs-var">lookupByRecordName</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073971"><span class="hs-identifier hs-var">recordName</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679073972"><span class="hs-identifier hs-var">dataInfo</span></a></span><span>
</span><span id="line-415"></span><span>
</span><span id="line-416"></span><span class="hs-comment">-- | Given a 'DatatypeInfo', find the 'ConstructorInfo' corresponding to the</span><span>
</span><span id="line-417"></span><span class="hs-comment">-- 'Name' of one of its constructors.</span><span>
</span><span id="line-418"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#lookupByConstructorName"><span class="hs-identifier hs-type">lookupByConstructorName</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-419"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-comment">{- ^ constructor name -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-420"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="annot"><span class="hs-comment">{- ^ info for the datatype which has that constructor -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-421"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span>
</span><span id="line-422"></span><span id="lookupByConstructorName"><span class="annot"><span class="annottext">lookupByConstructorName :: Name -&gt; DatatypeInfo -&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#lookupByConstructorName"><span class="hs-identifier hs-var hs-var">lookupByConstructorName</span></a></span></span><span> </span><span id="local-6989586621679073973"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073973"><span class="hs-identifier hs-var">conName</span></a></span></span><span> </span><span id="local-6989586621679073974"><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679073974"><span class="hs-identifier hs-var">dataInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-423"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(ConstructorInfo -&gt; Bool)
-&gt; [ConstructorInfo] -&gt; Maybe ConstructorInfo
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Maybe a
</span><span class="hs-identifier hs-var">find</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073973"><span class="hs-identifier hs-var">conName</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Bool)
-&gt; (ConstructorInfo -&gt; Name) -&gt; ConstructorInfo -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#constructorName"><span class="hs-identifier hs-var">constructorName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var">datatypeCons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679073974"><span class="hs-identifier hs-var">dataInfo</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-424"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679073976"><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679073976"><span class="hs-identifier hs-var">conInfo</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679073976"><span class="hs-identifier hs-var">conInfo</span></a></span><span>
</span><span id="line-425"></span><span>    </span><span class="annot"><span class="annottext">Maybe ConstructorInfo
</span><span class="hs-identifier hs-var">Nothing</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; ConstructorInfo
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; ConstructorInfo) -&gt; String -&gt; ConstructorInfo
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Datatype &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#datatypeName"><span class="hs-identifier hs-var">datatypeName</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679073974"><span class="hs-identifier hs-var">dataInfo</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-426"></span><span>                         </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot; does not have a constructor named &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073973"><span class="hs-identifier hs-var">conName</span></a></span><span>
</span><span id="line-427"></span><span class="hs-comment">-- | Given a 'DatatypeInfo', find the 'ConstructorInfo' corresponding to the</span><span>
</span><span id="line-428"></span><span class="hs-comment">-- 'Name' of one of its constructors.</span><span>
</span><span id="line-429"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#lookupByRecordName"><span class="hs-identifier hs-type">lookupByRecordName</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-430"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-comment">{- ^ record name -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-431"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="annot"><span class="hs-comment">{- ^ info for the datatype which has that constructor -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-432"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span>
</span><span id="line-433"></span><span id="lookupByRecordName"><span class="annot"><span class="annottext">lookupByRecordName :: Name -&gt; DatatypeInfo -&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#lookupByRecordName"><span class="hs-identifier hs-var hs-var">lookupByRecordName</span></a></span></span><span> </span><span id="local-6989586621679073979"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073979"><span class="hs-identifier hs-var">recordName</span></a></span></span><span> </span><span id="local-6989586621679073980"><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679073980"><span class="hs-identifier hs-var">dataInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-434"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(ConstructorInfo -&gt; Bool)
-&gt; [ConstructorInfo] -&gt; Maybe ConstructorInfo
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Maybe a
</span><span class="hs-identifier hs-var">find</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; ConstructorInfo -&gt; Bool
</span><a href="Language.Haskell.TH.Datatype.html#conHasRecord"><span class="hs-identifier hs-var">conHasRecord</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073979"><span class="hs-identifier hs-var">recordName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var">datatypeCons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679073980"><span class="hs-identifier hs-var">dataInfo</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-435"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679073982"><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679073982"><span class="hs-identifier hs-var">conInfo</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679073982"><span class="hs-identifier hs-var">conInfo</span></a></span><span>
</span><span id="line-436"></span><span>    </span><span class="annot"><span class="annottext">Maybe ConstructorInfo
</span><span class="hs-identifier hs-var">Nothing</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; ConstructorInfo
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; ConstructorInfo) -&gt; String -&gt; ConstructorInfo
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Datatype &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#datatypeName"><span class="hs-identifier hs-var">datatypeName</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679073980"><span class="hs-identifier hs-var">dataInfo</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-437"></span><span>                         </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot; does not have any constructors with a &quot;</span></span><span>
</span><span id="line-438"></span><span>                         </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;record selector named &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073979"><span class="hs-identifier hs-var">recordName</span></a></span><span>
</span><span id="line-439"></span><span>
</span><span id="line-440"></span><span class="hs-comment">-- | Normalize 'Info' for a newtype or datatype into a 'DatatypeInfo'.</span><span>
</span><span id="line-441"></span><span class="hs-comment">-- Fail in 'Q' otherwise.</span><span>
</span><span id="line-442"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeInfo"><span class="hs-identifier hs-type">normalizeInfo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Info</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-443"></span><span id="normalizeInfo"><span class="annot"><span class="annottext">normalizeInfo :: Info -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeInfo"><span class="hs-identifier hs-var hs-var">normalizeInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Bool -&gt; Info -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeInfo%27"><span class="hs-identifier hs-var">normalizeInfo'</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;normalizeInfo&quot;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="Language.Haskell.TH.Datatype.html#isn%27tReified"><span class="hs-identifier hs-var">isn'tReified</span></a></span><span>
</span><span id="line-444"></span><span>
</span><span id="line-445"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeInfo%27"><span class="hs-identifier hs-type">normalizeInfo'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Info</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-446"></span><span id="normalizeInfo%27"><span class="annot"><span class="annottext">normalizeInfo' :: String -&gt; Bool -&gt; Info -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeInfo%27"><span class="hs-identifier hs-var hs-var">normalizeInfo'</span></a></span></span><span> </span><span id="local-6989586621679073985"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679073985"><span class="hs-identifier hs-var">entry</span></a></span></span><span> </span><span id="local-6989586621679073986"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679073986"><span class="hs-identifier hs-var">reifiedDec</span></a></span></span><span> </span><span id="local-6989586621679073987"><span class="annot"><span class="annottext">Info
</span><a href="#local-6989586621679073987"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-447"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Info
</span><a href="#local-6989586621679073987"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-448"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">PrimTyConI</span></span><span> </span><span id="local-6989586621679073989"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073989"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679073990"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679073990"><span class="hs-identifier hs-var">arity</span></a></span></span><span> </span><span id="local-6989586621679073991"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679073991"><span class="hs-identifier hs-var">unlifted</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,16,0)
</span><span>      </span><span class="hs-comment">-- We provide a minimal @DataD@ because, since TH 2.16,</span><span>
</span><span id="line-451"></span><span>      </span><span class="hs-comment">-- we can rely on the call to @reifyType@ in</span><span>
</span><span id="line-452"></span><span>      </span><span class="hs-comment">-- @normalizeDecFor@ to fill in the missing details.</span><span>
</span><span id="line-453"></span><span>      </span><span class="annot"><span class="annottext">Bool -&gt; Dec -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-var">normalizeDecFor</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679073986"><span class="hs-identifier hs-var">reifiedDec</span></a></span><span> </span><span class="annot"><span class="annottext">(Dec -&gt; Q DatatypeInfo) -&gt; Dec -&gt; Q DatatypeInfo
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Type]
-&gt; Name
-&gt; [TyVarBndr BndrVis]
-&gt; Maybe Type
-&gt; [Con]
-&gt; [DerivClause]
-&gt; Dec
</span><span class="hs-identifier hs-var">DataD</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679073989"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Maybe Type
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-cpp">
#else
</span><span>      </span><span class="hs-comment">-- On older versions, we are very limited in what we can deduce.</span><span>
</span><span id="line-456"></span><span>      </span><span class="hs-comment">-- All we know is the appropriate amount of type constructors.</span><span>
</span><span id="line-457"></span><span>      </span><span class="hs-comment">-- Note that this will default all kinds to @Type@, which is all</span><span>
</span><span id="line-458"></span><span>      </span><span class="hs-comment">-- that is available anyway.</span><span>
</span><span id="line-459"></span><span>      </span><span class="hs-identifier">args</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">replicateM</span><span> </span><span class="hs-identifier">arity</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">newName</span><span> </span><span class="hs-string">&quot;x&quot;</span><span class="hs-special">)</span><span>
</span><span id="line-460"></span><span>      </span><span class="hs-identifier">dec</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">dataDCompat</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">return</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">map</span><span> </span><span class="hs-identifier">plainTV</span><span> </span><span class="hs-identifier">args</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-461"></span><span>      </span><span class="hs-identifier">normalizeDecFor</span><span> </span><span class="hs-identifier">reifiedDec</span><span> </span><span class="hs-identifier">dec</span><span class="hs-cpp">
#endif
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">ClassI</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span>                          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall {m :: * -&gt; *} {a}. MonadFail m =&gt; String -&gt; m a
</span><a href="#local-6989586621679073995"><span class="hs-identifier hs-var">bad</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Class not supported&quot;</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">FamilyI</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">DataFamilyD</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="annot"><span class="annottext">[Dec]
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">-&gt;</span><span class="hs-cpp">
#elif MIN_VERSION_template_haskell(2,7,0)
</span><span>    </span><span class="hs-identifier">FamilyI</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">DataFam</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span class="hs-cpp">
#else
</span><span>    </span><span class="hs-identifier">TyConI</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">DataFam</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">-&gt;</span><span class="hs-cpp">
#endif
</span><span>                                         </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall {m :: * -&gt; *} {a}. MonadFail m =&gt; String -&gt; m a
</span><a href="#local-6989586621679073995"><span class="hs-identifier hs-var">bad</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Use a value constructor to reify a data family instance&quot;</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,7,0)
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">FamilyI</span></span><span> </span><span class="annot"><span class="annottext">Dec
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Dec]
</span><span class="hs-identifier">_</span></span><span>                       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall {m :: * -&gt; *} {a}. MonadFail m =&gt; String -&gt; m a
</span><a href="#local-6989586621679073995"><span class="hs-identifier hs-var">bad</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Type families not supported&quot;</span></span><span class="hs-cpp">
#endif
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">TyConI</span></span><span> </span><span id="local-6989586621679073999"><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679073999"><span class="hs-identifier hs-var">dec</span></a></span></span><span>                        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Dec -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-var">normalizeDecFor</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679073986"><span class="hs-identifier hs-var">reifiedDec</span></a></span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679073999"><span class="hs-identifier hs-var">dec</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">DataConI</span></span><span> </span><span id="local-6989586621679074001"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074001"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679074002"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074002"><span class="hs-identifier hs-var">parent</span></a></span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyParent"><span class="hs-identifier hs-var">reifyParent</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074001"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074002"><span class="hs-identifier hs-var">parent</span></a></span><span>
</span><span id="line-478"></span><span>                                         </span><span class="hs-comment">-- NB: We do not pass the IsReifiedDec information here</span><span>
</span><span id="line-479"></span><span>                                         </span><span class="hs-comment">-- because there's no point. We have no choice but to</span><span>
</span><span id="line-480"></span><span>                                         </span><span class="hs-comment">-- call reify here, since we need to determine the</span><span>
</span><span id="line-481"></span><span>                                         </span><span class="hs-comment">-- parent data type/family.</span><span class="hs-cpp">
#else
</span><span>    </span><span class="hs-identifier">DataConI</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">parent</span><span> </span><span class="hs-identifier">_</span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">reifyParent</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">parent</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">VarI</span></span><span> </span><span id="local-6989586621679074005"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074005"><span class="hs-identifier hs-var">recName</span></a></span></span><span> </span><span id="local-6989586621679074006"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074006"><span class="hs-identifier hs-var">recTy</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe Dec
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyRecordType"><span class="hs-identifier hs-var">reifyRecordType</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074005"><span class="hs-identifier hs-var">recName</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074006"><span class="hs-identifier hs-var">recTy</span></a></span><span>
</span><span id="line-487"></span><span>                                         </span><span class="hs-comment">-- NB: Similarly, we do not pass the IsReifiedDec</span><span>
</span><span id="line-488"></span><span>                                         </span><span class="hs-comment">-- information here.</span><span class="hs-cpp">
#else
</span><span>    </span><span class="hs-identifier">VarI</span><span> </span><span class="hs-identifier">recName</span><span> </span><span class="hs-identifier">recTy</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">reifyRecordType</span><span> </span><span class="hs-identifier">recName</span><span> </span><span class="hs-identifier">recTy</span><span class="hs-cpp">
#endif
</span><span>    </span><span class="annot"><span class="annottext">Info
</span><span class="hs-identifier">_</span></span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall {m :: * -&gt; *} {a}. MonadFail m =&gt; String -&gt; m a
</span><a href="#local-6989586621679073995"><span class="hs-identifier hs-var">bad</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Expected a type constructor&quot;</span></span><span>
</span><span id="line-493"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-494"></span><span>    </span><span id="local-6989586621679073995"><span class="annot"><span class="annottext">bad :: String -&gt; m a
</span><a href="#local-6989586621679073995"><span class="hs-identifier hs-var hs-var">bad</span></a></span></span><span> </span><span id="local-6989586621679074019"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679074019"><span class="hs-identifier hs-var">msg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; m a
forall a. String -&gt; m a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679073985"><span class="hs-identifier hs-var">entry</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679074019"><span class="hs-identifier hs-var">msg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-495"></span><span>
</span><span id="line-496"></span><span>
</span><span id="line-497"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyParent"><span class="hs-identifier hs-type">reifyParent</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-498"></span><span id="reifyParent"><span class="annot"><span class="annottext">reifyParent :: Name -&gt; Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyParent"><span class="hs-identifier hs-var hs-var">reifyParent</span></a></span></span><span> </span><span id="local-6989586621679074020"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074020"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; (DatatypeInfo -&gt; Bool) -&gt; Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyParentWith"><span class="hs-identifier hs-var">reifyParentWith</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;reifyParent&quot;</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Bool
</span><a href="#local-6989586621679074022"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-499"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-500"></span><span>    </span><span class="annot"><a href="#local-6989586621679074022"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-501"></span><span>    </span><span id="local-6989586621679074022"><span class="annot"><span class="annottext">p :: DatatypeInfo -&gt; Bool
</span><a href="#local-6989586621679074022"><span class="hs-identifier hs-var hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679074023"><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679074023"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074020"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; Bool
forall a. Eq a =&gt; a -&gt; [a] -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-operator hs-var">`elem`</span></span><span> </span><span class="annot"><span class="annottext">(ConstructorInfo -&gt; Name) -&gt; [ConstructorInfo] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#constructorName"><span class="hs-identifier hs-var">constructorName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var">datatypeCons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679074023"><span class="hs-identifier hs-var">info</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-502"></span><span>
</span><span id="line-503"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyRecordType"><span class="hs-identifier hs-type">reifyRecordType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-504"></span><span id="reifyRecordType"><span class="annot"><span class="annottext">reifyRecordType :: Name -&gt; Type -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyRecordType"><span class="hs-identifier hs-var hs-var">reifyRecordType</span></a></span></span><span> </span><span id="local-6989586621679074025"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074025"><span class="hs-identifier hs-var">recName</span></a></span></span><span> </span><span id="local-6989586621679074026"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074026"><span class="hs-identifier hs-var">recTy</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-505"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074027"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074027"><span class="hs-identifier hs-var">argTys</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C-"><span class="hs-operator hs-type">:|-</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; ([TyVarBndrSpec], [Type], NonEmptySnoc Type)
</span><a href="Language.Haskell.TH.Datatype.html#uncurryType"><span class="hs-identifier hs-var">uncurryType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074026"><span class="hs-identifier hs-var">recTy</span></a></span><span>
</span><span id="line-506"></span><span>  </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074027"><span class="hs-identifier hs-var">argTys</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-507"></span><span>       </span><span id="local-6989586621679074030"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074030"><span class="hs-identifier hs-var">dataTy</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074031"><span class="hs-identifier hs-var">decomposeDataType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074030"><span class="hs-identifier hs-var">dataTy</span></a></span><span>
</span><span id="line-508"></span><span>       </span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Q DatatypeInfo
forall a. Q a
</span><a href="#local-6989586621679074032"><span class="hs-identifier hs-var">notRecSelFailure</span></a></span><span>
</span><span id="line-509"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-510"></span><span>    </span><span class="annot"><a href="#local-6989586621679074031"><span class="hs-identifier hs-type">decomposeDataType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-511"></span><span>    </span><span id="local-6989586621679074031"><span class="annot"><span class="annottext">decomposeDataType :: Type -&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074031"><span class="hs-identifier hs-var hs-var">decomposeDataType</span></a></span></span><span> </span><span id="local-6989586621679074033"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074033"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-512"></span><span>      </span><span class="hs-keyword">do</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type -&gt; NonEmpty Type
</span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074033"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-513"></span><span>           </span><span class="annot"><span class="hs-identifier hs-type">ConT</span></span><span> </span><span id="local-6989586621679074035"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074035"><span class="hs-identifier hs-var">parent</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; (DatatypeInfo -&gt; Bool) -&gt; Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyParentWith"><span class="hs-identifier hs-var">reifyParentWith</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;reifyRecordType&quot;</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Bool
</span><a href="#local-6989586621679074037"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074035"><span class="hs-identifier hs-var">parent</span></a></span><span>
</span><span id="line-514"></span><span>           </span><span class="annot"><span class="annottext">NonEmpty Type
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Q DatatypeInfo
forall a. Q a
</span><a href="#local-6989586621679074032"><span class="hs-identifier hs-var">notRecSelFailure</span></a></span><span>
</span><span id="line-515"></span><span>
</span><span id="line-516"></span><span>    </span><span id="local-6989586621679072455"><span class="annot"><a href="#local-6989586621679074032"><span class="hs-identifier hs-type">notRecSelFailure</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="#local-6989586621679072455"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-517"></span><span>    </span><span id="local-6989586621679074032"><span class="annot"><span class="annottext">notRecSelFailure :: forall a. Q a
</span><a href="#local-6989586621679074032"><span class="hs-identifier hs-var hs-var">notRecSelFailure</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q a
forall a. String -&gt; Q a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Q a) -&gt; String -&gt; Q a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-518"></span><span>      </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;reifyRecordType: Not a record selector type: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span>
</span><span id="line-519"></span><span>      </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074025"><span class="hs-identifier hs-var">recName</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot; :: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074026"><span class="hs-identifier hs-var">recTy</span></a></span><span>
</span><span id="line-520"></span><span>
</span><span id="line-521"></span><span>    </span><span class="annot"><a href="#local-6989586621679074037"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-522"></span><span>    </span><span id="local-6989586621679074037"><span class="annot"><span class="annottext">p :: DatatypeInfo -&gt; Bool
</span><a href="#local-6989586621679074037"><span class="hs-identifier hs-var hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679074041"><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679074041"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(ConstructorInfo -&gt; Bool) -&gt; [ConstructorInfo] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">any</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; ConstructorInfo -&gt; Bool
</span><a href="Language.Haskell.TH.Datatype.html#conHasRecord"><span class="hs-identifier hs-var">conHasRecord</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074025"><span class="hs-identifier hs-var">recName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var">datatypeCons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679074041"><span class="hs-identifier hs-var">info</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-523"></span><span>
</span><span id="line-524"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyParentWith"><span class="hs-identifier hs-type">reifyParentWith</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-525"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>                 </span><span class="annot"><span class="hs-comment">{- ^ prefix for error messages -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-526"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">{- ^ predicate for finding the right
                              data family instance -}</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-528"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>                   </span><span class="annot"><span class="hs-comment">{- ^ parent data type name -}</span></span><span>     </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-529"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-530"></span><span id="reifyParentWith"><span class="annot"><span class="annottext">reifyParentWith :: String -&gt; (DatatypeInfo -&gt; Bool) -&gt; Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyParentWith"><span class="hs-identifier hs-var hs-var">reifyParentWith</span></a></span></span><span> </span><span id="local-6989586621679074043"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679074043"><span class="hs-identifier hs-var">prefix</span></a></span></span><span> </span><span id="local-6989586621679074044"><span class="annot"><span class="annottext">DatatypeInfo -&gt; Bool
</span><a href="#local-6989586621679074044"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679074045"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074045"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-531"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679074046"><span class="annot"><span class="annottext">Info
</span><a href="#local-6989586621679074046"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q Info
</span><span class="hs-identifier hs-var">reify</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074045"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-532"></span><span>     </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Info
</span><a href="#local-6989586621679074046"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="hs-keyword">of</span><span class="hs-cpp">
#if !(MIN_VERSION_template_haskell(2,11,0))
</span><span>       </span><span class="hs-comment">-- This unusual combination of Info and Dec is only possible to reify on</span><span>
</span><span id="line-535"></span><span>       </span><span class="hs-comment">-- GHC 7.0 and 7.2, when you try to reify a data family. Because there's</span><span>
</span><span id="line-536"></span><span>       </span><span class="hs-comment">-- no way to reify the data family *instances* on these versions of GHC,</span><span>
</span><span id="line-537"></span><span>       </span><span class="hs-comment">-- we have no choice but to fail.</span><span>
</span><span id="line-538"></span><span>       </span><span class="hs-identifier">TyConI</span><span> </span><span class="hs-identifier">FamilyD</span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">dataFamiliesOnOldGHCsError</span><span class="hs-cpp">
#endif
</span><span>       </span><span class="annot"><span class="hs-identifier hs-type">TyConI</span></span><span> </span><span id="local-6989586621679074047"><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679074047"><span class="hs-identifier hs-var">dec</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Dec -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-var">normalizeDecFor</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="Language.Haskell.TH.Datatype.html#isReified"><span class="hs-identifier hs-var">isReified</span></a></span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679074047"><span class="hs-identifier hs-var">dec</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,7,0)
</span><span>       </span><span class="annot"><span class="hs-identifier hs-type">FamilyI</span></span><span> </span><span id="local-6989586621679074048"><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679074048"><span class="hs-identifier hs-var">dec</span></a></span></span><span> </span><span id="local-6989586621679074049"><span class="annot"><span class="annottext">[Dec]
</span><a href="#local-6989586621679074049"><span class="hs-identifier hs-var">instances</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-543"></span><span>         </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679074050"><span class="annot"><span class="annottext">[Dec]
</span><a href="#local-6989586621679074050"><span class="hs-identifier hs-var">instances1</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Dec -&gt; Q Dec) -&gt; [Dec] -&gt; Q [Dec]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Dec -&gt; Dec -&gt; Q Dec
</span><a href="Language.Haskell.TH.Datatype.html#repairDataFam"><span class="hs-identifier hs-var">repairDataFam</span></a></span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679074048"><span class="hs-identifier hs-var">dec</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Dec]
</span><a href="#local-6989586621679074049"><span class="hs-identifier hs-var">instances</span></a></span><span>
</span><span id="line-544"></span><span>            </span><span id="local-6989586621679074053"><span class="annot"><span class="annottext">[DatatypeInfo]
</span><a href="#local-6989586621679074053"><span class="hs-identifier hs-var">instances2</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Dec -&gt; Q DatatypeInfo) -&gt; [Dec] -&gt; Q [DatatypeInfo]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Dec -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-var">normalizeDecFor</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="Language.Haskell.TH.Datatype.html#isReified"><span class="hs-identifier hs-var">isReified</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Dec]
</span><a href="#local-6989586621679074050"><span class="hs-identifier hs-var">instances1</span></a></span><span>
</span><span id="line-545"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(DatatypeInfo -&gt; Bool) -&gt; [DatatypeInfo] -&gt; Maybe DatatypeInfo
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Maybe a
</span><span class="hs-identifier hs-var">find</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Bool
</span><a href="#local-6989586621679074044"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">[DatatypeInfo]
</span><a href="#local-6989586621679074053"><span class="hs-identifier hs-var">instances2</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-546"></span><span>              </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679074054"><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679074054"><span class="hs-identifier hs-var">inst</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Q DatatypeInfo
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679074054"><span class="hs-identifier hs-var">inst</span></a></span><span>
</span><span id="line-547"></span><span>              </span><span class="annot"><span class="annottext">Maybe DatatypeInfo
</span><span class="hs-identifier hs-var">Nothing</span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall a. String -&gt; Q a
</span><a href="#local-6989586621679074055"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;lost the instance&quot;</span></span><span class="hs-cpp">
#endif
</span><span>       </span><span class="annot"><span class="annottext">Info
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall a. String -&gt; Q a
</span><a href="#local-6989586621679074055"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;unexpected parent&quot;</span></span><span>
</span><span id="line-550"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-551"></span><span>    </span><span id="local-6989586621679074056"><span class="annot"><a href="#local-6989586621679074057"><span class="hs-identifier hs-type">dataFamiliesOnOldGHCsError</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="#local-6989586621679074056"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-552"></span><span>    </span><span id="local-6989586621679074057"><span class="annot"><span class="annottext">dataFamiliesOnOldGHCsError :: forall a. Q a
</span><a href="#local-6989586621679074057"><span class="hs-identifier hs-var hs-var">dataFamiliesOnOldGHCsError</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q a
forall a. String -&gt; Q a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Q a) -&gt; String -&gt; Q a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-553"></span><span>      </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679074043"><span class="hs-identifier hs-var">prefix</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;: Data family instances can only be reified with GHC 7.4 or later&quot;</span></span><span>
</span><span id="line-554"></span><span>
</span><span id="line-555"></span><span>    </span><span id="local-6989586621679074059"><span class="annot"><a href="#local-6989586621679074055"><span class="hs-identifier hs-type">panic</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="#local-6989586621679074059"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-556"></span><span>    </span><span id="local-6989586621679074055"><span class="annot"><span class="annottext">panic :: forall a. String -&gt; Q a
</span><a href="#local-6989586621679074055"><span class="hs-identifier hs-var hs-var">panic</span></a></span></span><span> </span><span id="local-6989586621679074061"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679074061"><span class="hs-identifier hs-var">message</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q a
forall a. String -&gt; Q a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Q a) -&gt; String -&gt; Q a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;PANIC: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679074043"><span class="hs-identifier hs-var">prefix</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot; &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679074061"><span class="hs-identifier hs-var">message</span></a></span><span class="hs-cpp">

#if MIN_VERSION_template_haskell(2,8,0) &amp;&amp; (!MIN_VERSION_template_haskell(2,10,0))
</span><span>
</span><span id="line-560"></span><span class="hs-comment">-- A GHC 7.6-specific bug requires us to replace all occurrences of</span><span>
</span><span id="line-561"></span><span class="hs-comment">-- (ConT GHC.Prim.*) with StarT, or else Template Haskell will reject it.</span><span>
</span><span id="line-562"></span><span class="hs-comment">-- Luckily, (ConT GHC.Prim.*) only seems to occur in this one spot.</span><span>
</span><span id="line-563"></span><span class="hs-identifier">sanitizeStars</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Kind</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Kind</span><span>
</span><span id="line-564"></span><span class="hs-identifier">sanitizeStars</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">go</span><span>
</span><span id="line-565"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-566"></span><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Kind</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Kind</span><span>
</span><span id="line-567"></span><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">AppT</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-identifier">t2</span><span class="hs-special">)</span><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">AppT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">t1</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">t2</span><span class="hs-special">)</span><span>
</span><span id="line-568"></span><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">SigT</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-identifier">k</span><span class="hs-special">)</span><span>                   </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">SigT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">t</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">k</span><span class="hs-special">)</span><span>
</span><span id="line-569"></span><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ConT</span><span> </span><span class="hs-identifier">n</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">starKindName</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">StarT</span><span>
</span><span id="line-570"></span><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">t</span><span>                            </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">t</span><span>
</span><span id="line-571"></span><span>
</span><span id="line-572"></span><span class="hs-comment">-- A version of repairVarKindsWith that does much more extra work to</span><span>
</span><span id="line-573"></span><span class="hs-comment">-- (1) eta-expand missing type patterns, and (2) ensure that the kind</span><span>
</span><span id="line-574"></span><span class="hs-comment">-- signatures for these new type patterns match accordingly.</span><span>
</span><span id="line-575"></span><span class="hs-identifier">repairVarKindsWith'</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">TyVarBndrUnit</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Maybe</span><span> </span><span class="hs-identifier">Kind</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Type</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Q</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Type</span><span class="hs-special">]</span><span>
</span><span id="line-576"></span><span class="hs-identifier">repairVarKindsWith'</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">dkind</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-577"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">kindVars</span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">map</span><span> </span><span class="hs-identifier">kindPart</span><span>
</span><span id="line-578"></span><span>      </span><span class="hs-identifier">kindPart</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">KindedTV</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">k</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">k</span><span class="hs-special">]</span><span>
</span><span id="line-579"></span><span>      </span><span class="hs-identifier">kindPart</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">PlainTV</span><span>  </span><span class="hs-identifier">_</span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-580"></span><span>
</span><span id="line-581"></span><span>      </span><span class="hs-identifier">nparams</span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">length</span><span> </span><span class="hs-identifier">dvars</span><span>
</span><span id="line-582"></span><span>      </span><span class="hs-identifier">kparams</span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">kindVars</span><span> </span><span class="hs-identifier">dvars</span><span>
</span><span id="line-583"></span><span>      </span><span class="hs-special">(</span><span class="hs-identifier">tsKinds</span><span class="hs-special">,</span><span class="hs-identifier">tsNoKinds</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">splitAt</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">length</span><span> </span><span class="hs-identifier">kparams</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">ts</span><span>
</span><span id="line-584"></span><span>      </span><span class="hs-identifier">tsKinds'</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">map</span><span> </span><span class="hs-identifier">sanitizeStars</span><span> </span><span class="hs-identifier">tsKinds</span><span>
</span><span id="line-585"></span><span>      </span><span class="hs-identifier">extraTys</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">drop</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">length</span><span> </span><span class="hs-identifier">tsNoKinds</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">bndrParams</span><span> </span><span class="hs-identifier">dvars</span><span class="hs-special">)</span><span>
</span><span id="line-586"></span><span>      </span><span class="hs-identifier">ts'</span><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">tsNoKinds</span><span> </span><span class="hs-operator">++</span><span> </span><span class="hs-identifier">extraTys</span><span> </span><span class="hs-comment">-- eta-expand</span><span>
</span><span id="line-587"></span><span>  </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">fmap</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Map.fromList</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">zip</span><span> </span><span class="hs-identifier">kparams</span><span> </span><span class="hs-identifier">tsKinds'</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-operator">$</span><span>
</span><span id="line-588"></span><span>     </span><span class="hs-identifier">repairVarKindsWith</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">dkind</span><span> </span><span class="hs-identifier">ts'</span><span>
</span><span id="line-589"></span><span>
</span><span id="line-590"></span><span>
</span><span id="line-591"></span><span class="hs-comment">-- Sadly, Template Haskell's treatment of data family instances leaves much</span><span>
</span><span id="line-592"></span><span class="hs-comment">-- to be desired. Here are some problems that we have to work around:</span><span>
</span><span id="line-593"></span><span class="hs-comment">--</span><span>
</span><span id="line-594"></span><span class="hs-comment">-- 1. On all versions of GHC, TH leaves off the kind signatures on the</span><span>
</span><span id="line-595"></span><span class="hs-comment">--    type patterns of data family instances where a kind signature isn't</span><span>
</span><span id="line-596"></span><span class="hs-comment">--    specified explicitly. Here, we can use the parent data family's</span><span>
</span><span id="line-597"></span><span class="hs-comment">--    type variable binders to reconstruct the kind signatures if they</span><span>
</span><span id="line-598"></span><span class="hs-comment">--    are missing.</span><span>
</span><span id="line-599"></span><span class="hs-comment">-- 2. On GHC 7.6 and 7.8, TH will eta-reduce data instances. We can find</span><span>
</span><span id="line-600"></span><span class="hs-comment">--    the missing type variables on the data constructor.</span><span>
</span><span id="line-601"></span><span class="hs-comment">--</span><span>
</span><span id="line-602"></span><span class="hs-comment">-- We opt to avoid propagating these new type variables through to the</span><span>
</span><span id="line-603"></span><span class="hs-comment">-- constructor now, but we will return to this task in normalizeCon.</span><span>
</span><span id="line-604"></span><span class="hs-identifier">repairDataFam</span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-605"></span><span>  </span><span class="hs-identifier">Dec</span><span> </span><span class="hs-comment">{- ^ family declaration   -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-606"></span><span>  </span><span class="hs-identifier">Dec</span><span> </span><span class="hs-comment">{- ^ instance declaration -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-607"></span><span>  </span><span class="hs-identifier">Q</span><span> </span><span class="hs-identifier">Dec</span><span> </span><span class="hs-comment">{- ^ instance declaration -}</span><span>
</span><span id="line-608"></span><span>
</span><span id="line-609"></span><span class="hs-identifier">repairDataFam</span><span>
</span><span id="line-610"></span><span>  </span><span class="hs-special">(</span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">dk</span><span class="hs-special">)</span><span>
</span><span id="line-611"></span><span>  </span><span class="hs-special">(</span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">deriv</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-612"></span><span>    </span><span class="hs-identifier">ts'</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">repairVarKindsWith'</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">dk</span><span> </span><span class="hs-identifier">ts</span><span>
</span><span id="line-613"></span><span>    </span><span class="hs-identifier">return</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts'</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">deriv</span><span>
</span><span id="line-614"></span><span class="hs-identifier">repairDataFam</span><span>
</span><span id="line-615"></span><span>  </span><span class="hs-special">(</span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">dk</span><span class="hs-special">)</span><span>
</span><span id="line-616"></span><span>  </span><span class="hs-special">(</span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">deriv</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-617"></span><span>    </span><span class="hs-identifier">ts'</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">repairVarKindsWith'</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">dk</span><span> </span><span class="hs-identifier">ts</span><span>
</span><span id="line-618"></span><span>    </span><span class="hs-identifier">return</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts'</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">deriv</span><span class="hs-cpp">
#else
</span><span id="repairDataFam"><span class="annot"><span class="annottext">repairDataFam :: Dec -&gt; Dec -&gt; Q Dec
</span><a href="Language.Haskell.TH.Datatype.html#repairDataFam"><span class="hs-identifier hs-var hs-var">repairDataFam</span></a></span></span><span> </span><span id="local-6989586621679074069"><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679074069"><span class="hs-identifier hs-var">famD</span></a></span></span><span> </span><span id="local-6989586621679074070"><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679074070"><span class="hs-identifier hs-var">instD</span></a></span></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,15,0)
</span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">DataFamilyD</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679074071"><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074071"><span class="hs-identifier hs-var">dvars</span></a></span></span><span> </span><span id="local-6989586621679074072"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074072"><span class="hs-identifier hs-var">dk</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679074069"><span class="hs-identifier hs-var">famD</span></a></span><span>
</span><span id="line-623"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NewtypeInstD</span></span><span> </span><span id="local-6989586621679074074"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074074"><span class="hs-identifier hs-var">cx</span></a></span></span><span> </span><span id="local-6989586621679074075"><span class="annot"><span class="annottext">Maybe [TyVarBndrUnit]
</span><a href="#local-6989586621679074075"><span class="hs-identifier hs-var">mbInstVars</span></a></span></span><span> </span><span id="local-6989586621679074076"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074076"><span class="hs-identifier hs-var">nts</span></a></span></span><span> </span><span id="local-6989586621679074077"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074077"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679074078"><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679074078"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679074079"><span class="annot"><span class="annottext">[DerivClause]
</span><a href="#local-6989586621679074079"><span class="hs-identifier hs-var">deriv</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679074070"><span class="hs-identifier hs-var">instD</span></a></span><span>
</span><span id="line-624"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074080"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074080"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679074081"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074081"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; NonEmpty Type
</span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074076"><span class="hs-identifier hs-var">nts</span></a></span><span>
</span><span id="line-625"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679074082"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074082"><span class="hs-identifier hs-var">ts'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis] -&gt; Maybe Type -&gt; [Type] -&gt; Q [Type]
</span><a href="Language.Haskell.TH.Datatype.html#repairVarKindsWith"><span class="hs-identifier hs-var">repairVarKindsWith</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074071"><span class="hs-identifier hs-var">dvars</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074072"><span class="hs-identifier hs-var">dk</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074081"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-626"></span><span>           </span><span class="annot"><span class="annottext">Dec -&gt; Q Dec
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Dec -&gt; Q Dec) -&gt; Dec -&gt; Q Dec
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Type]
-&gt; Maybe [TyVarBndrUnit]
-&gt; Type
-&gt; Maybe Type
-&gt; Con
-&gt; [DerivClause]
-&gt; Dec
</span><span class="hs-identifier hs-var">NewtypeInstD</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074074"><span class="hs-identifier hs-var">cx</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBndrUnit]
</span><a href="#local-6989586621679074075"><span class="hs-identifier hs-var">mbInstVars</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; Type -&gt; Type) -&gt; Type -&gt; [Type] -&gt; Type
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl'</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074080"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074082"><span class="hs-identifier hs-var">ts'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074077"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679074078"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">[DerivClause]
</span><a href="#local-6989586621679074079"><span class="hs-identifier hs-var">deriv</span></a></span><span>
</span><span id="line-627"></span><span>
</span><span id="line-628"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">DataFamilyD</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679074084"><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074084"><span class="hs-identifier hs-var">dvars</span></a></span></span><span> </span><span id="local-6989586621679074085"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074085"><span class="hs-identifier hs-var">dk</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679074069"><span class="hs-identifier hs-var">famD</span></a></span><span>
</span><span id="line-629"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">DataInstD</span></span><span> </span><span id="local-6989586621679074087"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074087"><span class="hs-identifier hs-var">cx</span></a></span></span><span> </span><span id="local-6989586621679074088"><span class="annot"><span class="annottext">Maybe [TyVarBndrUnit]
</span><a href="#local-6989586621679074088"><span class="hs-identifier hs-var">mbInstVars</span></a></span></span><span> </span><span id="local-6989586621679074089"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074089"><span class="hs-identifier hs-var">nts</span></a></span></span><span> </span><span id="local-6989586621679074090"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074090"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679074091"><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074091"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679074092"><span class="annot"><span class="annottext">[DerivClause]
</span><a href="#local-6989586621679074092"><span class="hs-identifier hs-var">deriv</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679074070"><span class="hs-identifier hs-var">instD</span></a></span><span>
</span><span id="line-630"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074093"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074093"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679074094"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074094"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; NonEmpty Type
</span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074089"><span class="hs-identifier hs-var">nts</span></a></span><span>
</span><span id="line-631"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679074095"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074095"><span class="hs-identifier hs-var">ts'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis] -&gt; Maybe Type -&gt; [Type] -&gt; Q [Type]
</span><a href="Language.Haskell.TH.Datatype.html#repairVarKindsWith"><span class="hs-identifier hs-var">repairVarKindsWith</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074084"><span class="hs-identifier hs-var">dvars</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074085"><span class="hs-identifier hs-var">dk</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074094"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-632"></span><span>           </span><span class="annot"><span class="annottext">Dec -&gt; Q Dec
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Dec -&gt; Q Dec) -&gt; Dec -&gt; Q Dec
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Type]
-&gt; Maybe [TyVarBndrUnit]
-&gt; Type
-&gt; Maybe Type
-&gt; [Con]
-&gt; [DerivClause]
-&gt; Dec
</span><span class="hs-identifier hs-var">DataInstD</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074087"><span class="hs-identifier hs-var">cx</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBndrUnit]
</span><a href="#local-6989586621679074088"><span class="hs-identifier hs-var">mbInstVars</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; Type -&gt; Type) -&gt; Type -&gt; [Type] -&gt; Type
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl'</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074093"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074095"><span class="hs-identifier hs-var">ts'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074090"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074091"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">[DerivClause]
</span><a href="#local-6989586621679074092"><span class="hs-identifier hs-var">deriv</span></a></span><span class="hs-cpp">
# elif MIN_VERSION_template_haskell(2,11,0)
</span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">DataFamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">dk</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">famD</span><span>
</span><span id="line-635"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">k</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">instD</span><span>
</span><span id="line-636"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">ts'</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">repairVarKindsWith</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">dk</span><span> </span><span class="hs-identifier">ts</span><span>
</span><span id="line-637"></span><span>           </span><span class="hs-identifier">return</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts'</span><span> </span><span class="hs-identifier">k</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span>
</span><span id="line-638"></span><span>
</span><span id="line-639"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">DataFamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">dk</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">famD</span><span>
</span><span id="line-640"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">k</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">instD</span><span>
</span><span id="line-641"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">ts'</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">repairVarKindsWith</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">dk</span><span> </span><span class="hs-identifier">ts</span><span>
</span><span id="line-642"></span><span>           </span><span class="hs-identifier">return</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts'</span><span> </span><span class="hs-identifier">k</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span class="hs-cpp">
# else
</span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">dk</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">famD</span><span>
</span><span id="line-645"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">instD</span><span>
</span><span id="line-646"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">ts'</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">repairVarKindsWith</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">dk</span><span> </span><span class="hs-identifier">ts</span><span>
</span><span id="line-647"></span><span>           </span><span class="hs-identifier">return</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts'</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span>
</span><span id="line-648"></span><span>
</span><span id="line-649"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">dk</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">famD</span><span>
</span><span id="line-650"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">instD</span><span>
</span><span id="line-651"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">ts'</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">repairVarKindsWith</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">dk</span><span> </span><span class="hs-identifier">ts</span><span>
</span><span id="line-652"></span><span>           </span><span class="hs-identifier">return</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts'</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span class="hs-cpp">
# endif
</span><span class="hs-cpp">#endif
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#repairDataFam"><span class="hs-identifier hs-var">repairDataFam</span></a></span><span> </span><span class="annot"><span class="annottext">Dec
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679074096"><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679074096"><span class="hs-identifier hs-var">instD</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Dec -&gt; Q Dec
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679074096"><span class="hs-identifier hs-var">instD</span></a></span><span>
</span><span id="line-656"></span><span>
</span><span id="line-657"></span><span class="hs-comment">-- | @'repairVarKindsWith' tvbs mbKind ts@ returns @ts@, but where each element</span><span>
</span><span id="line-658"></span><span class="hs-comment">-- has an explicit kind signature taken from a 'TyVarBndr' in the corresponding</span><span>
</span><span id="line-659"></span><span class="hs-comment">-- position in @tvbs@, or from the corresponding kind argument in 'mbKind' if</span><span>
</span><span id="line-660"></span><span class="hs-comment">-- there aren't enough 'TyVarBndr's available. An example where @tvbs@ can be</span><span>
</span><span id="line-661"></span><span class="hs-comment">-- shorter than @ts@ can be found in this example from #95:</span><span>
</span><span id="line-662"></span><span class="hs-comment">--</span><span>
</span><span id="line-663"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-664"></span><span class="hs-comment">-- data family F :: Type -&gt; Type</span><span>
</span><span id="line-665"></span><span class="hs-comment">-- data instance F a = C</span><span>
</span><span id="line-666"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-667"></span><span class="hs-comment">--</span><span>
</span><span id="line-668"></span><span class="hs-comment">-- The @F@ has no type variable binders in its @data family@ declaration, and</span><span>
</span><span id="line-669"></span><span class="hs-comment">-- it has a return kind of @Type -&gt; Type@. As a result, we pair up @Type@ with</span><span>
</span><span id="line-670"></span><span class="hs-comment">-- @VarT a@ to get @SigT a (ConT ''Type)@.</span><span>
</span><span id="line-671"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#repairVarKindsWith"><span class="hs-identifier hs-type">repairVarKindsWith</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrVis</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>
</span><span id="line-672"></span><span id="repairVarKindsWith"><span class="annot"><span class="annottext">repairVarKindsWith :: [TyVarBndr BndrVis] -&gt; Maybe Type -&gt; [Type] -&gt; Q [Type]
</span><a href="Language.Haskell.TH.Datatype.html#repairVarKindsWith"><span class="hs-identifier hs-var hs-var">repairVarKindsWith</span></a></span></span><span> </span><span id="local-6989586621679074097"><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074097"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679074098"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074098"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679074099"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074099"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-673"></span><span>  </span><span id="local-6989586621679074100"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074100"><span class="hs-identifier hs-var">extra_tvbs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q [TyVarBndrUnit]
</span><a href="Language.Haskell.TH.Datatype.html#mkExtraKindBinders"><span class="hs-identifier hs-var">mkExtraKindBinders</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q [TyVarBndrUnit]) -&gt; Type -&gt; Q [TyVarBndrUnit]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe Type -&gt; Type
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">starK</span></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074098"><span class="hs-identifier hs-var">mbKind</span></a></span><span>
</span><span id="line-674"></span><span>  </span><span class="hs-comment">-- This list should be the same length as @ts@. If it isn't, something has</span><span>
</span><span id="line-675"></span><span>  </span><span class="hs-comment">-- gone terribly wrong.</span><span>
</span><span id="line-676"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074103"><span class="annot"><span class="annottext">tvbs' :: [TyVarBndrUnit]
</span><a href="#local-6989586621679074103"><span class="hs-identifier hs-var hs-var">tvbs'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; [TyVarBndr BndrVis] -&gt; [TyVarBndrUnit]
forall newFlag oldFlag.
newFlag -&gt; [TyVarBndr_ oldFlag] -&gt; [TyVarBndr_ newFlag]
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#changeTVFlags"><span class="hs-identifier hs-var">changeTVFlags</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074097"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; [TyVarBndrUnit] -&gt; [TyVarBndrUnit]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074100"><span class="hs-identifier hs-var">extra_tvbs</span></a></span><span>
</span><span id="line-677"></span><span>  </span><span class="annot"><span class="annottext">[Type] -&gt; Q [Type]
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">([Type] -&gt; Q [Type]) -&gt; [Type] -&gt; Q [Type]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(TyVarBndrUnit -&gt; Type -&gt; Type)
-&gt; [TyVarBndrUnit] -&gt; [Type] -&gt; [Type]
forall a b c. (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
</span><span class="hs-identifier hs-var">zipWith</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit -&gt; Type -&gt; Type
forall flag. TyVarBndr_ flag -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#stealKindForType"><span class="hs-identifier hs-var">stealKindForType</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074103"><span class="hs-identifier hs-var">tvbs'</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074099"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-678"></span><span>
</span><span id="line-679"></span><span class="hs-comment">-- If a VarT is missing an explicit kind signature, steal it from a TyVarBndr.</span><span>
</span><span id="line-680"></span><span id="local-6989586621679072473"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#stealKindForType"><span class="hs-identifier hs-type">stealKindForType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072473"><span class="hs-identifier hs-type">flag</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span></span><span>
</span><span id="line-681"></span><span id="stealKindForType"><span class="annot"><span class="annottext">stealKindForType :: forall flag. TyVarBndr_ flag -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#stealKindForType"><span class="hs-identifier hs-var hs-var">stealKindForType</span></a></span></span><span> </span><span id="local-6989586621679074107"><span class="annot"><span class="annottext">TyVarBndr_ flag
</span><a href="#local-6989586621679074107"><span class="hs-identifier hs-var">tvb</span></a></span></span><span> </span><span id="local-6989586621679074108"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679074108"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">SigT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074108"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyVarBndr_ flag -&gt; Type
forall flag. TyVarBndr_ flag -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvKind"><span class="hs-identifier hs-var">tvKind</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndr_ flag
</span><a href="#local-6989586621679074107"><span class="hs-identifier hs-var">tvb</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-682"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#stealKindForType"><span class="hs-identifier hs-var">stealKindForType</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndr_ flag
</span><span class="hs-identifier">_</span></span><span>   </span><span id="local-6989586621679074109"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074109"><span class="hs-identifier hs-var">t</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074109"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-683"></span><span>
</span><span id="line-684"></span><span class="hs-comment">-- | Normalize 'Dec' for a newtype or datatype into a 'DatatypeInfo'.</span><span>
</span><span id="line-685"></span><span class="hs-comment">-- Fail in 'Q' otherwise.</span><span>
</span><span id="line-686"></span><span class="hs-comment">--</span><span>
</span><span id="line-687"></span><span class="hs-comment">-- Beware: 'normalizeDec' can have surprising behavior when it comes to fixity.</span><span>
</span><span id="line-688"></span><span class="hs-comment">-- For instance, if you have this quasiquoted data declaration:</span><span>
</span><span id="line-689"></span><span class="hs-comment">--</span><span>
</span><span id="line-690"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-691"></span><span class="hs-comment">-- [d| infix 5 :^^:</span><span>
</span><span id="line-692"></span><span class="hs-comment">--     data Foo where</span><span>
</span><span id="line-693"></span><span class="hs-comment">--       (:^^:) :: Int -&gt; Int -&gt; Foo |]</span><span>
</span><span id="line-694"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-695"></span><span class="hs-comment">--</span><span>
</span><span id="line-696"></span><span class="hs-comment">-- Then if you pass the 'Dec' for @Foo@ to 'normalizeDec' without splicing it</span><span>
</span><span id="line-697"></span><span class="hs-comment">-- in a previous Template Haskell splice, then @(:^^:)@ will be labeled a 'NormalConstructor'</span><span>
</span><span id="line-698"></span><span class="hs-comment">-- instead of an 'InfixConstructor'. This is because Template Haskell has no way to</span><span>
</span><span id="line-699"></span><span class="hs-comment">-- reify the fixity declaration for @(:^^:)@, so it must assume there isn't one. To</span><span>
</span><span id="line-700"></span><span class="hs-comment">-- work around this behavior, use 'reifyDatatype' instead.</span><span>
</span><span id="line-701"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeDec"><span class="hs-identifier hs-type">normalizeDec</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Dec</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-702"></span><span id="normalizeDec"><span class="annot"><span class="annottext">normalizeDec :: Dec -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDec"><span class="hs-identifier hs-var hs-var">normalizeDec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Dec -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-var">normalizeDecFor</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="Language.Haskell.TH.Datatype.html#isn%27tReified"><span class="hs-identifier hs-var">isn'tReified</span></a></span><span>
</span><span id="line-703"></span><span>
</span><span id="line-704"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-type">normalizeDecFor</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Dec</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-705"></span><span id="normalizeDecFor"><span class="annot"><span class="annottext">normalizeDecFor :: Bool -&gt; Dec -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-var hs-var">normalizeDecFor</span></a></span></span><span> </span><span id="local-6989586621679074110"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074110"><span class="hs-identifier hs-var">isReified</span></a></span></span><span> </span><span id="local-6989586621679074111"><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679074111"><span class="hs-identifier hs-var">dec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-706"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679074111"><span class="hs-identifier hs-var">dec</span></a></span><span> </span><span class="hs-keyword">of</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,20,0)
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">TypeDataD</span></span><span> </span><span id="local-6989586621679074113"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074113"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679074114"><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074114"><span class="hs-identifier hs-var">tyvars</span></a></span></span><span> </span><span id="local-6989586621679074115"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074115"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679074116"><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074116"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-709"></span><span>      </span><span class="annot"><span class="annottext">[Type]
-&gt; Name
-&gt; [TyVarBndr BndrVis]
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074117"><span class="hs-identifier hs-var">normalizeDataD</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074113"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074114"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074115"><span class="hs-identifier hs-var">mbKind</span></a></span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074116"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#TypeData"><span class="hs-identifier hs-var">TypeData</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,12,0)
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">NewtypeD</span></span><span> </span><span id="local-6989586621679074119"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074119"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679074120"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074120"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679074121"><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074121"><span class="hs-identifier hs-var">tyvars</span></a></span></span><span> </span><span id="local-6989586621679074122"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074122"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679074123"><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679074123"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span id="local-6989586621679074124"><span class="annot"><span class="annottext">[DerivClause]
</span><a href="#local-6989586621679074124"><span class="hs-identifier hs-var">_derives</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-713"></span><span>      </span><span class="annot"><span class="annottext">[Type]
-&gt; Name
-&gt; [TyVarBndr BndrVis]
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074117"><span class="hs-identifier hs-var">normalizeDataD</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074119"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074120"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074121"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074122"><span class="hs-identifier hs-var">mbKind</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679074123"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#Newtype"><span class="hs-identifier hs-var">Newtype</span></a></span><span>
</span><span id="line-714"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">DataD</span></span><span> </span><span id="local-6989586621679074125"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074125"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679074126"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074126"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679074127"><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074127"><span class="hs-identifier hs-var">tyvars</span></a></span></span><span> </span><span id="local-6989586621679074128"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074128"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679074129"><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074129"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621679074130"><span class="annot"><span class="annottext">[DerivClause]
</span><a href="#local-6989586621679074130"><span class="hs-identifier hs-var">_derives</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-715"></span><span>      </span><span class="annot"><span class="annottext">[Type]
-&gt; Name
-&gt; [TyVarBndr BndrVis]
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074117"><span class="hs-identifier hs-var">normalizeDataD</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074125"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074126"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074127"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074128"><span class="hs-identifier hs-var">mbKind</span></a></span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074129"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#Datatype"><span class="hs-identifier hs-var">Datatype</span></a></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,15,0)
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">NewtypeInstD</span></span><span> </span><span id="local-6989586621679074131"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074131"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679074132"><span class="annot"><span class="annottext">Maybe [TyVarBndrUnit]
</span><a href="#local-6989586621679074132"><span class="hs-identifier hs-var">mbTyvars</span></a></span></span><span> </span><span id="local-6989586621679074133"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074133"><span class="hs-identifier hs-var">nameInstTys</span></a></span></span><span> </span><span id="local-6989586621679074134"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074134"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679074135"><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679074135"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span id="local-6989586621679074136"><span class="annot"><span class="annottext">[DerivClause]
</span><a href="#local-6989586621679074136"><span class="hs-identifier hs-var">_derives</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-718"></span><span>      </span><span class="annot"><span class="annottext">String
-&gt; [Type]
-&gt; Maybe [TyVarBndrUnit]
-&gt; Type
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074137"><span class="hs-identifier hs-var">normalizeDataInstDPostTH2'15</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;newtype&quot;</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074131"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBndrUnit]
</span><a href="#local-6989586621679074132"><span class="hs-identifier hs-var">mbTyvars</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074133"><span class="hs-identifier hs-var">nameInstTys</span></a></span><span>
</span><span id="line-719"></span><span>                                   </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074134"><span class="hs-identifier hs-var">mbKind</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679074135"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#NewtypeInstance"><span class="hs-identifier hs-var">NewtypeInstance</span></a></span><span>
</span><span id="line-720"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">DataInstD</span></span><span> </span><span id="local-6989586621679074138"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074138"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679074139"><span class="annot"><span class="annottext">Maybe [TyVarBndrUnit]
</span><a href="#local-6989586621679074139"><span class="hs-identifier hs-var">mbTyvars</span></a></span></span><span> </span><span id="local-6989586621679074140"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074140"><span class="hs-identifier hs-var">nameInstTys</span></a></span></span><span> </span><span id="local-6989586621679074141"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074141"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679074142"><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074142"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621679074143"><span class="annot"><span class="annottext">[DerivClause]
</span><a href="#local-6989586621679074143"><span class="hs-identifier hs-var">_derives</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-721"></span><span>      </span><span class="annot"><span class="annottext">String
-&gt; [Type]
-&gt; Maybe [TyVarBndrUnit]
-&gt; Type
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074137"><span class="hs-identifier hs-var">normalizeDataInstDPostTH2'15</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;data&quot;</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074138"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBndrUnit]
</span><a href="#local-6989586621679074139"><span class="hs-identifier hs-var">mbTyvars</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074140"><span class="hs-identifier hs-var">nameInstTys</span></a></span><span>
</span><span id="line-722"></span><span>                                   </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074141"><span class="hs-identifier hs-var">mbKind</span></a></span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074142"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#DataInstance"><span class="hs-identifier hs-var">DataInstance</span></a></span><span class="hs-cpp">
# else
</span><span>    </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-725"></span><span>      </span><span class="hs-identifier">normalizeDataInstDPreTH2'15</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">con</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">NewtypeInstance</span><span>
</span><span id="line-726"></span><span>    </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-727"></span><span>      </span><span class="hs-identifier">normalizeDataInstDPreTH2'15</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">DataInstance</span><span class="hs-cpp">
# endif
</span><span class="hs-cpp">#elif MIN_VERSION_template_haskell(2,11,0)
</span><span>    </span><span class="hs-identifier">NewtypeD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-731"></span><span>      </span><span class="hs-identifier">normalizeDataD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">con</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">Newtype</span><span>
</span><span id="line-732"></span><span>    </span><span class="hs-identifier">DataD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-733"></span><span>      </span><span class="hs-identifier">normalizeDataD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">Datatype</span><span>
</span><span id="line-734"></span><span>    </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-735"></span><span>      </span><span class="hs-identifier">normalizeDataInstDPreTH2'15</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">con</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">NewtypeInstance</span><span>
</span><span id="line-736"></span><span>    </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-737"></span><span>      </span><span class="hs-identifier">normalizeDataInstDPreTH2'15</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">DataInstance</span><span class="hs-cpp">
#else
</span><span>    </span><span class="hs-identifier">NewtypeD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-740"></span><span>      </span><span class="hs-identifier">normalizeDataD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">con</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">Newtype</span><span>
</span><span id="line-741"></span><span>    </span><span class="hs-identifier">DataD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-742"></span><span>      </span><span class="hs-identifier">normalizeDataD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">Datatype</span><span>
</span><span id="line-743"></span><span>    </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-744"></span><span>      </span><span class="hs-identifier">normalizeDataInstDPreTH2'15</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">con</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">NewtypeInstance</span><span>
</span><span id="line-745"></span><span>    </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-746"></span><span>      </span><span class="hs-identifier">normalizeDataInstDPreTH2'15</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">DataInstance</span><span class="hs-cpp">
#endif
</span><span>    </span><span class="annot"><span class="annottext">Dec
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall a. String -&gt; Q a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;normalizeDecFor: DataD or NewtypeD required&quot;</span></span><span>
</span><span id="line-749"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-750"></span><span>    </span><span class="hs-comment">-- We only need to repair reified declarations for data family instances.</span><span>
</span><span id="line-751"></span><span>    </span><span class="annot"><a href="#local-6989586621679074144"><span class="hs-identifier hs-type">repair13618'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-752"></span><span>    </span><span id="local-6989586621679074144"><span class="annot"><span class="annottext">repair13618' :: DatatypeInfo -&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074144"><span class="hs-identifier hs-var hs-var">repair13618'</span></a></span></span><span> </span><span id="local-6989586621679074145"><span class="annot"><span class="annottext">di :: DatatypeInfo
</span><a href="#local-6989586621679074145"><span class="hs-identifier hs-var">di</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">datatypeVariant :: DatatypeInfo -&gt; DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#datatypeVariant"><span class="hs-identifier hs-var">datatypeVariant</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621679074146"><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074146"><span class="hs-identifier hs-var">variant</span></a></span></span><span class="hs-special">}</span><span>
</span><span id="line-753"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074110"><span class="hs-identifier hs-var">isReified</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant -&gt; Bool
</span><a href="Language.Haskell.TH.Datatype.html#isFamInstVariant"><span class="hs-identifier hs-var">isFamInstVariant</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074146"><span class="hs-identifier hs-var">variant</span></a></span><span>
</span><span id="line-754"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#repair13618"><span class="hs-identifier hs-var">repair13618</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679074145"><span class="hs-identifier hs-var">di</span></a></span><span>
</span><span id="line-755"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-756"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Q DatatypeInfo
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679074145"><span class="hs-identifier hs-var">di</span></a></span><span>
</span><span id="line-757"></span><span>
</span><span id="line-758"></span><span>    </span><span class="hs-comment">-- If a data type lacks an explicit return kind, use `reifyType` to compute</span><span>
</span><span id="line-759"></span><span>    </span><span class="hs-comment">-- it, as described in step (1) of Note [Tricky result kinds].</span><span>
</span><span id="line-760"></span><span>    </span><span class="annot"><a href="#local-6989586621679074150"><span class="hs-identifier hs-type">normalizeMbKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-special">)</span><span>
</span><span id="line-761"></span><span>    </span><span id="local-6989586621679074150"><span class="annot"><span class="annottext">normalizeMbKind :: Name -&gt; [Type] -&gt; Maybe Type -&gt; Q (Maybe Type)
</span><a href="#local-6989586621679074150"><span class="hs-identifier hs-var hs-var">normalizeMbKind</span></a></span></span><span> </span><span id="local-6989586621679074151"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074151"><span class="hs-identifier hs-var">_name</span></a></span></span><span> </span><span id="local-6989586621679074152"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074152"><span class="hs-identifier hs-var">_instTys</span></a></span></span><span> </span><span id="local-6989586621679074153"><span class="annot"><span class="annottext">mbKind :: Maybe Type
</span><a href="#local-6989586621679074153"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Type -&gt; Q (Maybe Type)
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074153"><span class="hs-identifier hs-var">mbKind</span></a></span><span>
</span><span id="line-762"></span><span>    </span><span class="annot"><a href="#local-6989586621679074150"><span class="hs-identifier hs-var">normalizeMbKind</span></a></span><span> </span><span id="local-6989586621679074154"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074154"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679074155"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074155"><span class="hs-identifier hs-var">instTys</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,16,0)
</span><span>      </span><span id="local-6989586621679074156"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074156"><span class="hs-identifier hs-var">mbReifiedKind</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Maybe Type -&gt; Q (Maybe Type)
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Maybe Type
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">Q (Maybe Type) -&gt; Q (Maybe Type) -&gt; Q (Maybe Type)
forall a. Q a -&gt; Q a -&gt; Q a
</span><span class="hs-operator hs-var">`recover`</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Maybe Type) -&gt; Q Type -&gt; Q (Maybe Type)
forall a b. (a -&gt; b) -&gt; Q a -&gt; Q b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe Type
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Q Type
</span><span class="hs-identifier hs-var">reifyType</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074154"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-765"></span><span>      </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; Maybe Type -&gt; Q (Maybe Type)
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Maybe a -&gt; m (Maybe b)
</span><span class="hs-identifier hs-var">T.mapM</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="#local-6989586621679074159"><span class="hs-identifier hs-var">normalizeKind</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074156"><span class="hs-identifier hs-var">mbReifiedKind</span></a></span><span>
</span><span id="line-766"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-767"></span><span>        </span><span class="annot"><a href="#local-6989586621679074159"><span class="hs-identifier hs-type">normalizeKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-768"></span><span>        </span><span id="local-6989586621679074159"><span class="annot"><span class="annottext">normalizeKind :: Type -&gt; Q Type
</span><a href="#local-6989586621679074159"><span class="hs-identifier hs-var hs-var">normalizeKind</span></a></span></span><span> </span><span id="local-6989586621679074160"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074160"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-769"></span><span>          </span><span id="local-6989586621679074161"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074161"><span class="hs-identifier hs-var">k'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-var">resolveKindSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074160"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-770"></span><span>          </span><span class="hs-comment">-- Step (1) in Note [Tricky result kinds]</span><span>
</span><span id="line-771"></span><span>          </span><span class="hs-comment">-- (Wrinkle: normalizeMbKind argument unification).</span><span>
</span><span id="line-772"></span><span>          </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074162"><span class="annot"><span class="annottext">[(Type, VisFunArg)]
</span><a href="#local-6989586621679074162"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074163"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074163"><span class="hs-identifier hs-var">res</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; ([(Type, VisFunArg)], Type)
forall a. [a] -&gt; Type -&gt; ([(a, VisFunArg)], Type)
</span><a href="Language.Haskell.TH.Datatype.html#unravelKindUpTo"><span class="hs-identifier hs-var">unravelKindUpTo</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074155"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074161"><span class="hs-identifier hs-var">k'</span></a></span><span>
</span><span id="line-773"></span><span>              </span><span class="hs-comment">-- Step (2) in Note [Tricky result kinds]</span><span>
</span><span id="line-774"></span><span>              </span><span class="hs-comment">-- (Wrinkle: normalizeMbKind argument unification).</span><span>
</span><span id="line-775"></span><span>              </span><span class="hs-special">(</span><span id="local-6989586621679074167"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074167"><span class="hs-identifier hs-var">instTys'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074168"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074168"><span class="hs-identifier hs-var">args'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-776"></span><span>                </span><span class="annot"><span class="annottext">[(Type, Type)] -&gt; ([Type], [Type])
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="annot"><span class="annottext">([(Type, Type)] -&gt; ([Type], [Type]))
-&gt; [(Type, Type)] -&gt; ([Type], [Type])
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-777"></span><span>                </span><span class="annot"><span class="annottext">((Type, VisFunArg) -&gt; Maybe (Type, Type))
-&gt; [(Type, VisFunArg)] -&gt; [(Type, Type)]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span>
</span><span id="line-778"></span><span>                  </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679074171"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074171"><span class="hs-identifier hs-var">instTy</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074172"><span class="annot"><span class="annottext">VisFunArg
</span><a href="#local-6989586621679074172"><span class="hs-identifier hs-var">arg</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-779"></span><span>                    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">VisFunArg
</span><a href="#local-6989586621679074172"><span class="hs-identifier hs-var">arg</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-780"></span><span>                      </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#VisFADep"><span class="hs-identifier hs-type">VisFADep</span></a></span><span> </span><span id="local-6989586621679074174"><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679074174"><span class="hs-identifier hs-var">tvb</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; Maybe (Type, Type)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074171"><span class="hs-identifier hs-var">instTy</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit -&gt; Type
forall flag. TyVarBndr_ flag -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#bndrParam"><span class="hs-identifier hs-var">bndrParam</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679074174"><span class="hs-identifier hs-var">tvb</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-781"></span><span>                      </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#VisFAAnon"><span class="hs-identifier hs-type">VisFAAnon</span></a></span><span> </span><span id="local-6989586621679074177"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074177"><span class="hs-identifier hs-var">k</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074177"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; (Type, Type)) -&gt; Maybe Type -&gt; Maybe (Type, Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe Type
</span><a href="Language.Haskell.TH.Datatype.html#sigTMaybeKind"><span class="hs-identifier hs-var">sigTMaybeKind</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074171"><span class="hs-identifier hs-var">instTy</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-782"></span><span>                  </span><span class="annot"><span class="annottext">[(Type, VisFunArg)]
</span><a href="#local-6989586621679074162"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-783"></span><span>              </span><span class="hs-special">(</span><span id="local-6989586621679074180"><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074180"><span class="hs-identifier hs-var">subst</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; (Map Name Name, [Type])
</span><a href="Language.Haskell.TH.Datatype.html#mergeArguments"><span class="hs-identifier hs-var">mergeArguments</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074168"><span class="hs-identifier hs-var">args'</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074167"><span class="hs-identifier hs-var">instTys'</span></a></span><span>
</span><span id="line-784"></span><span>          </span><span class="hs-comment">-- Step (3) in Note [Tricky result kinds]</span><span>
</span><span id="line-785"></span><span>          </span><span class="hs-comment">-- (Wrinkle: normalizeMbKind argument unification).</span><span>
</span><span id="line-786"></span><span>          </span><span class="annot"><span class="annottext">Type -&gt; Q Type
forall a. a -&gt; Q a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; Type -&gt; Q Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Type) -&gt; Map Name Name -&gt; Map Name Type
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074180"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074163"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-cpp">
#else
</span><span>      </span><span class="hs-identifier">return</span><span> </span><span class="hs-identifier">Nothing</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-791"></span><span>    </span><span class="hs-comment">-- Given a data type declaration's binders, as well as the arguments and</span><span>
</span><span id="line-792"></span><span>    </span><span class="hs-comment">-- result of its explicit return kind, compute the free type variables.</span><span>
</span><span id="line-793"></span><span>    </span><span class="hs-comment">-- For example, this:</span><span>
</span><span id="line-794"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-795"></span><span>    </span><span class="hs-comment">-- @</span><span>
</span><span id="line-796"></span><span>    </span><span class="hs-comment">-- data T (a :: j) :: forall k. Maybe k -&gt; Type</span><span>
</span><span id="line-797"></span><span>    </span><span class="hs-comment">-- @</span><span>
</span><span id="line-798"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-799"></span><span>    </span><span class="hs-comment">-- Would yield:</span><span>
</span><span id="line-800"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-801"></span><span>    </span><span class="hs-comment">-- @</span><span>
</span><span id="line-802"></span><span>    </span><span class="hs-comment">-- [j, (a :: j), k, (b :: k)]</span><span>
</span><span id="line-803"></span><span>    </span><span class="hs-comment">-- @</span><span>
</span><span id="line-804"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-805"></span><span>    </span><span class="hs-comment">-- Where @b@ is a fresh name that is generated in 'mkExtraFunArgForalls'.</span><span>
</span><span id="line-806"></span><span>    </span><span id="local-6989586621679072491"><span class="annot"><a href="#local-6989586621679074183"><span class="hs-identifier hs-type">datatypeFreeVars</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072491"><span class="hs-identifier hs-type">flag</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span></span><span>
</span><span id="line-807"></span><span>    </span><span id="local-6989586621679074183"><span class="annot"><span class="annottext">datatypeFreeVars :: forall flag.
[TyVarBndr_ flag] -&gt; FunArgs -&gt; Type -&gt; [TyVarBndrUnit]
</span><a href="#local-6989586621679074183"><span class="hs-identifier hs-var hs-var">datatypeFreeVars</span></a></span></span><span> </span><span id="local-6989586621679074184"><span class="annot"><span class="annottext">[TyVarBndr_ flag]
</span><a href="#local-6989586621679074184"><span class="hs-identifier hs-var">declBndrs</span></a></span></span><span> </span><span id="local-6989586621679074185"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074185"><span class="hs-identifier hs-var">kindArgs</span></a></span></span><span> </span><span id="local-6989586621679074186"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074186"><span class="hs-identifier hs-var">kindRes</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-808"></span><span>      </span><span class="annot"><span class="annottext">[Type] -&gt; [TyVarBndrUnit]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier hs-var">freeVariablesWellScoped</span></a></span><span> </span><span class="annot"><span class="annottext">([Type] -&gt; [TyVarBndrUnit]) -&gt; [Type] -&gt; [TyVarBndrUnit]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr_ flag] -&gt; [Type]
forall flag. [TyVarBndr_ flag] -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#bndrParams"><span class="hs-identifier hs-var">bndrParams</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr_ flag]
</span><a href="#local-6989586621679074184"><span class="hs-identifier hs-var">declBndrs</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; [Type]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span>        </span><span class="annot"><span class="annottext">FunArgs -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#funArgTys"><span class="hs-identifier hs-var">funArgTys</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074185"><span class="hs-identifier hs-var">kindArgs</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; [Type]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074186"><span class="hs-identifier hs-var">kindRes</span></a></span><span class="hs-special">]</span><span class="hs-cpp">
#else
</span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- No kind variables</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-815"></span><span>    </span><span class="annot"><a href="#local-6989586621679074117"><span class="hs-identifier hs-type">normalizeDataD</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrVis</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-816"></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-817"></span><span>    </span><span id="local-6989586621679074117"><span class="annot"><span class="annottext">normalizeDataD :: [Type]
-&gt; Name
-&gt; [TyVarBndr BndrVis]
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074117"><span class="hs-identifier hs-var hs-var">normalizeDataD</span></a></span></span><span> </span><span id="local-6989586621679074189"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074189"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679074190"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074190"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679074191"><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074191"><span class="hs-identifier hs-var">tyvars</span></a></span></span><span> </span><span id="local-6989586621679074192"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074192"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679074193"><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074193"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621679074194"><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074194"><span class="hs-identifier hs-var">variant</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-818"></span><span>      </span><span class="hs-comment">-- NB: use `filter isRequiredTvb tyvars` here. It is possible for some of</span><span>
</span><span id="line-819"></span><span>      </span><span class="hs-comment">-- the `tyvars` to be `BndrInvis` if the data type is quoted, e.g.,</span><span>
</span><span id="line-820"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-821"></span><span>      </span><span class="hs-comment">--   data D @k (a :: k)</span><span>
</span><span id="line-822"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-823"></span><span>      </span><span class="hs-comment">-- th-abstraction adopts the convention that all binders in the</span><span>
</span><span id="line-824"></span><span>      </span><span class="hs-comment">-- 'datatypeInstTypes' are required, so we want to filter out the `@k`.</span><span>
</span><span id="line-825"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074195"><span class="annot"><span class="annottext">tys :: [Type]
</span><a href="#local-6989586621679074195"><span class="hs-identifier hs-var hs-var">tys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis] -&gt; [Type]
forall flag. [TyVarBndr_ flag] -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#bndrParams"><span class="hs-identifier hs-var">bndrParams</span></a></span><span> </span><span class="annot"><span class="annottext">([TyVarBndr BndrVis] -&gt; [Type]) -&gt; [TyVarBndr BndrVis] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(TyVarBndr BndrVis -&gt; Bool)
-&gt; [TyVarBndr BndrVis] -&gt; [TyVarBndr BndrVis]
forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">filter</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr BndrVis -&gt; Bool
</span><a href="Language.Haskell.TH.Datatype.html#isRequiredTvb"><span class="hs-identifier hs-var">isRequiredTvb</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074191"><span class="hs-identifier hs-var">tyvars</span></a></span><span>
</span><span id="line-826"></span><span>      </span><span id="local-6989586621679074197"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074197"><span class="hs-identifier hs-var">mbKind'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Type] -&gt; Maybe Type -&gt; Q (Maybe Type)
</span><a href="#local-6989586621679074150"><span class="hs-identifier hs-var">normalizeMbKind</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074190"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074195"><span class="hs-identifier hs-var">tys</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074192"><span class="hs-identifier hs-var">mbKind</span></a></span><span>
</span><span id="line-827"></span><span>      </span><span class="annot"><span class="annottext">[Type]
-&gt; Name
-&gt; [TyVarBndr BndrVis]
-&gt; [Type]
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
forall flag.
[Type]
-&gt; Name
-&gt; [TyVarBndr_ flag]
-&gt; [Type]
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074198"><span class="hs-identifier hs-var">normalize'</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074189"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074190"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074191"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074195"><span class="hs-identifier hs-var">tys</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074197"><span class="hs-identifier hs-var">mbKind'</span></a></span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074193"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074194"><span class="hs-identifier hs-var">variant</span></a></span><span>
</span><span id="line-828"></span><span>
</span><span id="line-829"></span><span>    </span><span class="annot"><a href="#local-6989586621679074137"><span class="hs-identifier hs-type">normalizeDataInstDPostTH2'15</span></a></span><span>
</span><span id="line-830"></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-831"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-832"></span><span>    </span><span id="local-6989586621679074137"><span class="annot"><span class="annottext">normalizeDataInstDPostTH2'15 :: String
-&gt; [Type]
-&gt; Maybe [TyVarBndrUnit]
-&gt; Type
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074137"><span class="hs-identifier hs-var hs-var">normalizeDataInstDPostTH2'15</span></a></span></span><span> </span><span id="local-6989586621679074199"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679074199"><span class="hs-identifier hs-var">what</span></a></span></span><span> </span><span id="local-6989586621679074200"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074200"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679074201"><span class="annot"><span class="annottext">Maybe [TyVarBndrUnit]
</span><a href="#local-6989586621679074201"><span class="hs-identifier hs-var">mbTyvars</span></a></span></span><span> </span><span id="local-6989586621679074202"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074202"><span class="hs-identifier hs-var">nameInstTys</span></a></span></span><span>
</span><span id="line-833"></span><span>                                 </span><span id="local-6989586621679074203"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074203"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679074204"><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074204"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621679074205"><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074205"><span class="hs-identifier hs-var">variant</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-834"></span><span>      </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type -&gt; NonEmpty Type
</span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074202"><span class="hs-identifier hs-var">nameInstTys</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-835"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">ConT</span></span><span> </span><span id="local-6989586621679074206"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074206"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679074207"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074207"><span class="hs-identifier hs-var">instTys</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-836"></span><span>          </span><span id="local-6989586621679074208"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074208"><span class="hs-identifier hs-var">mbKind'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Type] -&gt; Maybe Type -&gt; Q (Maybe Type)
</span><a href="#local-6989586621679074150"><span class="hs-identifier hs-var">normalizeMbKind</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074206"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074207"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074203"><span class="hs-identifier hs-var">mbKind</span></a></span><span>
</span><span id="line-837"></span><span>          </span><span class="annot"><span class="annottext">[Type]
-&gt; Name
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
forall flag.
[Type]
-&gt; Name
-&gt; [TyVarBndr_ flag]
-&gt; [Type]
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074198"><span class="hs-identifier hs-var">normalize'</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074200"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074206"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-838"></span><span>                     </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; Maybe [TyVarBndrUnit] -&gt; [TyVarBndrUnit]
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; [TyVarBndrUnit]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier hs-var">freeVariablesWellScoped</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074207"><span class="hs-identifier hs-var">instTys</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBndrUnit]
</span><a href="#local-6989586621679074201"><span class="hs-identifier hs-var">mbTyvars</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-839"></span><span>                     </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074207"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074208"><span class="hs-identifier hs-var">mbKind'</span></a></span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074204"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074205"><span class="hs-identifier hs-var">variant</span></a></span><span>
</span><span id="line-840"></span><span>        </span><span class="annot"><span class="annottext">NonEmpty Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall a. String -&gt; Q a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Q DatatypeInfo) -&gt; String -&gt; Q DatatypeInfo
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Unexpected &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679074199"><span class="hs-identifier hs-var">what</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot; instance head: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; String
forall a. Ppr a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">pprint</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074202"><span class="hs-identifier hs-var">nameInstTys</span></a></span><span>
</span><span id="line-841"></span><span>
</span><span id="line-842"></span><span>    </span><span class="annot"><a href="#local-6989586621679074210"><span class="hs-identifier hs-type">normalizeDataInstDPreTH2'15</span></a></span><span>
</span><span id="line-843"></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-844"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-845"></span><span>    </span><span id="local-6989586621679074210"><span class="annot"><span class="annottext">normalizeDataInstDPreTH2'15 :: [Type]
-&gt; Name
-&gt; [Type]
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074210"><span class="hs-identifier hs-var hs-var">normalizeDataInstDPreTH2'15</span></a></span></span><span> </span><span id="local-6989586621679074211"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074211"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679074212"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074212"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679074213"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074213"><span class="hs-identifier hs-var">instTys</span></a></span></span><span> </span><span id="local-6989586621679074214"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074214"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679074215"><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074215"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621679074216"><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074216"><span class="hs-identifier hs-var">variant</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-846"></span><span>      </span><span id="local-6989586621679074217"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074217"><span class="hs-identifier hs-var">mbKind'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Type] -&gt; Maybe Type -&gt; Q (Maybe Type)
</span><a href="#local-6989586621679074150"><span class="hs-identifier hs-var">normalizeMbKind</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074212"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074213"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074214"><span class="hs-identifier hs-var">mbKind</span></a></span><span>
</span><span id="line-847"></span><span>      </span><span class="annot"><span class="annottext">[Type]
-&gt; Name
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
forall flag.
[Type]
-&gt; Name
-&gt; [TyVarBndr_ flag]
-&gt; [Type]
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074198"><span class="hs-identifier hs-var">normalize'</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074211"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074212"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; [TyVarBndrUnit]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier hs-var">freeVariablesWellScoped</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074213"><span class="hs-identifier hs-var">instTys</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-848"></span><span>                 </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074213"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074217"><span class="hs-identifier hs-var">mbKind'</span></a></span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074215"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074216"><span class="hs-identifier hs-var">variant</span></a></span><span>
</span><span id="line-849"></span><span>
</span><span id="line-850"></span><span>    </span><span class="hs-comment">-- The main worker of this function.</span><span>
</span><span id="line-851"></span><span>    </span><span id="local-6989586621679072496"><span class="annot"><a href="#local-6989586621679074198"><span class="hs-identifier hs-type">normalize'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072496"><span class="hs-identifier hs-type">flag</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-852"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span></span><span>
</span><span id="line-853"></span><span>    </span><span id="local-6989586621679074198"><span class="annot"><span class="annottext">normalize' :: forall flag.
[Type]
-&gt; Name
-&gt; [TyVarBndr_ flag]
-&gt; [Type]
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074198"><span class="hs-identifier hs-var hs-var">normalize'</span></a></span></span><span> </span><span id="local-6989586621679074221"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074221"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679074222"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074222"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679074223"><span class="annot"><span class="annottext">[TyVarBndr_ flag]
</span><a href="#local-6989586621679074223"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679074224"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074224"><span class="hs-identifier hs-var">instTys</span></a></span></span><span> </span><span id="local-6989586621679074225"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074225"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679074226"><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074226"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621679074227"><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074227"><span class="hs-identifier hs-var">variant</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-854"></span><span>      </span><span class="hs-comment">-- If `mbKind` is *still* Nothing after all of the work done in</span><span>
</span><span id="line-855"></span><span>      </span><span class="hs-comment">-- normalizeMbKind, then conservatively assume that the return kind is</span><span>
</span><span id="line-856"></span><span>      </span><span class="hs-comment">-- `Type`. See step (1) of Note [Tricky result kinds].</span><span>
</span><span id="line-857"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074228"><span class="annot"><span class="annottext">kind :: Type
</span><a href="#local-6989586621679074228"><span class="hs-identifier hs-var hs-var">kind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe Type -&gt; Type
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">starK</span></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074225"><span class="hs-identifier hs-var">mbKind</span></a></span><span>
</span><span id="line-858"></span><span>      </span><span id="local-6989586621679074229"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074229"><span class="hs-identifier hs-var">kind'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-var">resolveKindSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074228"><span class="hs-identifier hs-var">kind</span></a></span><span>
</span><span id="line-859"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074230"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074230"><span class="hs-identifier hs-var">kindArgs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074231"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074231"><span class="hs-identifier hs-var">kindRes</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; (FunArgs, Type)
</span><a href="Language.Haskell.TH.Datatype.html#unravelKind"><span class="hs-identifier hs-var">unravelKind</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074229"><span class="hs-identifier hs-var">kind'</span></a></span><span>
</span><span id="line-860"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621679074233"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074233"><span class="hs-identifier hs-var">extra_vis_tvbs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074234"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074234"><span class="hs-identifier hs-var">kindArgs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">FunArgs -&gt; Q ([TyVarBndrUnit], FunArgs)
</span><a href="Language.Haskell.TH.Datatype.html#mkExtraFunArgForalls"><span class="hs-identifier hs-var">mkExtraFunArgForalls</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074230"><span class="hs-identifier hs-var">kindArgs</span></a></span><span>
</span><span id="line-861"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074236"><span class="annot"><span class="annottext">tvbs' :: [TyVarBndrUnit]
</span><a href="#local-6989586621679074236"><span class="hs-identifier hs-var hs-var">tvbs'</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr_ flag] -&gt; FunArgs -&gt; Type -&gt; [TyVarBndrUnit]
forall flag.
[TyVarBndr_ flag] -&gt; FunArgs -&gt; Type -&gt; [TyVarBndrUnit]
</span><a href="#local-6989586621679074183"><span class="hs-identifier hs-var">datatypeFreeVars</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr_ flag]
</span><a href="#local-6989586621679074223"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074234"><span class="hs-identifier hs-var">kindArgs'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074231"><span class="hs-identifier hs-var">kindRes</span></a></span><span>
</span><span id="line-862"></span><span>          </span><span id="local-6989586621679074237"><span class="annot"><span class="annottext">instTys' :: [Type]
</span><a href="#local-6989586621679074237"><span class="hs-identifier hs-var hs-var">instTys'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074224"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; [Type]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; [Type]
forall flag. [TyVarBndr_ flag] -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#bndrParams"><span class="hs-identifier hs-var">bndrParams</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074233"><span class="hs-identifier hs-var">extra_vis_tvbs</span></a></span><span>
</span><span id="line-863"></span><span>      </span><span id="local-6989586621679074238"><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679074238"><span class="hs-identifier hs-var">dec</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; [Type]
-&gt; Name
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDec%27"><span class="hs-identifier hs-var">normalizeDec'</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074110"><span class="hs-identifier hs-var">isReified</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074221"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074222"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074236"><span class="hs-identifier hs-var">tvbs'</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074237"><span class="hs-identifier hs-var">instTys'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074231"><span class="hs-identifier hs-var">kindRes</span></a></span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074226"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074227"><span class="hs-identifier hs-var">variant</span></a></span><span>
</span><span id="line-864"></span><span>      </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Q DatatypeInfo
</span><a href="#local-6989586621679074144"><span class="hs-identifier hs-var">repair13618'</span></a></span><span> </span><span class="annot"><span class="annottext">(DatatypeInfo -&gt; Q DatatypeInfo) -&gt; DatatypeInfo -&gt; Q DatatypeInfo
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; DatatypeInfo -&gt; DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#giveDIVarsStarKinds"><span class="hs-identifier hs-var">giveDIVarsStarKinds</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074110"><span class="hs-identifier hs-var">isReified</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679074238"><span class="hs-identifier hs-var">dec</span></a></span><span>
</span><span id="line-865"></span><span>
</span><span id="line-866"></span><span class="hs-comment">{-
Note [Tricky result kinds]
~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider this example, which uses UnliftedNewtypes:

  type T :: TYPE r
  newtype T where
    MkT :: forall r. Any @(TYPE r) -&gt; T @r

This has one universally quantified type variable `r`, but making
`reifyDatatype ''T` realize this is surprisingly tricky. There root of the
trickiness is the fact that `Language.Haskell.TH.reify ''T` will yield this:

  newtype T where
    MkT :: forall r. (Any :: TYPE r) -&gt; (T :: TYPE r)

In particular, note that:

1. `reify` does not give `T` an explicit return kind of `TYPE r`. This is bad,
   because without this, we cannot conclude that `r` is universally quantified.
2. The reified type of the `MkT` constructor uses explicit kind annotations
   instead of visible kind applications. That is, the return type is
   `T :: TYPE r` instead of `T @r`. This makes it even trickier to figure out
   that `r` is universally quantified, as `r` does not appear directly
   underneath an application of `T`.

We resolve each of these issues as follows:

1. In `normalizeDecFor.normalizeMbKind`, we attempt to use `reifyType` to look
   up the return kind of the data type. In the `T` example above, this suffices
   to conclude that `T :: TYPE r`. `reifyType` won't always work (e.g., when
   using `normalizeDec` on a data type without an explicit return kind), so for
   those situations, we conservatively assume that the data type has return kind
   `Type`.

   The implementation of `normalizeMbKind` is somewhat involved. See
   &quot;Wrinkle: normalizeMbKind argument unification&quot; below for more details.
2. After determining the result kind `K1`, we pass `K1` through to
   `normalizeGadtC`. In that function, we check if the return type of the data
   constructor is of the form `Ty :: K2`, and if so, we attempt to unify `K1`
   and `K2` by passing through to `mergeArguments`. In the example above, this
   lets us conclude that the `r` in the data type return kind is the same `r`
   as in the data constructor.

===================================================
== Wrinkle: normalizeMbKind argument unification ==
===================================================

Here is a slightly more involved example:

  type T2 :: TYPE r1 -&gt; TYPE r1
  newtype T2 (a :: TYPE r2) = MkT2 a

Here, we must use `reifyType` in `normalizeMbKind` to determine that the return
kind is `TYPE r1`. But we must be careful here: `r1` is actually the same type
variable as `r2`! We don't want to accidentally end up quantifying over the two
variables separately in `datatypeInstVars`, since they're really one and the
same.

We accomplish this by doing the following:

1. After calling `reifyKind` in `normalizeMbKind`, split the result kind into
   as many arguments as there are visible binders in the data type declaration.
   In the `T2` example above, there is exactly one visible binder in
   `newtype T2 a`, so we split the kind `TYPE r1 -&gt; TYPE r1` by one argument to
   get ([TYPE r1], TYPE r1). See `unravelKindUpTo` for how this splitting logic
   is implemented.
2. We then unify the argument kinds resuling from the splitting in the previous
   step with the corresponding kinds from the data type declaration. In the
   example above, the split argument kind is `TYPE r1`, and the binder in the
   declaration has kind `TYPE r2`, so we unify `TYPE r1` with `TYPE r2` using
   `mergeArgumentKinds` to get a substitution [r1 :-&gt; r2].
3. We then apply the substitution from the previous step to the rest of the
   kind. In the example above, that means we apply the [r1 :-&gt; r2] substitution
   to `TYPE r1` to obtain `TYPE r2`.

The payoff is that everything consistently refers to `r2`, rather than the mix
of `r1` and `r2` as before.
-}</span><span>
</span><span id="line-945"></span><span>
</span><span id="line-946"></span><span class="hs-comment">-- | Create new kind variable binder names corresponding to the return kind of</span><span>
</span><span id="line-947"></span><span class="hs-comment">-- a data type. This is useful when you have a data type like:</span><span>
</span><span id="line-948"></span><span class="hs-comment">--</span><span>
</span><span id="line-949"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-950"></span><span class="hs-comment">-- data Foo :: forall k. k -&gt; Type -&gt; Type where ...</span><span>
</span><span id="line-951"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-952"></span><span class="hs-comment">--</span><span>
</span><span id="line-953"></span><span class="hs-comment">-- But you want to be able to refer to the type @Foo a b@.</span><span>
</span><span id="line-954"></span><span class="hs-comment">-- 'mkExtraKindBinders' will take the kind @forall k. k -&gt; Type -&gt; Type@,</span><span>
</span><span id="line-955"></span><span class="hs-comment">-- discover that is has two visible argument kinds, and return as a result</span><span>
</span><span id="line-956"></span><span class="hs-comment">-- two new kind variable binders @[a :: k, b :: Type]@, where @a@ and @b@</span><span>
</span><span id="line-957"></span><span class="hs-comment">-- are fresh type variable names.</span><span>
</span><span id="line-958"></span><span class="hs-comment">--</span><span>
</span><span id="line-959"></span><span class="hs-comment">-- This expands kind synonyms if necessary.</span><span>
</span><span id="line-960"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#mkExtraKindBinders"><span class="hs-identifier hs-type">mkExtraKindBinders</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span><span>
</span><span id="line-961"></span><span id="mkExtraKindBinders"><span class="annot"><span class="annottext">mkExtraKindBinders :: Type -&gt; Q [TyVarBndrUnit]
</span><a href="Language.Haskell.TH.Datatype.html#mkExtraKindBinders"><span class="hs-identifier hs-var hs-var">mkExtraKindBinders</span></a></span></span><span> </span><span id="local-6989586621679074241"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074241"><span class="hs-identifier hs-var">kind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-962"></span><span>  </span><span id="local-6989586621679074242"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074242"><span class="hs-identifier hs-var">kind'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-var">resolveKindSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074241"><span class="hs-identifier hs-var">kind</span></a></span><span>
</span><span id="line-963"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074243"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074243"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; (FunArgs, Type)
</span><a href="Language.Haskell.TH.Datatype.html#unravelKind"><span class="hs-identifier hs-var">unravelKind</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074242"><span class="hs-identifier hs-var">kind'</span></a></span><span>
</span><span id="line-964"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621679074244"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074244"><span class="hs-identifier hs-var">extra_kvbs</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">FunArgs -&gt; Q ([TyVarBndrUnit], FunArgs)
</span><a href="Language.Haskell.TH.Datatype.html#mkExtraFunArgForalls"><span class="hs-identifier hs-var">mkExtraFunArgForalls</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074243"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-965"></span><span>  </span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; Q [TyVarBndrUnit]
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074244"><span class="hs-identifier hs-var">extra_kvbs</span></a></span><span>
</span><span id="line-966"></span><span>
</span><span id="line-967"></span><span class="hs-comment">-- | Take the supplied function kind arguments ('FunArgs') and do two things:</span><span>
</span><span id="line-968"></span><span class="hs-comment">--</span><span>
</span><span id="line-969"></span><span class="hs-comment">-- 1. For each 'FAAnon' with kind @k@, generate a fresh name @a@ and return</span><span>
</span><span id="line-970"></span><span class="hs-comment">--    the 'TyVarBndr' @a :: k@. Also return each visible @forall@ in an</span><span>
</span><span id="line-971"></span><span class="hs-comment">--    'FAForalls' as a 'TyVarBndr'. (This is what the list of 'TyVarBndrUnit's</span><span>
</span><span id="line-972"></span><span class="hs-comment">--    in the return type consists of.)</span><span>
</span><span id="line-973"></span><span class="hs-comment">--</span><span>
</span><span id="line-974"></span><span class="hs-comment">-- 2. Return a new 'FunArgs' value where each 'FAAnon' has been replaced with</span><span>
</span><span id="line-975"></span><span class="hs-comment">--    @'FAForalls' ('ForallVis' [a :: k])@, where @a :: k@ the corresponding</span><span>
</span><span id="line-976"></span><span class="hs-comment">--    'TyVarBndr' computed in step (1).</span><span>
</span><span id="line-977"></span><span class="hs-comment">--</span><span>
</span><span id="line-978"></span><span class="hs-comment">-- As an example, consider this function kind:</span><span>
</span><span id="line-979"></span><span class="hs-comment">--</span><span>
</span><span id="line-980"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-981"></span><span class="hs-comment">-- forall k. k -&gt; Type -&gt; Type</span><span>
</span><span id="line-982"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-983"></span><span class="hs-comment">--</span><span>
</span><span id="line-984"></span><span class="hs-comment">-- After splitting this kind into its 'FunArgs':</span><span>
</span><span id="line-985"></span><span class="hs-comment">--</span><span>
</span><span id="line-986"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-987"></span><span class="hs-comment">-- ['FAForalls' ('ForallInvis' [k]), 'FAAnon' k, 'FAAnon' Type]</span><span>
</span><span id="line-988"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-989"></span><span class="hs-comment">--</span><span>
</span><span id="line-990"></span><span class="hs-comment">-- Calling 'mkExtraFunArgForalls' on this 'FunArgs' value would return:</span><span>
</span><span id="line-991"></span><span class="hs-comment">--</span><span>
</span><span id="line-992"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-993"></span><span class="hs-comment">-- ( [a :: k, b :: Type]</span><span>
</span><span id="line-994"></span><span class="hs-comment">-- , [ 'FAForalls' ('ForallInvis' [k])</span><span>
</span><span id="line-995"></span><span class="hs-comment">--   , 'FAForalls' ('ForallVis' [a :: k])</span><span>
</span><span id="line-996"></span><span class="hs-comment">--   , 'FAForalls' ('ForallVis' [b :: Type])</span><span>
</span><span id="line-997"></span><span class="hs-comment">--   ]</span><span>
</span><span id="line-998"></span><span class="hs-comment">-- )</span><span>
</span><span id="line-999"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1000"></span><span class="hs-comment">--</span><span>
</span><span id="line-1001"></span><span class="hs-comment">-- Where @a@ and @b@ are fresh.</span><span>
</span><span id="line-1002"></span><span class="hs-comment">--</span><span>
</span><span id="line-1003"></span><span class="hs-comment">-- This function is used in two places:</span><span>
</span><span id="line-1004"></span><span class="hs-comment">--</span><span>
</span><span id="line-1005"></span><span class="hs-comment">-- 1. As the workhorse for 'mkExtraKindBinders'.</span><span>
</span><span id="line-1006"></span><span class="hs-comment">--</span><span>
</span><span id="line-1007"></span><span class="hs-comment">-- 2. In 'normalizeDecFor', as part of computing the 'datatypeInstVars' and as</span><span>
</span><span id="line-1008"></span><span class="hs-comment">--    part of eta expanding the explicit return kind.</span><span>
</span><span id="line-1009"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#mkExtraFunArgForalls"><span class="hs-identifier hs-type">mkExtraFunArgForalls</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1010"></span><span id="mkExtraFunArgForalls"><span class="annot"><span class="annottext">mkExtraFunArgForalls :: FunArgs -&gt; Q ([TyVarBndrUnit], FunArgs)
</span><a href="Language.Haskell.TH.Datatype.html#mkExtraFunArgForalls"><span class="hs-identifier hs-var hs-var">mkExtraFunArgForalls</span></a></span></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="Language.Haskell.TH.Datatype.html#FANil"><span class="hs-identifier hs-var">FANil</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1011"></span><span>  </span><span class="annot"><span class="annottext">([TyVarBndrUnit], FunArgs) -&gt; Q ([TyVarBndrUnit], FunArgs)
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="Language.Haskell.TH.Datatype.html#FANil"><span class="hs-identifier hs-var">FANil</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1012"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#mkExtraFunArgForalls"><span class="hs-identifier hs-var">mkExtraFunArgForalls</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FAForalls"><span class="hs-identifier hs-type">FAForalls</span></a></span><span> </span><span id="local-6989586621679074250"><span class="annot"><span class="annottext">ForallTelescope
</span><a href="#local-6989586621679074250"><span class="hs-identifier hs-var">tele</span></a></span></span><span> </span><span id="local-6989586621679074251"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074251"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1013"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621679074252"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074252"><span class="hs-identifier hs-var">extra_vis_tvbs'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074253"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074253"><span class="hs-identifier hs-var">args'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">FunArgs -&gt; Q ([TyVarBndrUnit], FunArgs)
</span><a href="Language.Haskell.TH.Datatype.html#mkExtraFunArgForalls"><span class="hs-identifier hs-var">mkExtraFunArgForalls</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074251"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-1014"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">ForallTelescope
</span><a href="#local-6989586621679074250"><span class="hs-identifier hs-var">tele</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1015"></span><span>    </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ForallVis"><span class="hs-identifier hs-type">ForallVis</span></a></span><span> </span><span id="local-6989586621679074254"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074254"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1016"></span><span>      </span><span class="annot"><span class="annottext">([TyVarBndrUnit], FunArgs) -&gt; Q ([TyVarBndrUnit], FunArgs)
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074254"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; [TyVarBndrUnit] -&gt; [TyVarBndrUnit]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074252"><span class="hs-identifier hs-var">extra_vis_tvbs'</span></a></span><span>
</span><span id="line-1017"></span><span>             </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ForallTelescope -&gt; FunArgs -&gt; FunArgs
</span><a href="Language.Haskell.TH.Datatype.html#FAForalls"><span class="hs-identifier hs-var">FAForalls</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; ForallTelescope
</span><a href="Language.Haskell.TH.Datatype.html#ForallVis"><span class="hs-identifier hs-var">ForallVis</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074254"><span class="hs-identifier hs-var">tvbs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074253"><span class="hs-identifier hs-var">args'</span></a></span><span>
</span><span id="line-1018"></span><span>             </span><span class="hs-special">)</span><span>
</span><span id="line-1019"></span><span>    </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ForallInvis"><span class="hs-identifier hs-type">ForallInvis</span></a></span><span> </span><span id="local-6989586621679074255"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074255"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1020"></span><span>      </span><span class="annot"><span class="annottext">([TyVarBndrUnit], FunArgs) -&gt; Q ([TyVarBndrUnit], FunArgs)
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074252"><span class="hs-identifier hs-var">extra_vis_tvbs'</span></a></span><span>
</span><span id="line-1021"></span><span>             </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ForallTelescope -&gt; FunArgs -&gt; FunArgs
</span><a href="Language.Haskell.TH.Datatype.html#FAForalls"><span class="hs-identifier hs-var">FAForalls</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; ForallTelescope
</span><a href="Language.Haskell.TH.Datatype.html#ForallInvis"><span class="hs-identifier hs-var">ForallInvis</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074255"><span class="hs-identifier hs-var">tvbs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074253"><span class="hs-identifier hs-var">args'</span></a></span><span>
</span><span id="line-1022"></span><span>             </span><span class="hs-special">)</span><span>
</span><span id="line-1023"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#mkExtraFunArgForalls"><span class="hs-identifier hs-var">mkExtraFunArgForalls</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FACxt"><span class="hs-identifier hs-type">FACxt</span></a></span><span> </span><span id="local-6989586621679074257"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074257"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621679074258"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074258"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1024"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621679074259"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074259"><span class="hs-identifier hs-var">extra_vis_tvbs'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074260"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074260"><span class="hs-identifier hs-var">args'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">FunArgs -&gt; Q ([TyVarBndrUnit], FunArgs)
</span><a href="Language.Haskell.TH.Datatype.html#mkExtraFunArgForalls"><span class="hs-identifier hs-var">mkExtraFunArgForalls</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074258"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-1025"></span><span>  </span><span class="annot"><span class="annottext">([TyVarBndrUnit], FunArgs) -&gt; Q ([TyVarBndrUnit], FunArgs)
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074259"><span class="hs-identifier hs-var">extra_vis_tvbs'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; FunArgs -&gt; FunArgs
</span><a href="Language.Haskell.TH.Datatype.html#FACxt"><span class="hs-identifier hs-var">FACxt</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074257"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074260"><span class="hs-identifier hs-var">args'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1026"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#mkExtraFunArgForalls"><span class="hs-identifier hs-var">mkExtraFunArgForalls</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FAAnon"><span class="hs-identifier hs-type">FAAnon</span></a></span><span> </span><span id="local-6989586621679074261"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074261"><span class="hs-identifier hs-var">anon</span></a></span></span><span> </span><span id="local-6989586621679074262"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074262"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1027"></span><span>  </span><span id="local-6989586621679074263"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074263"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q Name
forall (m :: * -&gt; *). Quote m =&gt; String -&gt; m Name
</span><span class="hs-identifier hs-var">newName</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;x&quot;</span></span><span>
</span><span id="line-1028"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074265"><span class="annot"><span class="annottext">tvb :: TyVarBndrUnit
</span><a href="#local-6989586621679074265"><span class="hs-identifier hs-var hs-var">tvb</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; TyVarBndrUnit
forall flag. DefaultBndrFlag flag =&gt; Name -&gt; Type -&gt; TyVarBndr flag
</span><span class="hs-identifier hs-var">kindedTV</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074263"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074261"><span class="hs-identifier hs-var">anon</span></a></span><span>
</span><span id="line-1029"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621679074267"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074267"><span class="hs-identifier hs-var">extra_vis_tvbs'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074268"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074268"><span class="hs-identifier hs-var">args'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">FunArgs -&gt; Q ([TyVarBndrUnit], FunArgs)
</span><a href="Language.Haskell.TH.Datatype.html#mkExtraFunArgForalls"><span class="hs-identifier hs-var">mkExtraFunArgForalls</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074262"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-1030"></span><span>  </span><span class="annot"><span class="annottext">([TyVarBndrUnit], FunArgs) -&gt; Q ([TyVarBndrUnit], FunArgs)
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679074265"><span class="hs-identifier hs-var">tvb</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit -&gt; [TyVarBndrUnit] -&gt; [TyVarBndrUnit]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074267"><span class="hs-identifier hs-var">extra_vis_tvbs'</span></a></span><span>
</span><span id="line-1031"></span><span>         </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ForallTelescope -&gt; FunArgs -&gt; FunArgs
</span><a href="Language.Haskell.TH.Datatype.html#FAForalls"><span class="hs-identifier hs-var">FAForalls</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; ForallTelescope
</span><a href="Language.Haskell.TH.Datatype.html#ForallVis"><span class="hs-identifier hs-var">ForallVis</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679074265"><span class="hs-identifier hs-var">tvb</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074268"><span class="hs-identifier hs-var">args'</span></a></span><span>
</span><span id="line-1032"></span><span>         </span><span class="hs-special">)</span><span>
</span><span id="line-1033"></span><span>
</span><span id="line-1034"></span><span class="annot"><span class="hs-comment">-- | Is a declaration for a @data instance@ or @newtype instance@?</span></span><span>
</span><span id="line-1035"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#isFamInstVariant"><span class="hs-identifier hs-type">isFamInstVariant</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1036"></span><span id="isFamInstVariant"><span class="annot"><span class="annottext">isFamInstVariant :: DatatypeVariant -&gt; Bool
</span><a href="Language.Haskell.TH.Datatype.html#isFamInstVariant"><span class="hs-identifier hs-var hs-var">isFamInstVariant</span></a></span></span><span> </span><span id="local-6989586621679074269"><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074269"><span class="hs-identifier hs-var">dv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1037"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074269"><span class="hs-identifier hs-var">dv</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1038"></span><span>    </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#Datatype"><span class="hs-identifier hs-var">Datatype</span></a></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1039"></span><span>    </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#Newtype"><span class="hs-identifier hs-var">Newtype</span></a></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1040"></span><span>    </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#DataInstance"><span class="hs-identifier hs-var">DataInstance</span></a></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1041"></span><span>    </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#NewtypeInstance"><span class="hs-identifier hs-var">NewtypeInstance</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1042"></span><span>    </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#TypeData"><span class="hs-identifier hs-var">TypeData</span></a></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1043"></span><span>
</span><span id="line-1044"></span><span id="local-6989586621679072494"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#bndrParams"><span class="hs-identifier hs-type">bndrParams</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072494"><span class="hs-identifier hs-type">flag</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span></span><span>
</span><span id="line-1045"></span><span id="bndrParams"><span class="annot"><span class="annottext">bndrParams :: forall flag. [TyVarBndr_ flag] -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#bndrParams"><span class="hs-identifier hs-var hs-var">bndrParams</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyVarBndr_ flag -&gt; Type) -&gt; [TyVarBndr_ flag] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr_ flag -&gt; Type
forall flag. TyVarBndr_ flag -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#bndrParam"><span class="hs-identifier hs-var">bndrParam</span></a></span><span>
</span><span id="line-1046"></span><span>
</span><span id="line-1047"></span><span id="local-6989586621679074270"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#bndrParam"><span class="hs-identifier hs-type">bndrParam</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679074270"><span class="hs-identifier hs-type">flag</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span></span><span>
</span><span id="line-1048"></span><span id="bndrParam"><span class="annot"><span class="annottext">bndrParam :: forall flag. TyVarBndr_ flag -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#bndrParam"><span class="hs-identifier hs-var hs-var">bndrParam</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Type) -&gt; (Name -&gt; Type -&gt; Type) -&gt; TyVarBndr_ flag -&gt; Type
forall r flag.
(Name -&gt; r) -&gt; (Name -&gt; Type -&gt; r) -&gt; TyVarBndr_ flag -&gt; r
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#elimTV"><span class="hs-identifier hs-var">elimTV</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679074272"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074272"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679074273"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074273"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">SigT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074272"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074273"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1049"></span><span>
</span><span id="line-1050"></span><span class="annot"><span class="hs-comment">-- | Returns 'True' if the flag of the supplied 'TyVarBndrVis' is 'BndrReq'.</span></span><span>
</span><span id="line-1051"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#isRequiredTvb"><span class="hs-identifier hs-type">isRequiredTvb</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrVis</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 708
</span><span id="isRequiredTvb"><span class="annot"><span class="annottext">isRequiredTvb :: TyVarBndr BndrVis -&gt; Bool
</span><a href="Language.Haskell.TH.Datatype.html#isRequiredTvb"><span class="hs-identifier hs-var hs-var">isRequiredTvb</span></a></span></span><span> </span><span id="local-6989586621679074275"><span class="annot"><span class="annottext">TyVarBndr BndrVis
</span><a href="#local-6989586621679074275"><span class="hs-identifier hs-var">tvb</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyVarBndr BndrVis -&gt; BndrVis
forall flag. TyVarBndr_ flag -&gt; flag
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvFlag"><span class="hs-identifier hs-var">tvFlag</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndr BndrVis
</span><a href="#local-6989586621679074275"><span class="hs-identifier hs-var">tvb</span></a></span><span> </span><span class="annot"><span class="annottext">BndrVis -&gt; BndrVis -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">BndrVis
</span><span class="hs-identifier hs-var">BndrReq</span></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">isRequiredTvb</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">True</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1058"></span><span class="annot"><span class="hs-comment">-- | Remove the outermost 'SigT'.</span></span><span>
</span><span id="line-1059"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#stripSigT"><span class="hs-identifier hs-type">stripSigT</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1060"></span><span id="stripSigT"><span class="annot"><span class="annottext">stripSigT :: Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#stripSigT"><span class="hs-identifier hs-var hs-var">stripSigT</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679074277"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074277"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074277"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1061"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#stripSigT"><span class="hs-identifier hs-var">stripSigT</span></a></span><span> </span><span id="local-6989586621679074278"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074278"><span class="hs-identifier hs-var">t</span></a></span></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074278"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1062"></span><span>
</span><span id="line-1063"></span><span class="hs-comment">-- | If the supplied 'Type' is a @'SigT' _ k@, return @'Just' k@. Otherwise,</span><span>
</span><span id="line-1064"></span><span class="hs-comment">-- return 'Nothing'.</span><span>
</span><span id="line-1065"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#sigTMaybeKind"><span class="hs-identifier hs-type">sigTMaybeKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1066"></span><span id="sigTMaybeKind"><span class="annot"><span class="annottext">sigTMaybeKind :: Type -&gt; Maybe Type
</span><a href="Language.Haskell.TH.Datatype.html#sigTMaybeKind"><span class="hs-identifier hs-var hs-var">sigTMaybeKind</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679074279"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074279"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe Type
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074279"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1067"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#sigTMaybeKind"><span class="hs-identifier hs-var">sigTMaybeKind</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Type
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-1068"></span><span>
</span><span id="line-1069"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeDec%27"><span class="hs-identifier hs-type">normalizeDec'</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-1070"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a></span><span>    </span><span class="annot"><span class="hs-comment">{- ^ Is this a reified 'Dec'? -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1071"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span>             </span><span class="annot"><span class="hs-comment">{- ^ Datatype context         -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1072"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>            </span><span class="annot"><span class="hs-comment">{- ^ Type constructor         -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1073"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">{- ^ Type parameters          -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1074"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>          </span><span class="annot"><span class="hs-comment">{- ^ Argument types           -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1075"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>            </span><span class="annot"><span class="hs-comment">{- ^ Result kind              -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1076"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span class="hs-special">]</span><span>           </span><span class="annot"><span class="hs-comment">{- ^ Constructors             -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1077"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="annot"><span class="hs-comment">{- ^ Extra information        -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1078"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-1079"></span><span id="normalizeDec%27"><span class="annot"><span class="annottext">normalizeDec' :: Bool
-&gt; [Type]
-&gt; Name
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDec%27"><span class="hs-identifier hs-var hs-var">normalizeDec'</span></a></span></span><span> </span><span id="local-6989586621679074280"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074280"><span class="hs-identifier hs-var">reifiedDec</span></a></span></span><span> </span><span id="local-6989586621679074281"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074281"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679074282"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074282"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679074283"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074283"><span class="hs-identifier hs-var">params</span></a></span></span><span> </span><span id="local-6989586621679074284"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074284"><span class="hs-identifier hs-var">instTys</span></a></span></span><span> </span><span id="local-6989586621679074285"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074285"><span class="hs-identifier hs-var">resKind</span></a></span></span><span> </span><span id="local-6989586621679074286"><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074286"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621679074287"><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074287"><span class="hs-identifier hs-var">variant</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1080"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679074288"><span class="annot"><span class="annottext">[ConstructorInfo]
</span><a href="#local-6989586621679074288"><span class="hs-identifier hs-var">cons'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[[ConstructorInfo]] -&gt; [ConstructorInfo]
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="annot"><span class="annottext">([[ConstructorInfo]] -&gt; [ConstructorInfo])
-&gt; Q [[ConstructorInfo]] -&gt; Q [ConstructorInfo]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Con -&gt; Q [ConstructorInfo]) -&gt; [Con] -&gt; Q [[ConstructorInfo]]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
-&gt; Name
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; Type
-&gt; DatatypeVariant
-&gt; Con
-&gt; Q [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#normalizeConFor"><span class="hs-identifier hs-var">normalizeConFor</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074280"><span class="hs-identifier hs-var">reifiedDec</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074282"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074283"><span class="hs-identifier hs-var">params</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074284"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074285"><span class="hs-identifier hs-var">resKind</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074287"><span class="hs-identifier hs-var">variant</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679074286"><span class="hs-identifier hs-var">cons</span></a></span><span>
</span><span id="line-1081"></span><span>     </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Q DatatypeInfo
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-1082"></span><span>       </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">datatypeContext :: [Type]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeContext"><span class="hs-identifier hs-var">datatypeContext</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074281"><span class="hs-identifier hs-var">context</span></a></span><span>
</span><span id="line-1083"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">datatypeName :: Name
</span><a href="Language.Haskell.TH.Datatype.html#datatypeName"><span class="hs-identifier hs-var">datatypeName</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074282"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1084"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">datatypeVars :: [TyVarBndrUnit]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeVars"><span class="hs-identifier hs-var">datatypeVars</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074283"><span class="hs-identifier hs-var">params</span></a></span><span>
</span><span id="line-1085"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">datatypeInstTypes :: [Type]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeInstTypes"><span class="hs-identifier hs-var">datatypeInstTypes</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074284"><span class="hs-identifier hs-var">instTys</span></a></span><span>
</span><span id="line-1086"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">datatypeCons :: [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var">datatypeCons</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[ConstructorInfo]
</span><a href="#local-6989586621679074288"><span class="hs-identifier hs-var">cons'</span></a></span><span>
</span><span id="line-1087"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">datatypeReturnKind :: Type
</span><a href="Language.Haskell.TH.Datatype.html#datatypeReturnKind"><span class="hs-identifier hs-var">datatypeReturnKind</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074285"><span class="hs-identifier hs-var">resKind</span></a></span><span>
</span><span id="line-1088"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">datatypeVariant :: DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#datatypeVariant"><span class="hs-identifier hs-var">datatypeVariant</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074287"><span class="hs-identifier hs-var">variant</span></a></span><span>
</span><span id="line-1089"></span><span>       </span><span class="hs-special">}</span><span>
</span><span id="line-1090"></span><span>
</span><span id="line-1091"></span><span class="hs-comment">-- | Normalize a 'Con' into a 'ConstructorInfo'. This requires knowledge of</span><span>
</span><span id="line-1092"></span><span class="hs-comment">-- the type and parameters of the constructor, as well as whether the constructor</span><span>
</span><span id="line-1093"></span><span class="hs-comment">-- is for a data family instance, as extracted from the outer</span><span>
</span><span id="line-1094"></span><span class="hs-comment">-- 'Dec'.</span><span>
</span><span id="line-1095"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeCon"><span class="hs-identifier hs-type">normalizeCon</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-1096"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>            </span><span class="annot"><span class="hs-comment">{- ^ Type constructor  -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1097"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">{- ^ Type parameters   -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1098"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>          </span><span class="annot"><span class="hs-comment">{- ^ Argument types    -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1099"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>            </span><span class="annot"><span class="hs-comment">{- ^ Result kind       -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1100"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="annot"><span class="hs-comment">{- ^ Extra information -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1101"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span>             </span><span class="annot"><span class="hs-comment">{- ^ Constructor       -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1102"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1103"></span><span id="normalizeCon"><span class="annot"><span class="annottext">normalizeCon :: Name
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; Type
-&gt; DatatypeVariant
-&gt; Con
-&gt; Q [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#normalizeCon"><span class="hs-identifier hs-var hs-var">normalizeCon</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; Name
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; Type
-&gt; DatatypeVariant
-&gt; Con
-&gt; Q [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#normalizeConFor"><span class="hs-identifier hs-var">normalizeConFor</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="Language.Haskell.TH.Datatype.html#isn%27tReified"><span class="hs-identifier hs-var">isn'tReified</span></a></span><span>
</span><span id="line-1104"></span><span>
</span><span id="line-1105"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeConFor"><span class="hs-identifier hs-type">normalizeConFor</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-1106"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a></span><span>    </span><span class="annot"><span class="hs-comment">{- ^ Is this a reified 'Dec'? -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1107"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>            </span><span class="annot"><span class="hs-comment">{- ^ Type constructor         -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1108"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">{- ^ Type parameters          -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1109"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>          </span><span class="annot"><span class="hs-comment">{- ^ Argument types           -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1110"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>            </span><span class="annot"><span class="hs-comment">{- ^ Result kind              -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1111"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="annot"><span class="hs-comment">{- ^ Extra information        -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1112"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span>             </span><span class="annot"><span class="hs-comment">{- ^ Constructor              -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1113"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1114"></span><span id="normalizeConFor"><span class="annot"><span class="annottext">normalizeConFor :: Bool
-&gt; Name
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; Type
-&gt; DatatypeVariant
-&gt; Con
-&gt; Q [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#normalizeConFor"><span class="hs-identifier hs-var hs-var">normalizeConFor</span></a></span></span><span> </span><span id="local-6989586621679074291"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074291"><span class="hs-identifier hs-var">reifiedDec</span></a></span></span><span> </span><span id="local-6989586621679074292"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074292"><span class="hs-identifier hs-var">typename</span></a></span></span><span> </span><span id="local-6989586621679074293"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074293"><span class="hs-identifier hs-var">params</span></a></span></span><span> </span><span id="local-6989586621679074294"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074294"><span class="hs-identifier hs-var">instTys</span></a></span></span><span> </span><span id="local-6989586621679074295"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074295"><span class="hs-identifier hs-var">resKind</span></a></span></span><span> </span><span id="local-6989586621679074296"><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679074296"><span class="hs-identifier hs-var">variant</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1115"></span><span>  </span><span class="annot"><span class="annottext">([ConstructorInfo] -&gt; [ConstructorInfo])
-&gt; Q [ConstructorInfo] -&gt; Q [ConstructorInfo]
forall a b. (a -&gt; b) -&gt; Q a -&gt; Q b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(ConstructorInfo -&gt; ConstructorInfo)
-&gt; [ConstructorInfo] -&gt; [ConstructorInfo]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; ConstructorInfo -&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#giveCIVarsStarKinds"><span class="hs-identifier hs-var">giveCIVarsStarKinds</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074291"><span class="hs-identifier hs-var">reifiedDec</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Q [ConstructorInfo] -&gt; Q [ConstructorInfo])
-&gt; (Con -&gt; Q [ConstructorInfo]) -&gt; Con -&gt; Q [ConstructorInfo]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Con -&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679074298"><span class="hs-identifier hs-var">dispatch</span></a></span><span>
</span><span id="line-1116"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1117"></span><span>    </span><span class="hs-comment">-- A GADT constructor is declared infix when:</span><span>
</span><span id="line-1118"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-1119"></span><span>    </span><span class="hs-comment">-- 1. Its name uses operator syntax (e.g., (:*:))</span><span>
</span><span id="line-1120"></span><span>    </span><span class="hs-comment">-- 2. It has exactly two fields</span><span>
</span><span id="line-1121"></span><span>    </span><span class="hs-comment">-- 3. It has a programmer-supplied fixity declaration</span><span>
</span><span id="line-1122"></span><span>    </span><span class="annot"><a href="#local-6989586621679074299"><span class="hs-identifier hs-type">checkGadtFixity</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorVariant"><span class="hs-identifier hs-type">ConstructorVariant</span></a></span><span>
</span><span id="line-1123"></span><span>    </span><span id="local-6989586621679074299"><span class="annot"><span class="annottext">checkGadtFixity :: [Type] -&gt; Name -&gt; Q ConstructorVariant
</span><a href="#local-6989586621679074299"><span class="hs-identifier hs-var hs-var">checkGadtFixity</span></a></span></span><span> </span><span id="local-6989586621679074300"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074300"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span id="local-6989586621679074301"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074301"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>      </span><span class="hs-comment">-- Don't call reifyFixityCompat here! We need to be able to distinguish</span><span>
</span><span id="line-1126"></span><span>      </span><span class="hs-comment">-- between a default fixity and an explicit @infixl 9@.</span><span>
</span><span id="line-1127"></span><span>      </span><span id="local-6989586621679074302"><span class="annot"><span class="annottext">Maybe Fixity
</span><a href="#local-6989586621679074302"><span class="hs-identifier hs-var">mbFi</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Maybe Fixity -&gt; Q (Maybe Fixity)
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Maybe Fixity
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">Q (Maybe Fixity) -&gt; Q (Maybe Fixity) -&gt; Q (Maybe Fixity)
forall a. Q a -&gt; Q a -&gt; Q a
</span><span class="hs-operator hs-var">`recover`</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q (Maybe Fixity)
</span><span class="hs-identifier hs-var">reifyFixity</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074301"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1128"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074304"><span class="annot"><span class="annottext">userSuppliedFixity :: Bool
</span><a href="#local-6989586621679074304"><span class="hs-identifier hs-var hs-var">userSuppliedFixity</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Fixity -&gt; Bool
forall a. Maybe a -&gt; Bool
</span><span class="hs-identifier hs-var">isJust</span></span><span> </span><span class="annot"><span class="annottext">Maybe Fixity
</span><a href="#local-6989586621679074302"><span class="hs-identifier hs-var">mbFi</span></a></span><span class="hs-cpp">
#else
</span><span>      </span><span class="hs-comment">-- On old GHCs, there is a bug where infix GADT constructors will</span><span>
</span><span id="line-1131"></span><span>      </span><span class="hs-comment">-- mistakenly be marked as (ForallC (NormalC ...)) instead of</span><span>
</span><span id="line-1132"></span><span>      </span><span class="hs-comment">-- (ForallC (InfixC ...)). This is especially annoying since on these</span><span>
</span><span id="line-1133"></span><span>      </span><span class="hs-comment">-- versions of GHC, Template Haskell doesn't grant the ability to query</span><span>
</span><span id="line-1134"></span><span>      </span><span class="hs-comment">-- whether a constructor was given a user-supplied fixity declaration.</span><span>
</span><span id="line-1135"></span><span>      </span><span class="hs-comment">-- Rather, you can only check the fixity that GHC ultimately decides on</span><span>
</span><span id="line-1136"></span><span>      </span><span class="hs-comment">-- for a constructor, regardless of whether it was a default fixity or</span><span>
</span><span id="line-1137"></span><span>      </span><span class="hs-comment">-- it was user-supplied.</span><span>
</span><span id="line-1138"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-1139"></span><span>      </span><span class="hs-comment">-- We can approximate whether a fixity was user-supplied by checking if</span><span>
</span><span id="line-1140"></span><span>      </span><span class="hs-comment">-- it is not equal to defaultFixity (infixl 9). Unfortunately,</span><span>
</span><span id="line-1141"></span><span>      </span><span class="hs-comment">-- there is no way to distinguish between a user-supplied fixity of</span><span>
</span><span id="line-1142"></span><span>      </span><span class="hs-comment">-- infixl 9 and the fixity that GHC defaults to, so we cannot properly</span><span>
</span><span id="line-1143"></span><span>      </span><span class="hs-comment">-- handle that case.</span><span>
</span><span id="line-1144"></span><span>      </span><span class="hs-identifier">mbFi</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">reifyFixityCompat</span><span> </span><span class="hs-identifier">n</span><span>
</span><span id="line-1145"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">userSuppliedFixity</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">isJust</span><span> </span><span class="hs-identifier">mbFi</span><span> </span><span class="hs-operator">&amp;&amp;</span><span> </span><span class="hs-identifier">mbFi</span><span> </span><span class="hs-operator">/=</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">defaultFixity</span><span class="hs-cpp">
#endif
</span><span>      </span><span class="annot"><span class="annottext">ConstructorVariant -&gt; Q ConstructorVariant
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(ConstructorVariant -&gt; Q ConstructorVariant)
-&gt; ConstructorVariant -&gt; Q ConstructorVariant
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">String -&gt; Bool
</span><a href="#local-6989586621679074306"><span class="hs-identifier hs-var">isInfixDataCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074301"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1148"></span><span>                  </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074300"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span>
</span><span id="line-1149"></span><span>                  </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074304"><span class="hs-identifier hs-var">userSuppliedFixity</span></a></span><span>
</span><span id="line-1150"></span><span>               </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#InfixConstructor"><span class="hs-identifier hs-var">InfixConstructor</span></a></span><span>
</span><span id="line-1151"></span><span>               </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#NormalConstructor"><span class="hs-identifier hs-var">NormalConstructor</span></a></span><span>
</span><span id="line-1152"></span><span>
</span><span id="line-1153"></span><span>    </span><span class="hs-comment">-- Checks if a String names a valid Haskell infix data</span><span>
</span><span id="line-1154"></span><span>    </span><span class="hs-comment">-- constructor (i.e., does it begin with a colon?).</span><span>
</span><span id="line-1155"></span><span>    </span><span class="annot"><a href="#local-6989586621679074306"><span class="hs-identifier hs-type">isInfixDataCon</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1156"></span><span>    </span><span id="local-6989586621679074306"><span class="annot"><span class="annottext">isInfixDataCon :: String -&gt; Bool
</span><a href="#local-6989586621679074306"><span class="hs-identifier hs-var hs-var">isInfixDataCon</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">':'</span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1157"></span><span>    </span><span class="annot"><a href="#local-6989586621679074306"><span class="hs-identifier hs-var">isInfixDataCon</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1158"></span><span>
</span><span id="line-1159"></span><span>    </span><span class="annot"><a href="#local-6989586621679074298"><span class="hs-identifier hs-type">dispatch</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1160"></span><span>    </span><span id="local-6989586621679074298"><span class="annot"><span class="annottext">dispatch :: Con -&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679074298"><span class="hs-identifier hs-var hs-var">dispatch</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1161"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span class="annot"><a href="#local-6989586621679074308"><span class="hs-identifier hs-type">defaultCase</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1162"></span><span>          </span><span id="local-6989586621679074308"><span class="annot"><span class="annottext">defaultCase :: Con -&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679074308"><span class="hs-identifier hs-var hs-var">defaultCase</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; [Type] -&gt; Bool -&gt; Con -&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679074309"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1163"></span><span>            </span><span class="hs-keyword">where</span><span>
</span><span id="line-1164"></span><span>              </span><span class="annot"><a href="#local-6989586621679074309"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span><span>
</span><span id="line-1165"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span>
</span><span id="line-1166"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-comment">-- Is this a GADT? (see the documentation for</span><span>
</span><span id="line-1167"></span><span>                         </span><span class="hs-comment">-- for checkGadtFixity)</span><span>
</span><span id="line-1168"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span>
</span><span id="line-1169"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1170"></span><span>              </span><span id="local-6989586621679074309"><span class="annot"><span class="annottext">go :: [TyVarBndrUnit] -&gt; [Type] -&gt; Bool -&gt; Con -&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679074309"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679074310"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074310"><span class="hs-identifier hs-var">tyvars</span></a></span></span><span> </span><span id="local-6989586621679074311"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074311"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679074312"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074312"><span class="hs-identifier hs-var">gadt</span></a></span></span><span> </span><span id="local-6989586621679074313"><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679074313"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1171"></span><span>                </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679074313"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1172"></span><span>                  </span><span class="annot"><span class="hs-identifier hs-type">NormalC</span></span><span> </span><span id="local-6989586621679074315"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074315"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679074316"><span class="annot"><span class="annottext">[BangType]
</span><a href="#local-6989586621679074316"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1173"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074317"><span class="annot"><span class="annottext">[Bang]
</span><a href="#local-6989586621679074317"><span class="hs-identifier hs-var">bangs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074318"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074318"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[BangType] -&gt; ([Bang], [Type])
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="annot"><span class="annottext">[BangType]
</span><a href="#local-6989586621679074316"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-1174"></span><span>                        </span><span id="local-6989586621679074319"><span class="annot"><span class="annottext">stricts :: [FieldStrictness]
</span><a href="#local-6989586621679074319"><span class="hs-identifier hs-var hs-var">stricts</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Bang -&gt; FieldStrictness) -&gt; [Bang] -&gt; [FieldStrictness]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Bang -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-var">normalizeStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">[Bang]
</span><a href="#local-6989586621679074317"><span class="hs-identifier hs-var">bangs</span></a></span><span>
</span><span id="line-1175"></span><span>                    </span><span id="local-6989586621679074321"><span class="annot"><span class="annottext">ConstructorVariant
</span><a href="#local-6989586621679074321"><span class="hs-identifier hs-var">fi</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074312"><span class="hs-identifier hs-var">gadt</span></a></span><span>
</span><span id="line-1176"></span><span>                             </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Name -&gt; Q ConstructorVariant
</span><a href="#local-6989586621679074299"><span class="hs-identifier hs-var">checkGadtFixity</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074318"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074315"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1177"></span><span>                             </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">ConstructorVariant -&gt; Q ConstructorVariant
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#NormalConstructor"><span class="hs-identifier hs-var">NormalConstructor</span></a></span><span>
</span><span id="line-1178"></span><span>                    </span><span class="annot"><span class="annottext">[ConstructorInfo] -&gt; Q [ConstructorInfo]
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; [Type]
-&gt; [FieldStrictness]
-&gt; ConstructorVariant
-&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074315"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074310"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074311"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074318"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">[FieldStrictness]
</span><a href="#local-6989586621679074319"><span class="hs-identifier hs-var">stricts</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorVariant
</span><a href="#local-6989586621679074321"><span class="hs-identifier hs-var">fi</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1179"></span><span>                  </span><span class="annot"><span class="hs-identifier hs-type">InfixC</span></span><span> </span><span id="local-6989586621679074323"><span class="annot"><span class="annottext">BangType
</span><a href="#local-6989586621679074323"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679074324"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074324"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679074325"><span class="annot"><span class="annottext">BangType
</span><a href="#local-6989586621679074325"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1180"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074326"><span class="annot"><span class="annottext">[Bang]
</span><a href="#local-6989586621679074326"><span class="hs-identifier hs-var">bangs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074327"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074327"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[BangType] -&gt; ([Bang], [Type])
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">BangType
</span><a href="#local-6989586621679074323"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">BangType
</span><a href="#local-6989586621679074325"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1181"></span><span>                        </span><span id="local-6989586621679074328"><span class="annot"><span class="annottext">stricts :: [FieldStrictness]
</span><a href="#local-6989586621679074328"><span class="hs-identifier hs-var hs-var">stricts</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Bang -&gt; FieldStrictness) -&gt; [Bang] -&gt; [FieldStrictness]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Bang -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-var">normalizeStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">[Bang]
</span><a href="#local-6989586621679074326"><span class="hs-identifier hs-var">bangs</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1182"></span><span>                    </span><span class="annot"><span class="annottext">[ConstructorInfo] -&gt; Q [ConstructorInfo]
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; [Type]
-&gt; [FieldStrictness]
-&gt; ConstructorVariant
-&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074324"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074310"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074311"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074327"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">[FieldStrictness]
</span><a href="#local-6989586621679074328"><span class="hs-identifier hs-var">stricts</span></a></span><span>
</span><span id="line-1183"></span><span>                                            </span><span class="annot"><span class="annottext">ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#InfixConstructor"><span class="hs-identifier hs-var">InfixConstructor</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1184"></span><span>                  </span><span class="annot"><span class="hs-identifier hs-type">RecC</span></span><span> </span><span id="local-6989586621679074330"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074330"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679074331"><span class="annot"><span class="annottext">[VarBangType]
</span><a href="#local-6989586621679074331"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1185"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074332"><span class="annot"><span class="annottext">fns :: [Name]
</span><a href="#local-6989586621679074332"><span class="hs-identifier hs-var hs-var">fns</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[VarBangType] -&gt; [Name]
forall a b. [(Name, a, b)] -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldNames"><span class="hs-identifier hs-var">takeFieldNames</span></a></span><span> </span><span class="annot"><span class="annottext">[VarBangType]
</span><a href="#local-6989586621679074331"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-1186"></span><span>                        </span><span id="local-6989586621679074334"><span class="annot"><span class="annottext">stricts :: [FieldStrictness]
</span><a href="#local-6989586621679074334"><span class="hs-identifier hs-var hs-var">stricts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[VarBangType] -&gt; [FieldStrictness]
forall a b. [(a, Bang, b)] -&gt; [FieldStrictness]
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldStrictness"><span class="hs-identifier hs-var">takeFieldStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">[VarBangType]
</span><a href="#local-6989586621679074331"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1187"></span><span>                    </span><span class="annot"><span class="annottext">[ConstructorInfo] -&gt; Q [ConstructorInfo]
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; [Type]
-&gt; [FieldStrictness]
-&gt; ConstructorVariant
-&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074330"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074310"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074311"><span class="hs-identifier hs-var">context</span></a></span><span>
</span><span id="line-1188"></span><span>                              </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VarBangType] -&gt; [Type]
forall a b. [(a, b, Type)] -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldTypes"><span class="hs-identifier hs-var">takeFieldTypes</span></a></span><span> </span><span class="annot"><span class="annottext">[VarBangType]
</span><a href="#local-6989586621679074331"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[FieldStrictness]
</span><a href="#local-6989586621679074334"><span class="hs-identifier hs-var">stricts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#RecordConstructor"><span class="hs-identifier hs-var">RecordConstructor</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074332"><span class="hs-identifier hs-var">fns</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-1189"></span><span>                  </span><span class="annot"><span class="hs-identifier hs-type">ForallC</span></span><span> </span><span id="local-6989586621679074338"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074338"><span class="hs-identifier hs-var">tyvars'</span></a></span></span><span> </span><span id="local-6989586621679074339"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074339"><span class="hs-identifier hs-var">context'</span></a></span></span><span> </span><span id="local-6989586621679074340"><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679074340"><span class="hs-identifier hs-var">c'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1190"></span><span>                    </span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; [Type] -&gt; Bool -&gt; Con -&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679074309"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; [TyVarBndrSpec] -&gt; [TyVarBndrUnit]
forall newFlag oldFlag.
newFlag -&gt; [TyVarBndr_ oldFlag] -&gt; [TyVarBndr_ newFlag]
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#changeTVFlags"><span class="hs-identifier hs-var">changeTVFlags</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074338"><span class="hs-identifier hs-var">tyvars'</span></a></span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; [TyVarBndrUnit] -&gt; [TyVarBndrUnit]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074310"><span class="hs-identifier hs-var">tyvars</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074339"><span class="hs-identifier hs-var">context'</span></a></span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; [Type]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074311"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679074340"><span class="hs-identifier hs-var">c'</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>                  </span><span class="annot"><span class="hs-identifier hs-type">GadtC</span></span><span> </span><span id="local-6989586621679074342"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074342"><span class="hs-identifier hs-var">ns</span></a></span></span><span> </span><span id="local-6989586621679074343"><span class="annot"><span class="annottext">[BangType]
</span><a href="#local-6989586621679074343"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621679074344"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074344"><span class="hs-identifier hs-var">innerType</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1193"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074345"><span class="annot"><span class="annottext">[Bang]
</span><a href="#local-6989586621679074345"><span class="hs-identifier hs-var">bangs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074346"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074346"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[BangType] -&gt; ([Bang], [Type])
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="annot"><span class="annottext">[BangType]
</span><a href="#local-6989586621679074343"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-1194"></span><span>                        </span><span id="local-6989586621679074347"><span class="annot"><span class="annottext">stricts :: [FieldStrictness]
</span><a href="#local-6989586621679074347"><span class="hs-identifier hs-var hs-var">stricts</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Bang -&gt; FieldStrictness) -&gt; [Bang] -&gt; [FieldStrictness]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Bang -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-var">normalizeStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">[Bang]
</span><a href="#local-6989586621679074345"><span class="hs-identifier hs-var">bangs</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1195"></span><span>                    </span><span class="annot"><span class="annottext">[Name]
-&gt; Type
-&gt; [Type]
-&gt; [FieldStrictness]
-&gt; (Name -&gt; Q ConstructorVariant)
-&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679074348"><span class="hs-identifier hs-var">gadtCase</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074342"><span class="hs-identifier hs-var">ns</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074344"><span class="hs-identifier hs-var">innerType</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074346"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">[FieldStrictness]
</span><a href="#local-6989586621679074347"><span class="hs-identifier hs-var">stricts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; Name -&gt; Q ConstructorVariant
</span><a href="#local-6989586621679074299"><span class="hs-identifier hs-var">checkGadtFixity</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074346"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1196"></span><span>                  </span><span class="annot"><span class="hs-identifier hs-type">RecGadtC</span></span><span> </span><span id="local-6989586621679074350"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074350"><span class="hs-identifier hs-var">ns</span></a></span></span><span> </span><span id="local-6989586621679074351"><span class="annot"><span class="annottext">[VarBangType]
</span><a href="#local-6989586621679074351"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621679074352"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074352"><span class="hs-identifier hs-var">innerType</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1197"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074353"><span class="annot"><span class="annottext">fns :: [Name]
</span><a href="#local-6989586621679074353"><span class="hs-identifier hs-var hs-var">fns</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[VarBangType] -&gt; [Name]
forall a b. [(Name, a, b)] -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldNames"><span class="hs-identifier hs-var">takeFieldNames</span></a></span><span> </span><span class="annot"><span class="annottext">[VarBangType]
</span><a href="#local-6989586621679074351"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-1198"></span><span>                        </span><span id="local-6989586621679074354"><span class="annot"><span class="annottext">stricts :: [FieldStrictness]
</span><a href="#local-6989586621679074354"><span class="hs-identifier hs-var hs-var">stricts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[VarBangType] -&gt; [FieldStrictness]
forall a b. [(a, Bang, b)] -&gt; [FieldStrictness]
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldStrictness"><span class="hs-identifier hs-var">takeFieldStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">[VarBangType]
</span><a href="#local-6989586621679074351"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1199"></span><span>                    </span><span class="annot"><span class="annottext">[Name]
-&gt; Type
-&gt; [Type]
-&gt; [FieldStrictness]
-&gt; (Name -&gt; Q ConstructorVariant)
-&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679074348"><span class="hs-identifier hs-var">gadtCase</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074350"><span class="hs-identifier hs-var">ns</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074352"><span class="hs-identifier hs-var">innerType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VarBangType] -&gt; [Type]
forall a b. [(a, b, Type)] -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldTypes"><span class="hs-identifier hs-var">takeFieldTypes</span></a></span><span> </span><span class="annot"><span class="annottext">[VarBangType]
</span><a href="#local-6989586621679074351"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[FieldStrictness]
</span><a href="#local-6989586621679074354"><span class="hs-identifier hs-var">stricts</span></a></span><span>
</span><span id="line-1200"></span><span>                             </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Q ConstructorVariant -&gt; Name -&gt; Q ConstructorVariant
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">(Q ConstructorVariant -&gt; Name -&gt; Q ConstructorVariant)
-&gt; Q ConstructorVariant -&gt; Name -&gt; Q ConstructorVariant
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ConstructorVariant -&gt; Q ConstructorVariant
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(ConstructorVariant -&gt; Q ConstructorVariant)
-&gt; ConstructorVariant -&gt; Q ConstructorVariant
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#RecordConstructor"><span class="hs-identifier hs-var">RecordConstructor</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074353"><span class="hs-identifier hs-var">fns</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1201"></span><span>                </span><span class="hs-keyword">where</span><span>
</span><span id="line-1202"></span><span>                  </span><span id="local-6989586621679074348"><span class="annot"><span class="annottext">gadtCase :: [Name]
-&gt; Type
-&gt; [Type]
-&gt; [FieldStrictness]
-&gt; (Name -&gt; Q ConstructorVariant)
-&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679074348"><span class="hs-identifier hs-var hs-var">gadtCase</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; Type
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; [Name]
-&gt; Type
-&gt; [Type]
-&gt; [FieldStrictness]
-&gt; (Name -&gt; Q ConstructorVariant)
-&gt; Q [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#normalizeGadtC"><span class="hs-identifier hs-var">normalizeGadtC</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074292"><span class="hs-identifier hs-var">typename</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074293"><span class="hs-identifier hs-var">params</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074294"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074295"><span class="hs-identifier hs-var">resKind</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074310"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074311"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,8,0) &amp;&amp; (!MIN_VERSION_template_haskell(2,10,0))
</span><span>          </span><span class="hs-identifier">dataFamCompatCase</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Con</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Q</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">ConstructorInfo</span><span class="hs-special">]</span><span>
</span><span id="line-1206"></span><span>          </span><span class="hs-identifier">dataFamCompatCase</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-1207"></span><span>            </span><span class="hs-keyword">where</span><span>
</span><span id="line-1208"></span><span>              </span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1209"></span><span>                </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1210"></span><span>                  </span><span class="hs-identifier">NormalC</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1211"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">map</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">fst</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1212"></span><span>                    </span><span class="hs-identifier">dataFamCase'</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-identifier">NormalConstructor</span><span>
</span><span id="line-1213"></span><span>                  </span><span class="hs-identifier">InfixC</span><span> </span><span class="hs-identifier">l</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">r</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1214"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">map</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">fst</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">l</span><span class="hs-special">,</span><span class="hs-identifier">r</span><span class="hs-special">]</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1215"></span><span>                    </span><span class="hs-identifier">dataFamCase'</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-identifier">InfixConstructor</span><span>
</span><span id="line-1216"></span><span>                  </span><span class="hs-identifier">RecC</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1217"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">takeFieldStrictness</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1218"></span><span>                    </span><span class="hs-identifier">dataFamCase'</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">stricts</span><span>
</span><span id="line-1219"></span><span>                                 </span><span class="hs-special">(</span><span class="hs-identifier">RecordConstructor</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">takeFieldNames</span><span> </span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1220"></span><span>                  </span><span class="hs-identifier">ForallC</span><span> </span><span class="hs-identifier">tyvars'</span><span> </span><span class="hs-identifier">context'</span><span> </span><span class="hs-identifier">c'</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1221"></span><span>                    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">tyvars'</span><span class="hs-operator">++</span><span class="hs-identifier">tyvars</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">c'</span><span>
</span><span id="line-1222"></span><span>
</span><span id="line-1223"></span><span>          </span><span class="hs-identifier">dataFamCase'</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">FieldStrictness</span><span class="hs-special">]</span><span>
</span><span id="line-1224"></span><span>                       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">ConstructorVariant</span><span>
</span><span id="line-1225"></span><span>                       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Q</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">ConstructorInfo</span><span class="hs-special">]</span><span>
</span><span id="line-1226"></span><span>          </span><span class="hs-identifier">dataFamCase'</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-identifier">variant</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1227"></span><span>            </span><span class="hs-identifier">mbInfo</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">reifyMaybe</span><span> </span><span class="hs-identifier">n</span><span>
</span><span id="line-1228"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">mbInfo</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1229"></span><span>              </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">DataConI</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">ty</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1230"></span><span>                </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">tyvars</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">context</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">argTys</span><span> </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">returnTy</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">uncurryType</span><span> </span><span class="hs-identifier">ty</span><span>
</span><span id="line-1231"></span><span>                </span><span class="hs-identifier">returnTy'</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">resolveTypeSynonyms</span><span> </span><span class="hs-identifier">returnTy</span><span>
</span><span id="line-1232"></span><span>                </span><span class="hs-comment">-- Notice that we've ignored the TyVarBndrs, Cxt and argument</span><span>
</span><span id="line-1233"></span><span>                </span><span class="hs-comment">-- Types from the Con argument above, as they might be scoped</span><span>
</span><span id="line-1234"></span><span>                </span><span class="hs-comment">-- over eta-reduced variables. Instead of trying to figure out</span><span>
</span><span id="line-1235"></span><span>                </span><span class="hs-comment">-- what the eta-reduced variables should be substituted with</span><span>
</span><span id="line-1236"></span><span>                </span><span class="hs-comment">-- post facto, we opt for the simpler approach of using the</span><span>
</span><span id="line-1237"></span><span>                </span><span class="hs-comment">-- context and argument types from the reified constructor</span><span>
</span><span id="line-1238"></span><span>                </span><span class="hs-comment">-- Info, which will at least be correctly scoped. This will</span><span>
</span><span id="line-1239"></span><span>                </span><span class="hs-comment">-- make the task of substituting those types with the variables</span><span>
</span><span id="line-1240"></span><span>                </span><span class="hs-comment">-- we put in place of the eta-reduced variables</span><span>
</span><span id="line-1241"></span><span>                </span><span class="hs-comment">-- (in normalizeDec) much easier.</span><span>
</span><span id="line-1242"></span><span>                </span><span class="hs-identifier">normalizeGadtC</span><span> </span><span class="hs-identifier">typename</span><span> </span><span class="hs-identifier">params</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">resKind</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">n</span><span class="hs-special">]</span><span>
</span><span id="line-1243"></span><span>                               </span><span class="hs-identifier">returnTy'</span><span> </span><span class="hs-identifier">argTys</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">const</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-identifier">variant</span><span class="hs-special">)</span><span>
</span><span id="line-1244"></span><span>              </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">fail</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">unlines</span><span>
</span><span id="line-1245"></span><span>                     </span><span class="hs-special">[</span><span> </span><span class="hs-string">&quot;normalizeCon: Cannot reify constructor &quot;</span><span> </span><span class="hs-operator">++</span><span> </span><span class="hs-identifier">nameBase</span><span> </span><span class="hs-identifier">n</span><span>
</span><span id="line-1246"></span><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;You are likely calling normalizeDec on GHC 7.6 or 7.8 on a data family&quot;</span><span>
</span><span id="line-1247"></span><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;whose type variables have been eta-reduced due to GHC Trac #9692.&quot;</span><span>
</span><span id="line-1248"></span><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;Unfortunately, without being able to reify the constructor's type,&quot;</span><span>
</span><span id="line-1249"></span><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;there is no way to recover the eta-reduced type variables in general.&quot;</span><span>
</span><span id="line-1250"></span><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;A recommended workaround is to use reifyDatatype instead.&quot;</span><span>
</span><span id="line-1251"></span><span>                     </span><span class="hs-special">]</span><span>
</span><span id="line-1252"></span><span>
</span><span id="line-1253"></span><span>          </span><span class="hs-comment">-- A very ad hoc way of determining if we need to perform some extra passes</span><span>
</span><span id="line-1254"></span><span>          </span><span class="hs-comment">-- to repair an eta-reduction bug for data family instances that only occurs</span><span>
</span><span id="line-1255"></span><span>          </span><span class="hs-comment">-- with GHC 7.6 and 7.8. We want to avoid doing these passes if at all possible,</span><span>
</span><span id="line-1256"></span><span>          </span><span class="hs-comment">-- since they require reifying extra information, and reifying during</span><span>
</span><span id="line-1257"></span><span>          </span><span class="hs-comment">-- normalization can be problematic for locally declared Template Haskell</span><span>
</span><span id="line-1258"></span><span>          </span><span class="hs-comment">-- splices (see ##22).</span><span>
</span><span id="line-1259"></span><span>          </span><span class="hs-identifier">mightHaveBeenEtaReduced</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Type</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Bool</span><span>
</span><span id="line-1260"></span><span>          </span><span class="hs-identifier">mightHaveBeenEtaReduced</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1261"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">unsnoc</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1262"></span><span>              </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">False</span><span>
</span><span id="line-1263"></span><span>              </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">initTs</span><span> </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">lastT</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1264"></span><span>                </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-identifier">lastT</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1265"></span><span>                  </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">False</span><span>
</span><span id="line-1266"></span><span>                  </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">n</span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">not</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">n</span><span> </span><span class="hs-special">`</span><span class="hs-identifier">elem</span><span class="hs-special">`</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">initTs</span><span class="hs-special">)</span><span>
</span><span id="line-1267"></span><span>
</span><span id="line-1268"></span><span>          </span><span class="hs-comment">-- If the list is empty returns 'Nothing', otherwise returns the</span><span>
</span><span id="line-1269"></span><span>          </span><span class="hs-comment">-- 'init' and the 'last'.</span><span>
</span><span id="line-1270"></span><span>          </span><span class="hs-identifier">unsnoc</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">a</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Maybe</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">NonEmptySnoc</span><span> </span><span class="hs-identifier">a</span><span class="hs-special">)</span><span>
</span><span id="line-1271"></span><span>          </span><span class="hs-identifier">unsnoc</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Nothing</span><span>
</span><span id="line-1272"></span><span>          </span><span class="hs-identifier">unsnoc</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">x</span><span class="hs-glyph">:</span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">unsnoc</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1273"></span><span>            </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">b</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-identifier">x</span><span class="hs-glyph">:</span><span class="hs-identifier">a</span><span class="hs-special">)</span><span> </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">b</span><span class="hs-special">)</span><span>
</span><span id="line-1274"></span><span>            </span><span class="hs-identifier">Nothing</span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span>    </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">x</span><span class="hs-special">)</span><span>
</span><span id="line-1275"></span><span>
</span><span id="line-1276"></span><span>          </span><span class="hs-comment">-- If a Type is a VarT, find Just its Name. Otherwise, return Nothing.</span><span>
</span><span id="line-1277"></span><span>          </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Maybe</span><span> </span><span class="hs-identifier">Name</span><span>
</span><span id="line-1278"></span><span>          </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">SigT</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-identifier">t</span><span>
</span><span id="line-1279"></span><span>          </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">VarT</span><span> </span><span class="hs-identifier">n</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">n</span><span>
</span><span id="line-1280"></span><span>          </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-identifier">_</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Nothing</span><span>
</span><span id="line-1281"></span><span>
</span><span id="line-1282"></span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">variant</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1283"></span><span>           </span><span class="hs-comment">-- On GHC 7.6 and 7.8, there's quite a bit of post-processing that</span><span>
</span><span id="line-1284"></span><span>           </span><span class="hs-comment">-- needs to be performed to work around an old bug that eta-reduces the</span><span>
</span><span id="line-1285"></span><span>           </span><span class="hs-comment">-- type patterns of data families (but only for reified data family instances).</span><span>
</span><span id="line-1286"></span><span>           </span><span class="hs-identifier">DataInstance</span><span>
</span><span id="line-1287"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">reifiedDec</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">mightHaveBeenEtaReduced</span><span> </span><span class="hs-identifier">instTys</span><span>
</span><span id="line-1288"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">dataFamCompatCase</span><span>
</span><span id="line-1289"></span><span>           </span><span class="hs-identifier">NewtypeInstance</span><span>
</span><span id="line-1290"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">reifiedDec</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">mightHaveBeenEtaReduced</span><span> </span><span class="hs-identifier">instTys</span><span>
</span><span id="line-1291"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">dataFamCompatCase</span><span>
</span><span id="line-1292"></span><span>           </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">defaultCase</span><span class="hs-cpp">
#else
</span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Con -&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679074308"><span class="hs-identifier hs-var">defaultCase</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-type">normalizeStrictness</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bang</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a></span><span>
</span><span id="line-1299"></span><span id="normalizeStrictness"><span class="annot"><span class="annottext">normalizeStrictness :: Bang -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-var hs-var">normalizeStrictness</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Bang</span></span><span> </span><span id="local-6989586621679074358"><span class="annot"><span class="annottext">SourceUnpackedness
</span><a href="#local-6989586621679074358"><span class="hs-identifier hs-var">upk</span></a></span></span><span> </span><span id="local-6989586621679074359"><span class="annot"><span class="annottext">SourceStrictness
</span><a href="#local-6989586621679074359"><span class="hs-identifier hs-var">str</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1300"></span><span>  </span><span class="annot"><span class="annottext">Unpackedness -&gt; Strictness -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SourceUnpackedness -&gt; Unpackedness
</span><a href="#local-6989586621679074360"><span class="hs-identifier hs-var">normalizeSourceUnpackedness</span></a></span><span> </span><span class="annot"><span class="annottext">SourceUnpackedness
</span><a href="#local-6989586621679074358"><span class="hs-identifier hs-var">upk</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1301"></span><span>                  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SourceStrictness -&gt; Strictness
</span><a href="#local-6989586621679074361"><span class="hs-identifier hs-var">normalizeSourceStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">SourceStrictness
</span><a href="#local-6989586621679074359"><span class="hs-identifier hs-var">str</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1302"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1303"></span><span>    </span><span class="annot"><a href="#local-6989586621679074360"><span class="hs-identifier hs-type">normalizeSourceUnpackedness</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">SourceUnpackedness</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Unpackedness"><span class="hs-identifier hs-type">Unpackedness</span></a></span><span>
</span><span id="line-1304"></span><span>    </span><span id="local-6989586621679074360"><span class="annot"><span class="annottext">normalizeSourceUnpackedness :: SourceUnpackedness -&gt; Unpackedness
</span><a href="#local-6989586621679074360"><span class="hs-identifier hs-var hs-var">normalizeSourceUnpackedness</span></a></span></span><span> </span><span class="annot"><span class="annottext">SourceUnpackedness
</span><span class="hs-identifier hs-var">NoSourceUnpackedness</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Unpackedness
</span><a href="Language.Haskell.TH.Datatype.html#UnspecifiedUnpackedness"><span class="hs-identifier hs-var">UnspecifiedUnpackedness</span></a></span><span>
</span><span id="line-1305"></span><span>    </span><span class="annot"><a href="#local-6989586621679074360"><span class="hs-identifier hs-var">normalizeSourceUnpackedness</span></a></span><span> </span><span class="annot"><span class="annottext">SourceUnpackedness
</span><span class="hs-identifier hs-var">SourceNoUnpack</span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Unpackedness
</span><a href="Language.Haskell.TH.Datatype.html#NoUnpack"><span class="hs-identifier hs-var">NoUnpack</span></a></span><span>
</span><span id="line-1306"></span><span>    </span><span class="annot"><a href="#local-6989586621679074360"><span class="hs-identifier hs-var">normalizeSourceUnpackedness</span></a></span><span> </span><span class="annot"><span class="annottext">SourceUnpackedness
</span><span class="hs-identifier hs-var">SourceUnpack</span></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Unpackedness
</span><a href="Language.Haskell.TH.Datatype.html#Unpack"><span class="hs-identifier hs-var">Unpack</span></a></span><span>
</span><span id="line-1307"></span><span>
</span><span id="line-1308"></span><span>    </span><span class="annot"><a href="#local-6989586621679074361"><span class="hs-identifier hs-type">normalizeSourceStrictness</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">SourceStrictness</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Strictness"><span class="hs-identifier hs-type">Strictness</span></a></span><span>
</span><span id="line-1309"></span><span>    </span><span id="local-6989586621679074361"><span class="annot"><span class="annottext">normalizeSourceStrictness :: SourceStrictness -&gt; Strictness
</span><a href="#local-6989586621679074361"><span class="hs-identifier hs-var hs-var">normalizeSourceStrictness</span></a></span></span><span> </span><span class="annot"><span class="annottext">SourceStrictness
</span><span class="hs-identifier hs-var">NoSourceStrictness</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Strictness
</span><a href="Language.Haskell.TH.Datatype.html#UnspecifiedStrictness"><span class="hs-identifier hs-var">UnspecifiedStrictness</span></a></span><span>
</span><span id="line-1310"></span><span>    </span><span class="annot"><a href="#local-6989586621679074361"><span class="hs-identifier hs-var">normalizeSourceStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">SourceStrictness
</span><span class="hs-identifier hs-var">SourceLazy</span></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Strictness
</span><a href="Language.Haskell.TH.Datatype.html#Lazy"><span class="hs-identifier hs-var">Lazy</span></a></span><span>
</span><span id="line-1311"></span><span>    </span><span class="annot"><a href="#local-6989586621679074361"><span class="hs-identifier hs-var">normalizeSourceStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">SourceStrictness
</span><span class="hs-identifier hs-var">SourceStrict</span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Strictness
</span><a href="Language.Haskell.TH.Datatype.html#Strict"><span class="hs-identifier hs-var">Strict</span></a></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Strict</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">FieldStrictness</span><span>
</span><span id="line-1314"></span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-identifier">IsStrict</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">isStrictAnnot</span><span>
</span><span id="line-1315"></span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-identifier">NotStrict</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">notStrictAnnot</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,7,0)
</span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-identifier">Unpacked</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">unpackedAnnot</span><span class="hs-cpp">
# endif
</span><span class="hs-cpp">#endif
</span><span>
</span><span id="line-1321"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeGadtC"><span class="hs-identifier hs-type">normalizeGadtC</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-1322"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>              </span><span class="annot"><span class="hs-comment">{- ^ Type constructor             -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1323"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span><span>   </span><span class="annot"><span class="hs-comment">{- ^ Type parameters              -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1324"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>            </span><span class="annot"><span class="hs-comment">{- ^ Argument types               -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1325"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>              </span><span class="annot"><span class="hs-comment">{- ^ Result kind                  -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1326"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span><span>   </span><span class="annot"><span class="hs-comment">{- ^ Constructor parameters       -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1327"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span>               </span><span class="annot"><span class="hs-comment">{- ^ Constructor context          -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1328"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>            </span><span class="annot"><span class="hs-comment">{- ^ Constructor names            -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1329"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>              </span><span class="annot"><span class="hs-comment">{- ^ Declared type of constructor -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1330"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>            </span><span class="annot"><span class="hs-comment">{- ^ Constructor field types      -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1331"></span><span>  </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">{- ^ Constructor field strictness -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1332"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorVariant"><span class="hs-identifier hs-type">ConstructorVariant</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1333"></span><span>                    </span><span class="annot"><span class="hs-comment">{- ^ Determine a constructor variant
                         from its 'Name' -}</span></span><span>              </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1335"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1336"></span><span id="normalizeGadtC"><span class="annot"><span class="annottext">normalizeGadtC :: Name
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; Type
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; [Name]
-&gt; Type
-&gt; [Type]
-&gt; [FieldStrictness]
-&gt; (Name -&gt; Q ConstructorVariant)
-&gt; Q [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#normalizeGadtC"><span class="hs-identifier hs-var hs-var">normalizeGadtC</span></a></span></span><span> </span><span id="local-6989586621679074368"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074368"><span class="hs-identifier hs-var">typename</span></a></span></span><span> </span><span id="local-6989586621679074369"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074369"><span class="hs-identifier hs-var">params</span></a></span></span><span> </span><span id="local-6989586621679074370"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074370"><span class="hs-identifier hs-var">instTys</span></a></span></span><span> </span><span id="local-6989586621679074371"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074371"><span class="hs-identifier hs-var">resKind</span></a></span></span><span> </span><span id="local-6989586621679074372"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074372"><span class="hs-identifier hs-var">tyvars</span></a></span></span><span> </span><span id="local-6989586621679074373"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074373"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679074374"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074374"><span class="hs-identifier hs-var">names</span></a></span></span><span> </span><span id="local-6989586621679074375"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074375"><span class="hs-identifier hs-var">innerType</span></a></span></span><span>
</span><span id="line-1337"></span><span>               </span><span id="local-6989586621679074376"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074376"><span class="hs-identifier hs-var">fields</span></a></span></span><span> </span><span id="local-6989586621679074377"><span class="annot"><span class="annottext">[FieldStrictness]
</span><a href="#local-6989586621679074377"><span class="hs-identifier hs-var">stricts</span></a></span></span><span> </span><span id="local-6989586621679074378"><span class="annot"><span class="annottext">Name -&gt; Q ConstructorVariant
</span><a href="#local-6989586621679074378"><span class="hs-identifier hs-var">getVariant</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1338"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span class="hs-comment">-- It's possible that the constructor has implicitly quantified type</span><span>
</span><span id="line-1339"></span><span>     </span><span class="hs-comment">-- variables, such as in the following example (from #58):</span><span>
</span><span id="line-1340"></span><span>     </span><span class="hs-comment">--</span><span>
</span><span id="line-1341"></span><span>     </span><span class="hs-comment">--   [d| data Foo where</span><span>
</span><span id="line-1342"></span><span>     </span><span class="hs-comment">--         MkFoo :: a -&gt; Foo |]</span><span>
</span><span id="line-1343"></span><span>     </span><span class="hs-comment">--</span><span>
</span><span id="line-1344"></span><span>     </span><span class="hs-comment">-- normalizeGadtC assumes that all type variables have binders, however,</span><span>
</span><span id="line-1345"></span><span>     </span><span class="hs-comment">-- so we use freeVariablesWellScoped to obtain the implicit type</span><span>
</span><span id="line-1346"></span><span>     </span><span class="hs-comment">-- variables' binders before proceeding.</span><span>
</span><span id="line-1347"></span><span>     </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074379"><span class="annot"><span class="annottext">implicitTyvars :: [TyVarBndrUnit]
</span><a href="#local-6989586621679074379"><span class="hs-identifier hs-var hs-var">implicitTyvars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [TyVarBndrUnit]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier hs-var">freeVariablesWellScoped</span></a></span><span>
</span><span id="line-1348"></span><span>                          </span><span class="hs-special">[</span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; [Type] -&gt; [Type] -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#curryType"><span class="hs-identifier hs-var">curryType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Specificity -&gt; [TyVarBndrUnit] -&gt; [TyVarBndrSpec]
forall newFlag oldFlag.
newFlag -&gt; [TyVarBndr_ oldFlag] -&gt; [TyVarBndr_ newFlag]
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#changeTVFlags"><span class="hs-identifier hs-var">changeTVFlags</span></a></span><span> </span><span class="annot"><span class="annottext">Specificity
</span><span class="hs-identifier hs-var">SpecifiedSpec</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074372"><span class="hs-identifier hs-var">tyvars</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1349"></span><span>                                     </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074373"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074376"><span class="hs-identifier hs-var">fields</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074375"><span class="hs-identifier hs-var">innerType</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1350"></span><span>         </span><span id="local-6989586621679074382"><span class="annot"><span class="annottext">allTyvars :: [TyVarBndrUnit]
</span><a href="#local-6989586621679074382"><span class="hs-identifier hs-var hs-var">allTyvars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074379"><span class="hs-identifier hs-var">implicitTyvars</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; [TyVarBndrUnit] -&gt; [TyVarBndrUnit]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074372"><span class="hs-identifier hs-var">tyvars</span></a></span><span>
</span><span id="line-1351"></span><span>
</span><span id="line-1352"></span><span>     </span><span class="hs-comment">-- Due to GHC Trac #13885, it's possible that the type variables bound by</span><span>
</span><span id="line-1353"></span><span>     </span><span class="hs-comment">-- a GADT constructor will shadow those that are bound by the data type.</span><span>
</span><span id="line-1354"></span><span>     </span><span class="hs-comment">-- This function assumes this isn't the case in certain parts (e.g., when</span><span>
</span><span id="line-1355"></span><span>     </span><span class="hs-comment">-- mergeArguments is invoked), so we do an alpha-renaming of the</span><span>
</span><span id="line-1356"></span><span>     </span><span class="hs-comment">-- constructor-bound variables before proceeding. See #36 for an example</span><span>
</span><span id="line-1357"></span><span>     </span><span class="hs-comment">-- of what can go wrong if this isn't done.</span><span>
</span><span id="line-1358"></span><span>     </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074385"><span class="annot"><span class="annottext">conBoundNames :: [Name]
</span><a href="#local-6989586621679074385"><span class="hs-identifier hs-var hs-var">conBoundNames</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1359"></span><span>           </span><span class="annot"><span class="annottext">(TyVarBndrUnit -&gt; [Name]) -&gt; [TyVarBndrUnit] -&gt; [Name]
forall (t :: * -&gt; *) a b. Foldable t =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b]
</span><span class="hs-identifier hs-var">concatMap</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679074387"><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679074387"><span class="hs-identifier hs-var">tvb</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit -&gt; Name
forall flag. TyVarBndr_ flag -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679074387"><span class="hs-identifier hs-var">tvb</span></a></span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyVarBndrUnit -&gt; Type
forall flag. TyVarBndr_ flag -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvKind"><span class="hs-identifier hs-var">tvKind</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679074387"><span class="hs-identifier hs-var">tvb</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074382"><span class="hs-identifier hs-var">allTyvars</span></a></span><span>
</span><span id="line-1360"></span><span>     </span><span id="local-6989586621679074389"><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074389"><span class="hs-identifier hs-var">conSubst</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Map Name (Q Name) -&gt; Q (Map Name Name)
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; Map Name (m a) -&gt; m (Map Name a)
</span><span class="hs-identifier hs-var">T.sequence</span></span><span> </span><span class="annot"><span class="annottext">(Map Name (Q Name) -&gt; Q (Map Name Name))
-&gt; Map Name (Q Name) -&gt; Q (Map Name Name)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[(Name, Q Name)] -&gt; Map Name (Q Name)
forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.fromList</span></span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074392"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q Name
forall (m :: * -&gt; *). Quote m =&gt; String -&gt; m Name
</span><span class="hs-identifier hs-var">newName</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074392"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1361"></span><span>                                           </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679074392"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074392"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074385"><span class="hs-identifier hs-var">conBoundNames</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1362"></span><span>     </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074394"><span class="annot"><span class="annottext">conSubst' :: Map Name Type
</span><a href="#local-6989586621679074394"><span class="hs-identifier hs-var hs-var">conSubst'</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Type) -&gt; Map Name Name -&gt; Map Name Type
forall a b. (a -&gt; b) -&gt; Map Name a -&gt; Map Name b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074389"><span class="hs-identifier hs-var">conSubst</span></a></span><span>
</span><span id="line-1363"></span><span>         </span><span id="local-6989586621679074400"><span class="annot"><span class="annottext">renamedTyvars :: [TyVarBndrUnit]
</span><a href="#local-6989586621679074400"><span class="hs-identifier hs-var hs-var">renamedTyvars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1364"></span><span>           </span><span class="annot"><span class="annottext">(TyVarBndrUnit -&gt; TyVarBndrUnit)
-&gt; [TyVarBndrUnit] -&gt; [TyVarBndrUnit]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Name -&gt; TyVarBndrUnit)
-&gt; (Name -&gt; Type -&gt; TyVarBndrUnit)
-&gt; TyVarBndrUnit
-&gt; TyVarBndrUnit
forall r flag.
(Name -&gt; r) -&gt; (Name -&gt; Type -&gt; r) -&gt; TyVarBndr_ flag -&gt; r
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#elimTV"><span class="hs-identifier hs-var">elimTV</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679074401"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074401"><span class="hs-identifier hs-var">n</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; TyVarBndrUnit
forall flag. DefaultBndrFlag flag =&gt; Name -&gt; TyVarBndr flag
</span><span class="hs-identifier hs-var">plainTV</span></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074389"><span class="hs-identifier hs-var">conSubst</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Name -&gt; Name -&gt; Name
forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><span class="hs-operator hs-var">Map.!</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074401"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1365"></span><span>                       </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679074404"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074404"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679074405"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074405"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; TyVarBndrUnit
forall flag. DefaultBndrFlag flag =&gt; Name -&gt; Type -&gt; TyVarBndr flag
</span><span class="hs-identifier hs-var">kindedTV</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074389"><span class="hs-identifier hs-var">conSubst</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Name -&gt; Name -&gt; Name
forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><span class="hs-operator hs-var">Map.!</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074404"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1366"></span><span>                                         </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074394"><span class="hs-identifier hs-var">conSubst'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074405"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074382"><span class="hs-identifier hs-var">allTyvars</span></a></span><span>
</span><span id="line-1367"></span><span>         </span><span id="local-6989586621679074408"><span class="annot"><span class="annottext">renamedContext :: [Type]
</span><a href="#local-6989586621679074408"><span class="hs-identifier hs-var hs-var">renamedContext</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; [Type] -&gt; [Type]
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074394"><span class="hs-identifier hs-var">conSubst'</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074373"><span class="hs-identifier hs-var">context</span></a></span><span>
</span><span id="line-1368"></span><span>         </span><span id="local-6989586621679074410"><span class="annot"><span class="annottext">renamedInnerType :: Type
</span><a href="#local-6989586621679074410"><span class="hs-identifier hs-var hs-var">renamedInnerType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074394"><span class="hs-identifier hs-var">conSubst'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074375"><span class="hs-identifier hs-var">innerType</span></a></span><span>
</span><span id="line-1369"></span><span>         </span><span id="local-6989586621679074413"><span class="annot"><span class="annottext">renamedFields :: [Type]
</span><a href="#local-6989586621679074413"><span class="hs-identifier hs-var hs-var">renamedFields</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; [Type] -&gt; [Type]
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074394"><span class="hs-identifier hs-var">conSubst'</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074376"><span class="hs-identifier hs-var">fields</span></a></span><span>
</span><span id="line-1370"></span><span>
</span><span id="line-1371"></span><span>     </span><span id="local-6989586621679074414"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074414"><span class="hs-identifier hs-var">innerType'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074410"><span class="hs-identifier hs-var">renamedInnerType</span></a></span><span>
</span><span id="line-1372"></span><span>
</span><span id="line-1373"></span><span>     </span><span class="hs-comment">-- If the return type in the data constructor is of the form `T :: K`, then</span><span>
</span><span id="line-1374"></span><span>     </span><span class="hs-comment">-- return (T, Just K, Just resKind), where `resKind` is the result kind of</span><span>
</span><span id="line-1375"></span><span>     </span><span class="hs-comment">-- the parent data type. Otherwise, return (T :: K, Nothing, Nothing). The</span><span>
</span><span id="line-1376"></span><span>     </span><span class="hs-comment">-- two `Maybe` values are passed below to `mergeArgumentKinds` such that if</span><span>
</span><span id="line-1377"></span><span>     </span><span class="hs-comment">-- they are both `Just`, then we will attempt to unify `K` and `resKind`.</span><span>
</span><span id="line-1378"></span><span>     </span><span class="hs-comment">-- See step (2) of Note [Tricky result kinds].</span><span>
</span><span id="line-1379"></span><span>     </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074415"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074415"><span class="hs-identifier hs-var">innerType''</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074416"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074416"><span class="hs-identifier hs-var">mbInnerResKind</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074417"><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074417"><span class="hs-identifier hs-var">mbResKind</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1380"></span><span>           </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074414"><span class="hs-identifier hs-var">innerType'</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1381"></span><span>             </span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679074418"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074418"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679074419"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074419"><span class="hs-identifier hs-var">innerResKind</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074418"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe Type
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074419"><span class="hs-identifier hs-var">innerResKind</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe Type
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074371"><span class="hs-identifier hs-var">resKind</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1382"></span><span>             </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074414"><span class="hs-identifier hs-var">innerType'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Maybe Type
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Maybe Type
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-1383"></span><span>
</span><span id="line-1384"></span><span>     </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type -&gt; NonEmpty Type
</span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074415"><span class="hs-identifier hs-var">innerType''</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1385"></span><span>       </span><span class="annot"><span class="hs-identifier hs-type">ConT</span></span><span> </span><span id="local-6989586621679074420"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074420"><span class="hs-identifier hs-var">innerTyCon</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679074421"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074421"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074368"><span class="hs-identifier hs-var">typename</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074420"><span class="hs-identifier hs-var">innerTyCon</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1386"></span><span>
</span><span id="line-1387"></span><span>         </span><span class="hs-keyword">let</span><span> </span><span class="hs-comment">-- See step (2) of Note [Tricky result kinds].</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span>             </span><span id="local-6989586621679074422"><span class="annot"><span class="annottext">instTys' :: [Type]
</span><a href="#local-6989586621679074422"><span class="hs-identifier hs-var hs-var">instTys'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Type -&gt; [Type]
forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074417"><span class="hs-identifier hs-var">mbResKind</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; [Type]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074370"><span class="hs-identifier hs-var">instTys</span></a></span><span>
</span><span id="line-1390"></span><span>             </span><span id="local-6989586621679074424"><span class="annot"><span class="annottext">ts' :: [Type]
</span><a href="#local-6989586621679074424"><span class="hs-identifier hs-var hs-var">ts'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Type -&gt; [Type]
forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679074416"><span class="hs-identifier hs-var">mbInnerResKind</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; [Type]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074421"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-cpp">
#else
</span><span>             </span><span class="hs-identifier">instTys'</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">instTys</span><span>
</span><span id="line-1393"></span><span>             </span><span class="hs-identifier">ts'</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">ts</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1396"></span><span>             </span><span class="hs-special">(</span><span id="local-6989586621679074425"><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074425"><span class="hs-identifier hs-var">substName</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074426"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074426"><span class="hs-identifier hs-var">context1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1397"></span><span>               </span><span class="annot"><span class="annottext">Map Name Type
-&gt; Map Name Type
-&gt; (Map Name Name, [Type])
-&gt; (Map Name Name, [Type])
</span><a href="Language.Haskell.TH.Datatype.html#closeOverKinds"><span class="hs-identifier hs-var">closeOverKinds</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; Map Name Type
forall flag. [TyVarBndr_ flag] -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTvbs"><span class="hs-identifier hs-var">kindsOfFVsOfTvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074400"><span class="hs-identifier hs-var">renamedTyvars</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1398"></span><span>                              </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; Map Name Type
forall flag. [TyVarBndr_ flag] -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTvbs"><span class="hs-identifier hs-var">kindsOfFVsOfTvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074369"><span class="hs-identifier hs-var">params</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1399"></span><span>                              </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; (Map Name Name, [Type])
</span><a href="Language.Haskell.TH.Datatype.html#mergeArguments"><span class="hs-identifier hs-var">mergeArguments</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074422"><span class="hs-identifier hs-var">instTys'</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074424"><span class="hs-identifier hs-var">ts'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1400"></span><span>             </span><span id="local-6989586621679074430"><span class="annot"><span class="annottext">subst :: Map Name Type
</span><a href="#local-6989586621679074430"><span class="hs-identifier hs-var hs-var">subst</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Type) -&gt; Map Name Name -&gt; Map Name Type
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074425"><span class="hs-identifier hs-var">substName</span></a></span><span>
</span><span id="line-1401"></span><span>             </span><span id="local-6989586621679074432"><span class="annot"><span class="annottext">exTyvars :: [TyVarBndrUnit]
</span><a href="#local-6989586621679074432"><span class="hs-identifier hs-var hs-var">exTyvars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679074433"><span class="hs-identifier hs-var">tv</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679074433"><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679074433"><span class="hs-identifier hs-var">tv</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074400"><span class="hs-identifier hs-var">renamedTyvars</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Bool
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">Map.notMember</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyVarBndrUnit -&gt; Name
forall flag. TyVarBndr_ flag -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679074433"><span class="hs-identifier hs-var">tv</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074430"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1402"></span><span>
</span><span id="line-1403"></span><span>             </span><span class="hs-comment">-- The use of substTyVarBndrKinds below will never capture, as the</span><span>
</span><span id="line-1404"></span><span>             </span><span class="hs-comment">-- range of the substitution will always use distinct names from</span><span>
</span><span id="line-1405"></span><span>             </span><span class="hs-comment">-- exTyvars due to the alpha-renaming pass above.</span><span>
</span><span id="line-1406"></span><span>             </span><span id="local-6989586621679074435"><span class="annot"><span class="annottext">exTyvars' :: [TyVarBndrUnit]
</span><a href="#local-6989586621679074435"><span class="hs-identifier hs-var hs-var">exTyvars'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; [TyVarBndrUnit] -&gt; [TyVarBndrUnit]
forall flag.
Map Name Type -&gt; [TyVarBndr_ flag] -&gt; [TyVarBndr_ flag]
</span><a href="Language.Haskell.TH.Datatype.html#substTyVarBndrKinds"><span class="hs-identifier hs-var">substTyVarBndrKinds</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074430"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074432"><span class="hs-identifier hs-var">exTyvars</span></a></span><span>
</span><span id="line-1407"></span><span>             </span><span id="local-6989586621679074439"><span class="annot"><span class="annottext">context2 :: [Type]
</span><a href="#local-6989586621679074439"><span class="hs-identifier hs-var hs-var">context2</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; [Type] -&gt; [Type]
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span>   </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074430"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074426"><span class="hs-identifier hs-var">context1</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; [Type]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074408"><span class="hs-identifier hs-var">renamedContext</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1408"></span><span>             </span><span id="local-6989586621679074442"><span class="annot"><span class="annottext">fields' :: [Type]
</span><a href="#local-6989586621679074442"><span class="hs-identifier hs-var hs-var">fields'</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; [Type] -&gt; [Type]
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span>   </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074430"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074413"><span class="hs-identifier hs-var">renamedFields</span></a></span><span>
</span><span id="line-1409"></span><span>         </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">[Q ConstructorInfo] -&gt; Q [ConstructorInfo]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Name
-&gt; [TyVarBndrUnit]
-&gt; [Type]
-&gt; [Type]
-&gt; [FieldStrictness]
-&gt; ConstructorVariant
-&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074443"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074435"><span class="hs-identifier hs-var">exTyvars'</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074439"><span class="hs-identifier hs-var">context2</span></a></span><span>
</span><span id="line-1410"></span><span>                                       </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074442"><span class="hs-identifier hs-var">fields'</span></a></span><span> </span><span class="annot"><span class="annottext">[FieldStrictness]
</span><a href="#local-6989586621679074377"><span class="hs-identifier hs-var">stricts</span></a></span><span> </span><span class="annot"><span class="annottext">(ConstructorVariant -&gt; ConstructorInfo)
-&gt; Q ConstructorVariant -&gt; Q ConstructorInfo
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Q ConstructorVariant
</span><a href="#local-6989586621679074444"><span class="hs-identifier hs-var">variantQ</span></a></span><span>
</span><span id="line-1411"></span><span>                     </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679074443"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074443"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074374"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1412"></span><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074444"><span class="annot"><span class="annottext">variantQ :: Q ConstructorVariant
</span><a href="#local-6989586621679074444"><span class="hs-identifier hs-var hs-var">variantQ</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q ConstructorVariant
</span><a href="#local-6989586621679074378"><span class="hs-identifier hs-var">getVariant</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074443"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1413"></span><span>                     </span><span class="hs-special">]</span><span>
</span><span id="line-1414"></span><span>
</span><span id="line-1415"></span><span>       </span><span class="annot"><span class="annottext">NonEmpty Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q [ConstructorInfo]
forall a. String -&gt; Q a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;normalizeGadtC: Expected type constructor application&quot;</span></span><span>
</span><span id="line-1416"></span><span>
</span><span id="line-1417"></span><span class="hs-comment">{-
Extend a type variable renaming subtitution and a list of equality
predicates by looking into kind information as much as possible.

Why is this necessary? Consider the following example:

  data (a1 :: k1) :~: (b1 :: k1) where
    Refl :: forall k2 (a2 :: k2). a2 :~: a2

After an initial call to mergeArguments, we will have the following
substitution and context:

* Substitution: [a2 :-&gt; a1]
* Context: (a2 ~ b1)

We shouldn't stop there, however! We determine the existentially quantified
type variables of a constructor by filtering out those constructor-bound
variables which do not appear in the substitution that mergeArguments
returns. In this example, Refl's bound variables are k2 and a2. a2 appears
in the returned substitution, but k2 does not, which means that we would
mistakenly conclude that k2 is existential!

Although we don't have the full power of kind inference to guide us here, we
can at least do the next best thing. Generally, the datatype-bound type
variables and the constructor type variable binders contain all of the kind
information we need, so we proceed as follows:

1. Construct a map from each constructor-bound variable to its kind. (Do the
   same for each datatype-bound variable). These maps are the first and second
   arguments to closeOverKinds, respectively.
2. Call mergeArguments once on the GADT return type and datatype-bound types,
   and pass that in as the third argument to closeOverKinds.
3. For each name-name pair in the supplied substitution, check if the first and
   second names map to kinds in the first and second kind maps in
   closeOverKinds, respectively. If so, associate the first kind with the
   second kind.
4. For each kind association discovered in part (3), call mergeArguments
   on the lists of kinds. This will yield a kind substitution and kind
   equality context.
5. If the kind substitution is non-empty, then go back to step (3) and repeat
   the process on the new kind substitution and context.

   Otherwise, if the kind substitution is empty, then we have reached a fixed-
   point (i.e., we have closed over the kinds), so proceed.
6. Union up all of the substitutions and contexts, and return those.

This algorithm is not perfect, as it will only catch everything if all of
the kinds are explicitly mentioned somewhere (and not left quantified
implicitly). Thankfully, reifying data types via Template Haskell tends to
yield a healthy amount of kind signatures, so this works quite well in
practice.
-}</span><span>
</span><span id="line-1469"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#closeOverKinds"><span class="hs-identifier hs-type">closeOverKinds</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1470"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1471"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span class="hs-special">)</span><span>
</span><span id="line-1472"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span class="hs-special">)</span><span>
</span><span id="line-1473"></span><span id="closeOverKinds"><span class="annot"><span class="annottext">closeOverKinds :: Map Name Type
-&gt; Map Name Type
-&gt; (Map Name Name, [Type])
-&gt; (Map Name Name, [Type])
</span><a href="Language.Haskell.TH.Datatype.html#closeOverKinds"><span class="hs-identifier hs-var hs-var">closeOverKinds</span></a></span></span><span> </span><span id="local-6989586621679074445"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074445"><span class="hs-identifier hs-var">domainFVKinds</span></a></span></span><span> </span><span id="local-6989586621679074446"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074446"><span class="hs-identifier hs-var">rangeFVKinds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Map Name Name, [Type]) -&gt; (Map Name Name, [Type])
</span><a href="#local-6989586621679074447"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-1474"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1475"></span><span>    </span><span class="annot"><a href="#local-6989586621679074447"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span class="hs-special">)</span><span>
</span><span id="line-1476"></span><span>    </span><span id="local-6989586621679074447"><span class="annot"><span class="annottext">go :: (Map Name Name, [Type]) -&gt; (Map Name Name, [Type])
</span><a href="#local-6989586621679074447"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074448"><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074448"><span class="hs-identifier hs-var">subst</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074449"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074449"><span class="hs-identifier hs-var">context</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1477"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074450"><span class="annot"><span class="annottext">substList :: [(Name, Name)]
</span><a href="#local-6989586621679074450"><span class="hs-identifier hs-var hs-var">substList</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Name -&gt; [(Name, Name)]
forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">Map.toList</span></span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074448"><span class="hs-identifier hs-var">subst</span></a></span><span>
</span><span id="line-1478"></span><span>          </span><span class="hs-special">(</span><span id="local-6989586621679074458"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074458"><span class="hs-identifier hs-var">kindsInner</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074459"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074459"><span class="hs-identifier hs-var">kindsOuter</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1479"></span><span>            </span><span class="annot"><span class="annottext">[(Type, Type)] -&gt; ([Type], [Type])
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="annot"><span class="annottext">([(Type, Type)] -&gt; ([Type], [Type]))
-&gt; [(Type, Type)] -&gt; ([Type], [Type])
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-1480"></span><span>            </span><span class="annot"><span class="annottext">((Name, Name) -&gt; Maybe (Type, Type))
-&gt; [(Name, Name)] -&gt; [(Type, Type)]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679074460"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074460"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074461"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074461"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679074462"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074462"><span class="hs-identifier hs-var">d'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Maybe Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Map.lookup</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074460"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074445"><span class="hs-identifier hs-var">domainFVKinds</span></a></span><span>
</span><span id="line-1481"></span><span>                                    </span><span id="local-6989586621679074464"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074464"><span class="hs-identifier hs-var">r'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Maybe Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Map.lookup</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074461"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074446"><span class="hs-identifier hs-var">rangeFVKinds</span></a></span><span>
</span><span id="line-1482"></span><span>                                    </span><span class="annot"><span class="annottext">(Type, Type) -&gt; Maybe (Type, Type)
forall a. a -&gt; Maybe a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074462"><span class="hs-identifier hs-var">d'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074464"><span class="hs-identifier hs-var">r'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1483"></span><span>                     </span><span class="annot"><span class="annottext">[(Name, Name)]
</span><a href="#local-6989586621679074450"><span class="hs-identifier hs-var">substList</span></a></span><span>
</span><span id="line-1484"></span><span>          </span><span class="hs-special">(</span><span id="local-6989586621679074465"><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074465"><span class="hs-identifier hs-var">kindSubst</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074466"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074466"><span class="hs-identifier hs-var">kindContext</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; (Map Name Name, [Type])
</span><a href="Language.Haskell.TH.Datatype.html#mergeArgumentKinds"><span class="hs-identifier hs-var">mergeArgumentKinds</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074459"><span class="hs-identifier hs-var">kindsOuter</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074458"><span class="hs-identifier hs-var">kindsInner</span></a></span><span>
</span><span id="line-1485"></span><span>          </span><span class="hs-special">(</span><span id="local-6989586621679074468"><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074468"><span class="hs-identifier hs-var">restSubst</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074469"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074469"><span class="hs-identifier hs-var">restContext</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1486"></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Map Name Name -&gt; Bool
forall k a. Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">Map.null</span></span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074465"><span class="hs-identifier hs-var">kindSubst</span></a></span><span> </span><span class="hs-comment">-- Fixed-point calculation</span><span>
</span><span id="line-1487"></span><span>                 </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1488"></span><span>                 </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">(Map Name Name, [Type]) -&gt; (Map Name Name, [Type])
</span><a href="#local-6989586621679074447"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074465"><span class="hs-identifier hs-var">kindSubst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074466"><span class="hs-identifier hs-var">kindContext</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1489"></span><span>          </span><span id="local-6989586621679074474"><span class="annot"><span class="annottext">finalSubst :: Map Name Name
</span><a href="#local-6989586621679074474"><span class="hs-identifier hs-var hs-var">finalSubst</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Map Name Name] -&gt; Map Name Name
forall (f :: * -&gt; *) k a.
(Foldable f, Ord k) =&gt;
f (Map k a) -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.unions</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074448"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074465"><span class="hs-identifier hs-var">kindSubst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074468"><span class="hs-identifier hs-var">restSubst</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1490"></span><span>          </span><span id="local-6989586621679074478"><span class="annot"><span class="annottext">finalContext :: [Type]
</span><a href="#local-6989586621679074478"><span class="hs-identifier hs-var hs-var">finalContext</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type]
forall a. Eq a =&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">nub</span></span><span> </span><span class="annot"><span class="annottext">([Type] -&gt; [Type]) -&gt; [Type] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[[Type]] -&gt; [Type]
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074449"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074466"><span class="hs-identifier hs-var">kindContext</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074469"><span class="hs-identifier hs-var">restContext</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1491"></span><span>            </span><span class="hs-comment">-- Use `nub` here in an effort to minimize the number of</span><span>
</span><span id="line-1492"></span><span>            </span><span class="hs-comment">-- redundant equality constraints in the returned context.</span><span>
</span><span id="line-1493"></span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074474"><span class="hs-identifier hs-var">finalSubst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074478"><span class="hs-identifier hs-var">finalContext</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1494"></span><span>
</span><span id="line-1495"></span><span class="hs-comment">-- Look into a list of types and map each free variable name to its kind.</span><span>
</span><span id="line-1496"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTypes"><span class="hs-identifier hs-type">kindsOfFVsOfTypes</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1497"></span><span id="kindsOfFVsOfTypes"><span class="annot"><span class="annottext">kindsOfFVsOfTypes :: [Type] -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTypes"><span class="hs-identifier hs-var hs-var">kindsOfFVsOfTypes</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Map Name Type) -&gt; [Type] -&gt; Map Name Type
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; [a] -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074480"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-1498"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1499"></span><span>    </span><span class="annot"><a href="#local-6989586621679074480"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1500"></span><span>    </span><span id="local-6989586621679074480"><span class="annot"><span class="annottext">go :: Type -&gt; Map Name Type
</span><a href="#local-6989586621679074480"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679074481"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074481"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621679074482"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074482"><span class="hs-identifier hs-var">t2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074480"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074481"><span class="hs-identifier hs-var">t1</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; Map k a -&gt; Map k a -&gt; Map k a
</span><span class="hs-operator hs-var">`Map.union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074480"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074482"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-1501"></span><span>    </span><span class="annot"><a href="#local-6989586621679074480"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679074484"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074484"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679074485"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074485"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1502"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074486"><span class="annot"><span class="annottext">kSigs :: Map Name Type
</span><a href="#local-6989586621679074486"><span class="hs-identifier hs-var hs-var">kSigs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span>                  </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074480"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074485"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-cpp">
#else
</span><span>                  </span><span class="hs-identifier">Map.empty</span><span class="hs-cpp">
#endif
</span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074484"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1509"></span><span>           </span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679074487"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074487"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.insert</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074487"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074485"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074486"><span class="hs-identifier hs-var">kSigs</span></a></span><span>
</span><span id="line-1510"></span><span>           </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074480"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074484"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; Map k a -&gt; Map k a -&gt; Map k a
</span><span class="hs-operator hs-var">`Map.union`</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074486"><span class="hs-identifier hs-var">kSigs</span></a></span><span>
</span><span id="line-1511"></span><span>
</span><span id="line-1512"></span><span>    </span><span class="annot"><a href="#local-6989586621679074480"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type
forall a. a
</span><a href="#local-6989586621679074490"><span class="hs-identifier hs-var">forallError</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,16,0)
</span><span>    </span><span class="annot"><a href="#local-6989586621679074480"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallVisT</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type
forall a. a
</span><a href="#local-6989586621679074490"><span class="hs-identifier hs-var">forallError</span></a></span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1517"></span><span>    </span><span class="annot"><a href="#local-6989586621679074480"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span>
</span><span id="line-1518"></span><span>
</span><span id="line-1519"></span><span>    </span><span id="local-6989586621679072558"><span class="annot"><a href="#local-6989586621679074490"><span class="hs-identifier hs-type">forallError</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679072558"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-1520"></span><span>    </span><span id="local-6989586621679074490"><span class="annot"><span class="annottext">forallError :: forall a. a
</span><a href="#local-6989586621679074490"><span class="hs-identifier hs-var hs-var">forallError</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; a
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;`forall` type used in data family pattern&quot;</span></span><span>
</span><span id="line-1521"></span><span>
</span><span id="line-1522"></span><span class="hs-comment">-- Look into a list of type variable binder and map each free variable name</span><span>
</span><span id="line-1523"></span><span class="hs-comment">-- to its kind (also map the names that KindedTVs bind to their respective</span><span>
</span><span id="line-1524"></span><span class="hs-comment">-- kinds). This function considers the kind of a PlainTV to be *.</span><span>
</span><span id="line-1525"></span><span id="local-6989586621679072536"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTvbs"><span class="hs-identifier hs-type">kindsOfFVsOfTvbs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072536"><span class="hs-identifier hs-type">flag</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span></span><span>
</span><span id="line-1526"></span><span id="kindsOfFVsOfTvbs"><span class="annot"><span class="annottext">kindsOfFVsOfTvbs :: forall flag. [TyVarBndr_ flag] -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTvbs"><span class="hs-identifier hs-var hs-var">kindsOfFVsOfTvbs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyVarBndr_ flag -&gt; Map Name Type)
-&gt; [TyVarBndr_ flag] -&gt; Map Name Type
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; [a] -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr_ flag -&gt; Map Name Type
forall flag. TyVarBndr_ flag -&gt; Map Name Type
</span><a href="#local-6989586621679074496"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-1527"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1528"></span><span>    </span><span id="local-6989586621679072561"><span class="annot"><a href="#local-6989586621679074496"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072561"><span class="hs-identifier hs-type">flag</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span></span><span>
</span><span id="line-1529"></span><span>    </span><span id="local-6989586621679074496"><span class="annot"><span class="annottext">go :: forall flag. TyVarBndr_ flag -&gt; Map Name Type
</span><a href="#local-6989586621679074496"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Map Name Type)
-&gt; (Name -&gt; Type -&gt; Map Name Type)
-&gt; TyVarBndr_ flag
-&gt; Map Name Type
forall r flag.
(Name -&gt; r) -&gt; (Name -&gt; Type -&gt; r) -&gt; TyVarBndr_ flag -&gt; r
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#elimTV"><span class="hs-identifier hs-var">elimTV</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679074498"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074498"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Map Name Type
forall k a. k -&gt; a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.singleton</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074498"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">starK</span></span><span class="hs-special">)</span><span>
</span><span id="line-1530"></span><span>                </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679074500"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074500"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679074501"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074501"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074502"><span class="annot"><span class="annottext">kSigs :: Map Name Type
</span><a href="#local-6989586621679074502"><span class="hs-identifier hs-var hs-var">kSigs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span>                                     </span><span class="annot"><span class="annottext">[Type] -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTypes"><span class="hs-identifier hs-var">kindsOfFVsOfTypes</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074501"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">]</span><span class="hs-cpp">
#else
</span><span>                                     </span><span class="hs-identifier">Map.empty</span><span class="hs-cpp">
#endif
</span><span>                         </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.insert</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074500"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074501"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074502"><span class="hs-identifier hs-var">kSigs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1537"></span><span>
</span><span id="line-1538"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#mergeArguments"><span class="hs-identifier hs-type">mergeArguments</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-1539"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">{- ^ outer parameters                    -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1540"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">{- ^ inner parameters (specializations ) -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1541"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span class="hs-special">)</span><span>
</span><span id="line-1542"></span><span id="mergeArguments"><span class="annot"><span class="annottext">mergeArguments :: [Type] -&gt; [Type] -&gt; (Map Name Name, [Type])
</span><a href="Language.Haskell.TH.Datatype.html#mergeArguments"><span class="hs-identifier hs-var hs-var">mergeArguments</span></a></span></span><span> </span><span id="local-6989586621679074503"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074503"><span class="hs-identifier hs-var">ns</span></a></span></span><span> </span><span id="local-6989586621679074504"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074504"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((Type, Type)
 -&gt; (Map Name Name, [Type]) -&gt; (Map Name Name, [Type]))
-&gt; (Map Name Name, [Type])
-&gt; [(Type, Type)]
-&gt; (Map Name Name, [Type])
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; (Map Name Name, [Type]) -&gt; (Map Name Name, [Type])
</span><a href="#local-6989586621679074506"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; [(Type, Type)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074503"><span class="hs-identifier hs-var">ns</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074504"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1543"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1544"></span><span>
</span><span id="line-1545"></span><span>    </span><span id="local-6989586621679074506"><span class="annot"><span class="annottext">aux :: (Type, Type) -&gt; (Map Name Name, [Type]) -&gt; (Map Name Name, [Type])
</span><a href="#local-6989586621679074506"><span class="hs-identifier hs-var hs-var">aux</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074512"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074512"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`AppT`</span></span><span> </span><span id="local-6989586621679074513"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074513"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074514"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074514"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`AppT`</span></span><span> </span><span id="local-6989586621679074515"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074515"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679074516"><span class="annot"><span class="annottext">(Map Name Name, [Type])
</span><a href="#local-6989586621679074516"><span class="hs-identifier hs-var">sc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1546"></span><span>      </span><span class="annot"><span class="annottext">(Type, Type) -&gt; (Map Name Name, [Type]) -&gt; (Map Name Name, [Type])
</span><a href="#local-6989586621679074506"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074513"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074515"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type, Type) -&gt; (Map Name Name, [Type]) -&gt; (Map Name Name, [Type])
</span><a href="#local-6989586621679074506"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074512"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074514"><span class="hs-identifier hs-var">g</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Map Name Name, [Type])
</span><a href="#local-6989586621679074516"><span class="hs-identifier hs-var">sc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1547"></span><span>
</span><span id="line-1548"></span><span>    </span><span class="annot"><a href="#local-6989586621679074506"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679074517"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074517"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679074518"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074518"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074519"><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074519"><span class="hs-identifier hs-var">subst</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074520"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074520"><span class="hs-identifier hs-var">context</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1549"></span><span>      </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074518"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1550"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679074521"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074521"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074521"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074517"><span class="hs-identifier hs-var">n</span></a></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074519"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074520"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1551"></span><span>                   </span><span class="hs-comment">-- If the two variables are the same, don't bother extending</span><span>
</span><span id="line-1552"></span><span>                   </span><span class="hs-comment">-- the substitution. (This is purely an optimization.)</span><span>
</span><span id="line-1553"></span><span>               </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679074522"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074522"><span class="hs-identifier hs-var">n'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Name -&gt; Maybe Name
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Map.lookup</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074521"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074519"><span class="hs-identifier hs-var">subst</span></a></span><span>
</span><span id="line-1554"></span><span>               </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074517"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074522"><span class="hs-identifier hs-var">n'</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074519"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074520"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1555"></span><span>                   </span><span class="hs-comment">-- If a variable is already in a substitution and it maps</span><span>
</span><span id="line-1556"></span><span>                   </span><span class="hs-comment">-- to the variable that we are trying to unify with, then</span><span>
</span><span id="line-1557"></span><span>                   </span><span class="hs-comment">-- leave the context alone. (Not doing so caused #46.)</span><span>
</span><span id="line-1558"></span><span>               </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Name -&gt; Bool
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">Map.notMember</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074521"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074519"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Map Name Name -&gt; Map Name Name
forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.insert</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074521"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074517"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074519"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074520"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1559"></span><span>        </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679074519"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#equalPred"><span class="hs-identifier hs-var">equalPred</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074517"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074518"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Type] -&gt; [Type]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074520"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1560"></span><span>
</span><span id="line-1561"></span><span>    </span><span class="annot"><a href="#local-6989586621679074506"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679074523"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074523"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074524"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074524"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679074525"><span class="annot"><span class="annottext">(Map Name Name, [Type])
</span><a href="#local-6989586621679074525"><span class="hs-identifier hs-var">sc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; (Map Name Name, [Type]) -&gt; (Map Name Name, [Type])
</span><a href="#local-6989586621679074506"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074523"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074524"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Map Name Name, [Type])
</span><a href="#local-6989586621679074525"><span class="hs-identifier hs-var">sc</span></a></span><span> </span><span class="hs-comment">-- learn about kinds??</span><span>
</span><span id="line-1562"></span><span>    </span><span class="hs-comment">-- This matches *after* VarT so that we can compute a substitution</span><span>
</span><span id="line-1563"></span><span>    </span><span class="hs-comment">-- that includes the kind signature.</span><span>
</span><span id="line-1564"></span><span>    </span><span class="annot"><a href="#local-6989586621679074506"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074526"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074526"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679074527"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074527"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679074528"><span class="annot"><span class="annottext">(Map Name Name, [Type])
</span><a href="#local-6989586621679074528"><span class="hs-identifier hs-var">sc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; (Map Name Name, [Type]) -&gt; (Map Name Name, [Type])
</span><a href="#local-6989586621679074506"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074526"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074527"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Map Name Name, [Type])
</span><a href="#local-6989586621679074528"><span class="hs-identifier hs-var">sc</span></a></span><span>
</span><span id="line-1565"></span><span>
</span><span id="line-1566"></span><span>    </span><span class="annot"><a href="#local-6989586621679074506"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="annot"><span class="annottext">(Type, Type)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679074529"><span class="annot"><span class="annottext">(Map Name Name, [Type])
</span><a href="#local-6989586621679074529"><span class="hs-identifier hs-var">sc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Map Name Name, [Type])
</span><a href="#local-6989586621679074529"><span class="hs-identifier hs-var">sc</span></a></span><span>
</span><span id="line-1567"></span><span>
</span><span id="line-1568"></span><span class="hs-comment">-- | A specialization of 'mergeArguments' to 'Kind'.</span><span>
</span><span id="line-1569"></span><span class="hs-comment">-- Needed only for backwards compatibility with older versions of</span><span>
</span><span id="line-1570"></span><span class="hs-comment">-- @template-haskell@.</span><span>
</span><span id="line-1571"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#mergeArgumentKinds"><span class="hs-identifier hs-type">mergeArgumentKinds</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-1572"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1573"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1574"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span class="hs-special">)</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span id="mergeArgumentKinds"><span class="annot"><span class="annottext">mergeArgumentKinds :: [Type] -&gt; [Type] -&gt; (Map Name Name, [Type])
</span><a href="Language.Haskell.TH.Datatype.html#mergeArgumentKinds"><span class="hs-identifier hs-var hs-var">mergeArgumentKinds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; (Map Name Name, [Type])
</span><a href="Language.Haskell.TH.Datatype.html#mergeArguments"><span class="hs-identifier hs-var">mergeArguments</span></a></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">mergeArgumentKinds</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Map.empty</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1581"></span><span class="hs-comment">-- | Expand all of the type synonyms in a type.</span><span>
</span><span id="line-1582"></span><span class="hs-comment">--</span><span>
</span><span id="line-1583"></span><span class="hs-comment">-- Note that this function will drop parentheses as a side effect.</span><span>
</span><span id="line-1584"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-type">resolveTypeSynonyms</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1585"></span><span id="resolveTypeSynonyms"><span class="annot"><span class="annottext">resolveTypeSynonyms :: Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var hs-var">resolveTypeSynonyms</span></a></span></span><span> </span><span id="local-6989586621679074530"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074530"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1586"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074531"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074531"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074532"><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679074532"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; (Type, [TypeArg])
</span><a href="Language.Haskell.TH.Datatype.html#decomposeTypeArgs"><span class="hs-identifier hs-var">decomposeTypeArgs</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074530"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1587"></span><span>      </span><span id="local-6989586621679074534"><span class="annot"><span class="annottext">normal_xs :: [Type]
</span><a href="#local-6989586621679074534"><span class="hs-identifier hs-var hs-var">normal_xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#filterTANormals"><span class="hs-identifier hs-var">filterTANormals</span></a></span><span> </span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679074532"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-1588"></span><span>
</span><span id="line-1589"></span><span>      </span><span class="hs-comment">-- Either the type is not headed by a type synonym, or it is headed by a</span><span>
</span><span id="line-1590"></span><span>      </span><span class="hs-comment">-- type synonym that is not applied to enough arguments. Leave the type</span><span>
</span><span id="line-1591"></span><span>      </span><span class="hs-comment">-- alone and only expand its arguments.</span><span>
</span><span id="line-1592"></span><span>      </span><span class="annot"><a href="#local-6989586621679074536"><span class="hs-identifier hs-type">defaultCase</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1593"></span><span>      </span><span id="local-6989586621679074536"><span class="annot"><span class="annottext">defaultCase :: Type -&gt; Q Type
</span><a href="#local-6989586621679074536"><span class="hs-identifier hs-var hs-var">defaultCase</span></a></span></span><span> </span><span id="local-6989586621679074537"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074537"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; TypeArg -&gt; Type) -&gt; Type -&gt; [TypeArg] -&gt; Type
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; TypeArg -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#appTypeArg"><span class="hs-identifier hs-var">appTypeArg</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074537"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="annot"><span class="annottext">([TypeArg] -&gt; Type) -&gt; Q [TypeArg] -&gt; Q Type
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(TypeArg -&gt; Q TypeArg) -&gt; [TypeArg] -&gt; Q [TypeArg]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">TypeArg -&gt; Q TypeArg
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeArgSynonyms"><span class="hs-identifier hs-var">resolveTypeArgSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679074532"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-1594"></span><span>
</span><span id="line-1595"></span><span>      </span><span class="annot"><a href="#local-6989586621679074540"><span class="hs-identifier hs-type">expandCon</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-comment">-- The Name to check whether it is a type synonym or not</span><span>
</span><span id="line-1596"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-comment">-- The argument type to fall back on if the supplied</span><span>
</span><span id="line-1597"></span><span>                        </span><span class="hs-comment">-- Name isn't a type synonym</span><span>
</span><span id="line-1598"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1599"></span><span>      </span><span id="local-6989586621679074540"><span class="annot"><span class="annottext">expandCon :: Name -&gt; Type -&gt; Q Type
</span><a href="#local-6989586621679074540"><span class="hs-identifier hs-var hs-var">expandCon</span></a></span></span><span> </span><span id="local-6989586621679074541"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074541"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679074542"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074542"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1600"></span><span>        </span><span id="local-6989586621679074543"><span class="annot"><span class="annottext">Maybe Info
</span><a href="#local-6989586621679074543"><span class="hs-identifier hs-var">mbInfo</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q (Maybe Info)
</span><a href="Language.Haskell.TH.Datatype.html#reifyMaybe"><span class="hs-identifier hs-var">reifyMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074541"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1601"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe Info
</span><a href="#local-6989586621679074543"><span class="hs-identifier hs-var">mbInfo</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1602"></span><span>          </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TyConI</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TySynD</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679074546"><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074546"><span class="hs-identifier hs-var">synvars</span></a></span></span><span> </span><span id="local-6989586621679074547"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074547"><span class="hs-identifier hs-var">def</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1603"></span><span>            </span><span class="hs-glyph">|</span><span>  </span><span class="annot"><span class="annottext">[Type] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074534"><span class="hs-identifier hs-var">normal_xs</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074546"><span class="hs-identifier hs-var">synvars</span></a></span><span> </span><span class="hs-comment">-- Don't expand undersaturated type synonyms (#88)</span><span>
</span><span id="line-1604"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; Type -&gt; Q Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis] -&gt; [Type] -&gt; Type -&gt; Type
forall flag. [TyVarBndr_ flag] -&gt; [Type] -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#expandSynonymRHS"><span class="hs-identifier hs-var">expandSynonymRHS</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679074546"><span class="hs-identifier hs-var">synvars</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074534"><span class="hs-identifier hs-var">normal_xs</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074547"><span class="hs-identifier hs-var">def</span></a></span><span>
</span><span id="line-1605"></span><span>          </span><span class="annot"><span class="annottext">Maybe Info
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="#local-6989586621679074536"><span class="hs-identifier hs-var">defaultCase</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074542"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-1606"></span><span>
</span><span id="line-1607"></span><span>  </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074531"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1608"></span><span>       </span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679074549"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074549"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679074550"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074550"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621679074551"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074551"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1609"></span><span>         </span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; [Type] -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="annot"><span class="annottext">([TyVarBndrSpec] -&gt; [Type] -&gt; Type -&gt; Type)
-&gt; Q [TyVarBndrSpec] -&gt; Q ([Type] -&gt; Type -&gt; Type)
forall a b. (a -&gt; b) -&gt; Q a -&gt; Q b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">`fmap`</span></span><span> </span><span class="annot"><span class="annottext">(TyVarBndrSpec -&gt; Q TyVarBndrSpec)
-&gt; [TyVarBndrSpec] -&gt; Q [TyVarBndrSpec]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndrSpec -&gt; Q TyVarBndrSpec
forall flag. TyVarBndr_ flag -&gt; Q (TyVarBndr_ flag)
</span><a href="Language.Haskell.TH.Datatype.html#resolve_tvb_syns"><span class="hs-identifier hs-var">resolve_tvb_syns</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074549"><span class="hs-identifier hs-var">tvbs</span></a></span><span>
</span><span id="line-1610"></span><span>                   </span><span class="annot"><span class="annottext">Q ([Type] -&gt; Type -&gt; Type) -&gt; Q [Type] -&gt; Q (Type -&gt; Type)
forall (m :: * -&gt; *) a b. Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">`ap`</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; [Type] -&gt; Q [Type]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolvePredSynonyms"><span class="hs-identifier hs-var">resolvePredSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074550"><span class="hs-identifier hs-var">ctxt</span></a></span><span>
</span><span id="line-1611"></span><span>                   </span><span class="annot"><span class="annottext">Q (Type -&gt; Type) -&gt; Q Type -&gt; Q Type
forall (m :: * -&gt; *) a b. Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">`ap`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074551"><span class="hs-identifier hs-var">body</span></a></span><span>
</span><span id="line-1612"></span><span>       </span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679074554"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074554"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span id="local-6989586621679074555"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074555"><span class="hs-identifier hs-var">ki</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1613"></span><span>         </span><span id="local-6989586621679074556"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074556"><span class="hs-identifier hs-var">ty'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074554"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-1614"></span><span>         </span><span id="local-6989586621679074557"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074557"><span class="hs-identifier hs-var">ki'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-var">resolveKindSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074555"><span class="hs-identifier hs-var">ki</span></a></span><span>
</span><span id="line-1615"></span><span>         </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="#local-6989586621679074536"><span class="hs-identifier hs-var">defaultCase</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; Type -&gt; Q Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">SigT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074556"><span class="hs-identifier hs-var">ty'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074557"><span class="hs-identifier hs-var">ki'</span></a></span><span>
</span><span id="line-1616"></span><span>       </span><span class="annot"><span class="hs-identifier hs-type">ConT</span></span><span> </span><span id="local-6989586621679074558"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074558"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Q Type
</span><a href="#local-6989586621679074540"><span class="hs-identifier hs-var">expandCon</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074558"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074531"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>       </span><span class="annot"><span class="hs-identifier hs-type">InfixT</span></span><span> </span><span id="local-6989586621679074560"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074560"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621679074561"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074561"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679074562"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074562"><span class="hs-identifier hs-var">t2</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1619"></span><span>         </span><span id="local-6989586621679074563"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074563"><span class="hs-identifier hs-var">t1'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074560"><span class="hs-identifier hs-var">t1</span></a></span><span>
</span><span id="line-1620"></span><span>         </span><span id="local-6989586621679074564"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074564"><span class="hs-identifier hs-var">t2'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074562"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-1621"></span><span>         </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Q Type
</span><a href="#local-6989586621679074540"><span class="hs-identifier hs-var">expandCon</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074561"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">InfixT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074563"><span class="hs-identifier hs-var">t1'</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074561"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074564"><span class="hs-identifier hs-var">t2'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1622"></span><span>       </span><span class="annot"><span class="hs-identifier hs-type">UInfixT</span></span><span> </span><span id="local-6989586621679074566"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074566"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621679074567"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074567"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679074568"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074568"><span class="hs-identifier hs-var">t2</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1623"></span><span>         </span><span id="local-6989586621679074569"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074569"><span class="hs-identifier hs-var">t1'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074566"><span class="hs-identifier hs-var">t1</span></a></span><span>
</span><span id="line-1624"></span><span>         </span><span id="local-6989586621679074570"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074570"><span class="hs-identifier hs-var">t2'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074568"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-1625"></span><span>         </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Q Type
</span><a href="#local-6989586621679074540"><span class="hs-identifier hs-var">expandCon</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074567"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">UInfixT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074569"><span class="hs-identifier hs-var">t1'</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074567"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074570"><span class="hs-identifier hs-var">t2'</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,15,0)
</span><span>       </span><span class="annot"><span class="hs-identifier hs-type">ImplicitParamT</span></span><span> </span><span id="local-6989586621679074572"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679074572"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679074573"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074573"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1629"></span><span>         </span><span class="annot"><span class="annottext">String -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ImplicitParamT</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679074572"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Q Type -&gt; Q Type
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074573"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,16,0)
</span><span>       </span><span class="annot"><span class="hs-identifier hs-type">ForallVisT</span></span><span> </span><span id="local-6989586621679074574"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074574"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679074575"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074575"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1633"></span><span>         </span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallVisT</span></span><span> </span><span class="annot"><span class="annottext">([TyVarBndrUnit] -&gt; Type -&gt; Type)
-&gt; Q [TyVarBndrUnit] -&gt; Q (Type -&gt; Type)
forall a b. (a -&gt; b) -&gt; Q a -&gt; Q b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">`fmap`</span></span><span> </span><span class="annot"><span class="annottext">(TyVarBndrUnit -&gt; Q TyVarBndrUnit)
-&gt; [TyVarBndrUnit] -&gt; Q [TyVarBndrUnit]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit -&gt; Q TyVarBndrUnit
forall flag. TyVarBndr_ flag -&gt; Q (TyVarBndr_ flag)
</span><a href="Language.Haskell.TH.Datatype.html#resolve_tvb_syns"><span class="hs-identifier hs-var">resolve_tvb_syns</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074574"><span class="hs-identifier hs-var">tvbs</span></a></span><span>
</span><span id="line-1634"></span><span>                      </span><span class="annot"><span class="annottext">Q (Type -&gt; Type) -&gt; Q Type -&gt; Q Type
forall (m :: * -&gt; *) a b. Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">`ap`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074575"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,19,0)
</span><span>       </span><span class="annot"><span class="hs-identifier hs-type">PromotedInfixT</span></span><span> </span><span id="local-6989586621679074577"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074577"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621679074578"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074578"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679074579"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074579"><span class="hs-identifier hs-var">t2</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1638"></span><span>         </span><span id="local-6989586621679074580"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074580"><span class="hs-identifier hs-var">t1'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074577"><span class="hs-identifier hs-var">t1</span></a></span><span>
</span><span id="line-1639"></span><span>         </span><span id="local-6989586621679074581"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074581"><span class="hs-identifier hs-var">t2'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074579"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-1640"></span><span>         </span><span class="annot"><span class="annottext">Type -&gt; Q Type
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; Type -&gt; Q Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">PromotedInfixT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074580"><span class="hs-identifier hs-var">t1'</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074578"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074581"><span class="hs-identifier hs-var">t2'</span></a></span><span>
</span><span id="line-1641"></span><span>       </span><span class="annot"><span class="hs-identifier hs-type">PromotedUInfixT</span></span><span> </span><span id="local-6989586621679074583"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074583"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621679074584"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074584"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679074585"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074585"><span class="hs-identifier hs-var">t2</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1642"></span><span>         </span><span id="local-6989586621679074586"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074586"><span class="hs-identifier hs-var">t1'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074583"><span class="hs-identifier hs-var">t1</span></a></span><span>
</span><span id="line-1643"></span><span>         </span><span id="local-6989586621679074587"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074587"><span class="hs-identifier hs-var">t2'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074585"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-1644"></span><span>         </span><span class="annot"><span class="annottext">Type -&gt; Q Type
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; Type -&gt; Q Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">PromotedUInfixT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074586"><span class="hs-identifier hs-var">t1'</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074584"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074587"><span class="hs-identifier hs-var">t2'</span></a></span><span class="hs-cpp">
#endif
</span><span>       </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="#local-6989586621679074536"><span class="hs-identifier hs-var">defaultCase</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074531"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-1647"></span><span>
</span><span id="line-1648"></span><span class="annot"><span class="hs-comment">-- | Expand all of the type synonyms in a 'TypeArg'.</span></span><span>
</span><span id="line-1649"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveTypeArgSynonyms"><span class="hs-identifier hs-type">resolveTypeArgSynonyms</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span>
</span><span id="line-1650"></span><span id="resolveTypeArgSynonyms"><span class="annot"><span class="annottext">resolveTypeArgSynonyms :: TypeArg -&gt; Q TypeArg
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeArgSynonyms"><span class="hs-identifier hs-var hs-var">resolveTypeArgSynonyms</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TANormal"><span class="hs-identifier hs-type">TANormal</span></a></span><span> </span><span id="local-6989586621679074589"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074589"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; TypeArg
</span><a href="Language.Haskell.TH.Datatype.html#TANormal"><span class="hs-identifier hs-var">TANormal</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; TypeArg) -&gt; Q Type -&gt; Q TypeArg
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074589"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1651"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveTypeArgSynonyms"><span class="hs-identifier hs-var">resolveTypeArgSynonyms</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TyArg"><span class="hs-identifier hs-type">TyArg</span></a></span><span> </span><span id="local-6989586621679074591"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074591"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; TypeArg
</span><a href="Language.Haskell.TH.Datatype.html#TyArg"><span class="hs-identifier hs-var">TyArg</span></a></span><span>    </span><span class="annot"><span class="annottext">(Type -&gt; TypeArg) -&gt; Q Type -&gt; Q TypeArg
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-var">resolveKindSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074591"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1652"></span><span>
</span><span id="line-1653"></span><span class="annot"><span class="hs-comment">-- | Expand all of the type synonyms in a 'Kind'.</span></span><span>
</span><span id="line-1654"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-type">resolveKindSynonyms</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span id="resolveKindSynonyms"><span class="annot"><span class="annottext">resolveKindSynonyms :: Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-var hs-var">resolveKindSynonyms</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">resolveKindSynonyms</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-comment">-- One simply couldn't put type synonyms into</span><span>
</span><span id="line-1659"></span><span>                             </span><span class="hs-comment">-- kinds on old versions of GHC.</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1662"></span><span class="annot"><span class="hs-comment">-- | Expand all of the type synonyms in a the kind of a 'TyVarBndr'.</span></span><span>
</span><span id="line-1663"></span><span id="local-6989586621679072571"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolve_tvb_syns"><span class="hs-identifier hs-type">resolve_tvb_syns</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072571"><span class="hs-identifier hs-type">flag</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072571"><span class="hs-identifier hs-type">flag</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-1664"></span><span id="resolve_tvb_syns"><span class="annot"><span class="annottext">resolve_tvb_syns :: forall flag. TyVarBndr_ flag -&gt; Q (TyVarBndr_ flag)
</span><a href="Language.Haskell.TH.Datatype.html#resolve_tvb_syns"><span class="hs-identifier hs-var hs-var">resolve_tvb_syns</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; TyVarBndr_ flag -&gt; Q (TyVarBndr_ flag)
forall (m :: * -&gt; *) flag.
Monad m =&gt;
(Type -&gt; m Type) -&gt; TyVarBndr_ flag -&gt; m (TyVarBndr_ flag)
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#mapMTVKind"><span class="hs-identifier hs-var">mapMTVKind</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-var">resolveKindSynonyms</span></a></span><span>
</span><span id="line-1665"></span><span>
</span><span id="line-1666"></span><span id="local-6989586621679072570"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#expandSynonymRHS"><span class="hs-identifier hs-type">expandSynonymRHS</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-1667"></span><span>  </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072570"><span class="hs-identifier hs-type">flag</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">{- ^ Substitute these variables... -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1668"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>            </span><span class="annot"><span class="hs-comment">{- ^ ...with these types... -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1669"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>              </span><span class="annot"><span class="hs-comment">{- ^ ...inside of this type. -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1670"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span></span><span>
</span><span id="line-1671"></span><span id="expandSynonymRHS"><span class="annot"><span class="annottext">expandSynonymRHS :: forall flag. [TyVarBndr_ flag] -&gt; [Type] -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#expandSynonymRHS"><span class="hs-identifier hs-var hs-var">expandSynonymRHS</span></a></span></span><span> </span><span id="local-6989586621679074596"><span class="annot"><span class="annottext">[TyVarBndr_ flag]
</span><a href="#local-6989586621679074596"><span class="hs-identifier hs-var">synvars</span></a></span></span><span> </span><span id="local-6989586621679074597"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074597"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span id="local-6989586621679074598"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074598"><span class="hs-identifier hs-var">def</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1672"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074599"><span class="annot"><span class="annottext">argNames :: [Name]
</span><a href="#local-6989586621679074599"><span class="hs-identifier hs-var hs-var">argNames</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyVarBndr_ flag -&gt; Name) -&gt; [TyVarBndr_ flag] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr_ flag -&gt; Name
forall flag. TyVarBndr_ flag -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr_ flag]
</span><a href="#local-6989586621679074596"><span class="hs-identifier hs-var">synvars</span></a></span><span>
</span><span id="line-1673"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621679074601"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074601"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679074602"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074602"><span class="hs-identifier hs-var">rest</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [Type] -&gt; ([Type], [Type])
forall a. Int -&gt; [a] -&gt; ([a], [a])
</span><span class="hs-identifier hs-var">splitAt</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074599"><span class="hs-identifier hs-var">argNames</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074597"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-1674"></span><span>      </span><span id="local-6989586621679074605"><span class="annot"><span class="annottext">subst :: Map Name Type
</span><a href="#local-6989586621679074605"><span class="hs-identifier hs-var hs-var">subst</span></a></span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Name, Type)] -&gt; Map Name Type
forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.fromList</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; [Type] -&gt; [(Name, Type)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074599"><span class="hs-identifier hs-var">argNames</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074601"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1675"></span><span>  </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type -&gt; Type) -&gt; Type -&gt; [Type] -&gt; Type
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074605"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074598"><span class="hs-identifier hs-var">def</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074602"><span class="hs-identifier hs-var">rest</span></a></span><span>
</span><span id="line-1676"></span><span>
</span><span id="line-1677"></span><span class="annot"><span class="hs-comment">-- | Expand all of the type synonyms in a 'Pred'.</span></span><span>
</span><span id="line-1678"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolvePredSynonyms"><span class="hs-identifier hs-type">resolvePredSynonyms</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,10,0)
</span><span id="resolvePredSynonyms"><span class="annot"><span class="annottext">resolvePredSynonyms :: Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolvePredSynonyms"><span class="hs-identifier hs-var hs-var">resolvePredSynonyms</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">resolvePredSynonyms</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1683"></span><span>  </span><span class="hs-identifier">mbInfo</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">reifyMaybe</span><span> </span><span class="hs-identifier">n</span><span>
</span><span id="line-1684"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">mbInfo</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1685"></span><span>    </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">TyConI</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">TySynD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">synvars</span><span> </span><span class="hs-identifier">def</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1686"></span><span>      </span><span class="hs-glyph">|</span><span>  </span><span class="hs-identifier">length</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-operator">&gt;=</span><span> </span><span class="hs-identifier">length</span><span> </span><span class="hs-identifier">synvars</span><span> </span><span class="hs-comment">-- Don't expand undersaturated type synonyms (#88)</span><span>
</span><span id="line-1687"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">resolvePredSynonyms</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">typeToPred</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">expandSynonymRHS</span><span> </span><span class="hs-identifier">synvars</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">def</span><span>
</span><span id="line-1688"></span><span>    </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-operator">&lt;$&gt;</span><span> </span><span class="hs-identifier">mapM</span><span> </span><span class="hs-identifier">resolveTypeSynonyms</span><span> </span><span class="hs-identifier">ts</span><span>
</span><span id="line-1689"></span><span class="hs-identifier">resolvePredSynonyms</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-identifier">t2</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1690"></span><span>  </span><span class="hs-identifier">t1'</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">resolveTypeSynonyms</span><span> </span><span class="hs-identifier">t1</span><span>
</span><span id="line-1691"></span><span>  </span><span class="hs-identifier">t2'</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">resolveTypeSynonyms</span><span> </span><span class="hs-identifier">t2</span><span>
</span><span id="line-1692"></span><span>  </span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">t1'</span><span> </span><span class="hs-identifier">t2'</span><span class="hs-special">)</span><span>
</span><span id="line-1693"></span><span>
</span><span id="line-1694"></span><span class="hs-identifier">typeToPred</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Pred</span><span>
</span><span id="line-1695"></span><span class="hs-identifier">typeToPred</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1696"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">f</span><span> </span><span class="hs-operator">:|</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">decomposeType</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1697"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">f</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1698"></span><span>    </span><span class="hs-identifier">ConT</span><span> </span><span class="hs-identifier">n</span><span>
</span><span id="line-1699"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">eqTypeName</span><span class="hs-cpp">
# if __GLASGOW_HASKELL__ == 704
</span><span>        </span><span class="hs-comment">-- There's an unfortunate bug in GHC 7.4 where the (~) type is reified</span><span>
</span><span id="line-1702"></span><span>        </span><span class="hs-comment">-- with an explicit kind argument. To work around this, we ignore it.</span><span>
</span><span id="line-1703"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span class="hs-identifier">t1</span><span class="hs-special">,</span><span class="hs-identifier">t2</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">xs</span><span class="hs-cpp">
# else
</span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">t1</span><span class="hs-special">,</span><span class="hs-identifier">t2</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">xs</span><span class="hs-cpp">
# endif
</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-identifier">t2</span><span>
</span><span id="line-1708"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">otherwise</span><span>
</span><span id="line-1709"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">xs</span><span>
</span><span id="line-1710"></span><span>    </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">error</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-string">&quot;typeToPred: Can't handle type &quot;</span><span> </span><span class="hs-operator">++</span><span> </span><span class="hs-identifier">show</span><span> </span><span class="hs-identifier">t</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1713"></span><span class="hs-comment">-- | Decompose a type into a list of it's outermost applications. This process</span><span>
</span><span id="line-1714"></span><span class="hs-comment">-- forgets about infix application, explicit parentheses, and visible kind</span><span>
</span><span id="line-1715"></span><span class="hs-comment">-- applications.</span><span>
</span><span id="line-1716"></span><span class="hs-comment">--</span><span>
</span><span id="line-1717"></span><span class="hs-comment">-- This operation should be used after all 'UInfixT' cases have been resolved</span><span>
</span><span id="line-1718"></span><span class="hs-comment">-- by 'resolveFixities' if the argument is being user generated.</span><span>
</span><span id="line-1719"></span><span class="hs-comment">--</span><span>
</span><span id="line-1720"></span><span class="hs-comment">-- &gt; t ~= foldl1 AppT (decomposeType t)</span><span>
</span><span id="line-1721"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-type">decomposeType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NonEmpty"><span class="hs-identifier hs-type">NonEmpty</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1722"></span><span id="decomposeType"><span class="annot"><span class="annottext">decomposeType :: Type -&gt; NonEmpty Type
</span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var hs-var">decomposeType</span></a></span></span><span> </span><span id="local-6989586621679074606"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074606"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1723"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type -&gt; (Type, [TypeArg])
</span><a href="Language.Haskell.TH.Datatype.html#decomposeTypeArgs"><span class="hs-identifier hs-var">decomposeTypeArgs</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074606"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1724"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679074607"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074607"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074608"><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679074608"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074607"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Type] -&gt; NonEmpty Type
forall a. a -&gt; [a] -&gt; NonEmpty a
</span><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-var">:|</span></a></span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#filterTANormals"><span class="hs-identifier hs-var">filterTANormals</span></a></span><span> </span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679074608"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1725"></span><span>
</span><span id="line-1726"></span><span class="hs-comment">-- | A variant of 'decomposeType' that preserves information about visible kind</span><span>
</span><span id="line-1727"></span><span class="hs-comment">-- applications by returning a 'NonEmpty' list of 'TypeArg's.</span><span>
</span><span id="line-1728"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#decomposeTypeArgs"><span class="hs-identifier hs-type">decomposeTypeArgs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1729"></span><span id="decomposeTypeArgs"><span class="annot"><span class="annottext">decomposeTypeArgs :: Type -&gt; (Type, [TypeArg])
</span><a href="Language.Haskell.TH.Datatype.html#decomposeTypeArgs"><span class="hs-identifier hs-var hs-var">decomposeTypeArgs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679074609"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-1730"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1731"></span><span>    </span><span class="annot"><a href="#local-6989586621679074609"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1732"></span><span>    </span><span id="local-6989586621679074609"><span class="annot"><span class="annottext">go :: [TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679074609"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679074610"><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679074610"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679074611"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074611"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679074612"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074612"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679074609"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; TypeArg
</span><a href="Language.Haskell.TH.Datatype.html#TANormal"><span class="hs-identifier hs-var">TANormal</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074612"><span class="hs-identifier hs-var">x</span></a></span><span class="annot"><span class="annottext">TypeArg -&gt; [TypeArg] -&gt; [TypeArg]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679074610"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074611"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>    </span><span class="annot"><a href="#local-6989586621679074609"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679074613"><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679074613"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ParensT</span></span><span> </span><span id="local-6989586621679074615"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074615"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679074609"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679074613"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074615"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,15,0)
</span><span>    </span><span class="annot"><a href="#local-6989586621679074609"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679074616"><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679074616"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppKindT</span></span><span> </span><span id="local-6989586621679074618"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074618"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679074619"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074619"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679074609"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; TypeArg
</span><a href="Language.Haskell.TH.Datatype.html#TyArg"><span class="hs-identifier hs-var">TyArg</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074619"><span class="hs-identifier hs-var">x</span></a></span><span class="annot"><span class="annottext">TypeArg -&gt; [TypeArg] -&gt; [TypeArg]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679074616"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074618"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-cpp">
#endif
</span><span>    </span><span class="annot"><a href="#local-6989586621679074609"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679074620"><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679074620"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span id="local-6989586621679074621"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074621"><span class="hs-identifier hs-var">t</span></a></span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074621"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679074620"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1740"></span><span>
</span><span id="line-1741"></span><span class="hs-comment">-- | An argument to a type, either a normal type ('TANormal') or a visible</span><span>
</span><span id="line-1742"></span><span class="hs-comment">-- kind application ('TyArg').</span><span>
</span><span id="line-1743"></span><span class="hs-keyword">data</span><span> </span><span id="TypeArg"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-var">TypeArg</span></a></span></span><span>
</span><span id="line-1744"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="TANormal"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TANormal"><span class="hs-identifier hs-var">TANormal</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1745"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TyArg"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TyArg"><span class="hs-identifier hs-var">TyArg</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1746"></span><span>
</span><span id="line-1747"></span><span class="annot"><span class="hs-comment">-- | Apply a 'Type' to a 'TypeArg'.</span></span><span>
</span><span id="line-1748"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#appTypeArg"><span class="hs-identifier hs-type">appTypeArg</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1749"></span><span id="appTypeArg"><span class="annot"><span class="annottext">appTypeArg :: Type -&gt; TypeArg -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#appTypeArg"><span class="hs-identifier hs-var hs-var">appTypeArg</span></a></span></span><span> </span><span id="local-6989586621679074622"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074622"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TANormal"><span class="hs-identifier hs-type">TANormal</span></a></span><span> </span><span id="local-6989586621679074623"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074623"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074622"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074623"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1750"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#appTypeArg"><span class="hs-identifier hs-var">appTypeArg</span></a></span><span> </span><span id="local-6989586621679074624"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074624"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TyArg"><span class="hs-identifier hs-type">TyArg</span></a></span><span> </span><span id="local-6989586621679074625"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074625"><span class="hs-identifier hs-var">_k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,15,0)
</span><span>  </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074624"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppKindT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074625"><span class="hs-identifier hs-var">_k</span></a></span><span class="hs-cpp">
#else
</span><span>  </span><span class="hs-identifier">f</span><span> </span><span class="hs-comment">-- VKA isn't supported, so conservatively drop the argument</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1757"></span><span class="annot"><span class="hs-comment">-- | Filter out all of the normal type arguments from a list of 'TypeArg's.</span></span><span>
</span><span id="line-1758"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#filterTANormals"><span class="hs-identifier hs-type">filterTANormals</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>
</span><span id="line-1759"></span><span id="filterTANormals"><span class="annot"><span class="annottext">filterTANormals :: [TypeArg] -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#filterTANormals"><span class="hs-identifier hs-var hs-var">filterTANormals</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TypeArg -&gt; Maybe Type) -&gt; [TypeArg] -&gt; [Type]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">TypeArg -&gt; Maybe Type
</span><a href="#local-6989586621679074626"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-1760"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1761"></span><span>    </span><span class="annot"><a href="#local-6989586621679074626"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1762"></span><span>    </span><span id="local-6989586621679074626"><span class="annot"><span class="annottext">f :: TypeArg -&gt; Maybe Type
</span><a href="#local-6989586621679074626"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TANormal"><span class="hs-identifier hs-type">TANormal</span></a></span><span> </span><span id="local-6989586621679074627"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074627"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe Type
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074627"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1763"></span><span>    </span><span class="annot"><a href="#local-6989586621679074626"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TyArg"><span class="hs-identifier hs-type">TyArg</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Type
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-1764"></span><span>
</span><span id="line-1765"></span><span class="hs-comment">-- 'NonEmpty' didn't move into base until recently. Reimplementing it locally</span><span>
</span><span id="line-1766"></span><span class="hs-comment">-- saves dependencies for supporting older GHCs</span><span>
</span><span id="line-1767"></span><span class="hs-keyword">data</span><span> </span><span id="NonEmpty"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NonEmpty"><span class="hs-identifier hs-var">NonEmpty</span></a></span></span><span> </span><span id="local-6989586621679072580"><span class="annot"><a href="#local-6989586621679072580"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621679072580"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span id="%3A%7C"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-var">:|</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072580"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1768"></span><span>
</span><span id="line-1769"></span><span class="hs-keyword">data</span><span> </span><span id="NonEmptySnoc"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NonEmptySnoc"><span class="hs-identifier hs-var">NonEmptySnoc</span></a></span></span><span> </span><span id="local-6989586621679072582"><span class="annot"><a href="#local-6989586621679072582"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072582"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span id="%3A%7C-"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C-"><span class="hs-operator hs-var">:|-</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679072582"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-1770"></span><span>
</span><span id="line-1771"></span><span class="hs-comment">-- Decompose a function type into its context, argument types,</span><span>
</span><span id="line-1772"></span><span class="hs-comment">-- and return type. For instance, this</span><span>
</span><span id="line-1773"></span><span class="hs-comment">--</span><span>
</span><span id="line-1774"></span><span class="hs-comment">--   forall a b. (Show a, b ~ Int) =&gt; (a -&gt; b) -&gt; Char -&gt; Int</span><span>
</span><span id="line-1775"></span><span class="hs-comment">--</span><span>
</span><span id="line-1776"></span><span class="hs-comment">-- becomes</span><span>
</span><span id="line-1777"></span><span class="hs-comment">--</span><span>
</span><span id="line-1778"></span><span class="hs-comment">--   ([a, b], [Show a, b ~ Int], [a -&gt; b, Char] :|- Int)</span><span>
</span><span id="line-1779"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#uncurryType"><span class="hs-identifier hs-type">uncurryType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrSpec</span></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NonEmptySnoc"><span class="hs-identifier hs-type">NonEmptySnoc</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span>
</span><span id="line-1780"></span><span id="uncurryType"><span class="annot"><span class="annottext">uncurryType :: Type -&gt; ([TyVarBndrSpec], [Type], NonEmptySnoc Type)
</span><a href="Language.Haskell.TH.Datatype.html#uncurryType"><span class="hs-identifier hs-var hs-var">uncurryType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
-&gt; [Type]
-&gt; [Type]
-&gt; Type
-&gt; ([TyVarBndrSpec], [Type], NonEmptySnoc Type)
</span><a href="#local-6989586621679074628"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-1781"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1782"></span><span>    </span><span id="local-6989586621679074628"><span class="annot"><span class="annottext">go :: [TyVarBndrSpec]
-&gt; [Type]
-&gt; [Type]
-&gt; Type
-&gt; ([TyVarBndrSpec], [Type], NonEmptySnoc Type)
</span><a href="#local-6989586621679074628"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679074629"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074629"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679074630"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074630"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621679074631"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074631"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">ArrowT</span></span><span> </span><span id="local-6989586621679074633"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074633"><span class="hs-identifier hs-var">t1</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679074634"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074634"><span class="hs-identifier hs-var">t2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
-&gt; [Type]
-&gt; [Type]
-&gt; Type
-&gt; ([TyVarBndrSpec], [Type], NonEmptySnoc Type)
</span><a href="#local-6989586621679074628"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074629"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074630"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074633"><span class="hs-identifier hs-var">t1</span></a></span><span class="annot"><span class="annottext">Type -&gt; [Type] -&gt; [Type]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074631"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074634"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-1783"></span><span>    </span><span class="annot"><a href="#local-6989586621679074628"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679074635"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074635"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679074636"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074636"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621679074637"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074637"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679074638"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074638"><span class="hs-identifier hs-var">tvbs'</span></a></span></span><span> </span><span id="local-6989586621679074639"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074639"><span class="hs-identifier hs-var">ctxt'</span></a></span></span><span> </span><span id="local-6989586621679074640"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074640"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
-&gt; [Type]
-&gt; [Type]
-&gt; Type
-&gt; ([TyVarBndrSpec], [Type], NonEmptySnoc Type)
</span><a href="#local-6989586621679074628"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074635"><span class="hs-identifier hs-var">tvbs</span></a></span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; [TyVarBndrSpec] -&gt; [TyVarBndrSpec]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074638"><span class="hs-identifier hs-var">tvbs'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074636"><span class="hs-identifier hs-var">ctxt</span></a></span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; [Type]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074639"><span class="hs-identifier hs-var">ctxt'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074637"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074640"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1784"></span><span>    </span><span class="annot"><a href="#local-6989586621679074628"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679074641"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074641"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679074642"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074642"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621679074643"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074643"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span id="local-6989586621679074644"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074644"><span class="hs-identifier hs-var">t</span></a></span></span><span>                          </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074641"><span class="hs-identifier hs-var">tvbs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074642"><span class="hs-identifier hs-var">ctxt</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type]
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074643"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; NonEmptySnoc Type
forall a. [a] -&gt; a -&gt; NonEmptySnoc a
</span><a href="Language.Haskell.TH.Datatype.html#%3A%7C-"><span class="hs-operator hs-var">:|-</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074644"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1785"></span><span>
</span><span id="line-1786"></span><span class="hs-comment">-- Reconstruct a function type from its type variable binders, context,</span><span>
</span><span id="line-1787"></span><span class="hs-comment">-- argument types and return type.</span><span>
</span><span id="line-1788"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#curryType"><span class="hs-identifier hs-type">curryType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrSpec</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1789"></span><span id="curryType"><span class="annot"><span class="annottext">curryType :: [TyVarBndrSpec] -&gt; [Type] -&gt; [Type] -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#curryType"><span class="hs-identifier hs-var hs-var">curryType</span></a></span></span><span> </span><span id="local-6989586621679074646"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074646"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679074647"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074647"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621679074648"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074648"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span id="local-6989586621679074649"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074649"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1790"></span><span>  </span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; [Type] -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074646"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074647"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Type -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type -&gt; Type) -&gt; Type -&gt; [Type] -&gt; Type
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679074650"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074650"><span class="hs-identifier hs-var">arg</span></a></span></span><span> </span><span id="local-6989586621679074651"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074651"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">ArrowT</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074650"><span class="hs-identifier hs-var">arg</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074651"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074649"><span class="hs-identifier hs-var">res</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074648"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-1791"></span><span>
</span><span id="line-1792"></span><span class="hs-comment">-- All of the code from @ForallTelescope@ through @unravelType@ is taken from</span><span>
</span><span id="line-1793"></span><span class="hs-comment">-- the @th-desugar@ library, which is licensed under a 3-Clause BSD license.</span><span>
</span><span id="line-1794"></span><span>
</span><span id="line-1795"></span><span class="hs-comment">-- | The type variable binders in a @forall@. This is not used by the TH AST</span><span>
</span><span id="line-1796"></span><span class="hs-comment">-- itself, but this is used as an intermediate data type in 'FAForalls'.</span><span>
</span><span id="line-1797"></span><span class="hs-keyword">data</span><span> </span><span id="ForallTelescope"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ForallTelescope"><span class="hs-identifier hs-var">ForallTelescope</span></a></span></span><span>
</span><span id="line-1798"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ForallVis"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ForallVis"><span class="hs-identifier hs-var">ForallVis</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span><span>
</span><span id="line-1799"></span><span>    </span><span class="hs-comment">-- ^ A visible @forall@ (e.g., @forall a -&gt; {...}@).</span><span>
</span><span id="line-1800"></span><span>    </span><span class="hs-comment">--   These do not have any notion of specificity, so we use</span><span>
</span><span id="line-1801"></span><span>    </span><span class="hs-comment">--   '()' as a placeholder value in the 'TyVarBndr's.</span><span>
</span><span id="line-1802"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ForallInvis"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ForallInvis"><span class="hs-identifier hs-var">ForallInvis</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrSpec</span></span><span class="hs-special">]</span><span>
</span><span id="line-1803"></span><span>    </span><span class="hs-comment">-- ^ An invisible @forall@ (e.g., @forall a {b} c -&gt; {...}@),</span><span>
</span><span id="line-1804"></span><span>    </span><span class="hs-comment">--   where each binder has a 'Specificity'.</span><span>
</span><span id="line-1805"></span><span>
</span><span id="line-1806"></span><span class="annot"><span class="hs-comment">-- | The list of arguments in a function 'Type'.</span></span><span>
</span><span id="line-1807"></span><span class="hs-keyword">data</span><span> </span><span id="FunArgs"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-var">FunArgs</span></a></span></span><span>
</span><span id="line-1808"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="FANil"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FANil"><span class="hs-identifier hs-var">FANil</span></a></span></span><span>
</span><span id="line-1809"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ No more arguments.</span></span><span>
</span><span id="line-1810"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FAForalls"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FAForalls"><span class="hs-identifier hs-var">FAForalls</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ForallTelescope"><span class="hs-identifier hs-type">ForallTelescope</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span>
</span><span id="line-1811"></span><span>    </span><span class="hs-comment">-- ^ A series of @forall@ed type variables followed by a dot (if</span><span>
</span><span id="line-1812"></span><span>    </span><span class="hs-comment">--   'ForallInvis') or an arrow (if 'ForallVis'). For example,</span><span>
</span><span id="line-1813"></span><span>    </span><span class="hs-comment">--   the type variables @a1 ... an@ in @forall a1 ... an. r@.</span><span>
</span><span id="line-1814"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FACxt"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FACxt"><span class="hs-identifier hs-var">FACxt</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span>
</span><span id="line-1815"></span><span>    </span><span class="hs-comment">-- ^ A series of constraint arguments followed by @=&gt;@. For example,</span><span>
</span><span id="line-1816"></span><span>    </span><span class="hs-comment">--   the @(c1, ..., cn)@ in @(c1, ..., cn) =&gt; r@.</span><span>
</span><span id="line-1817"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FAAnon"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FAAnon"><span class="hs-identifier hs-var">FAAnon</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span>
</span><span id="line-1818"></span><span>    </span><span class="hs-comment">-- ^ An anonymous argument followed by an arrow. For example, the @a@</span><span>
</span><span id="line-1819"></span><span>    </span><span class="hs-comment">--   in @a -&gt; r@.</span><span>
</span><span id="line-1820"></span><span>
</span><span id="line-1821"></span><span class="hs-comment">-- | A /visible/ function argument type (i.e., one that must be supplied</span><span>
</span><span id="line-1822"></span><span class="hs-comment">-- explicitly in the source code). This is in contrast to /invisible/</span><span>
</span><span id="line-1823"></span><span class="hs-comment">-- arguments (e.g., the @c@ in @c =&gt; r@), which are instantiated without</span><span>
</span><span id="line-1824"></span><span class="hs-comment">-- the need for explicit user input.</span><span>
</span><span id="line-1825"></span><span class="hs-keyword">data</span><span> </span><span id="VisFunArg"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#VisFunArg"><span class="hs-identifier hs-var">VisFunArg</span></a></span></span><span>
</span><span id="line-1826"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="VisFADep"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#VisFADep"><span class="hs-identifier hs-var">VisFADep</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span>
</span><span id="line-1827"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ A visible @forall@ (e.g., @forall a -&gt; a@).</span></span><span>
</span><span id="line-1828"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="VisFAAnon"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#VisFAAnon"><span class="hs-identifier hs-var">VisFAAnon</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1829"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ An anonymous argument followed by an arrow (e.g., @a -&gt; r@).</span></span><span class="hs-cpp">

#if MIN_VERSION_template_haskell(2,8,0)
</span><span class="hs-comment">-- | Decompose a function 'Type' into its arguments (the 'FunArgs') and its</span><span>
</span><span id="line-1833"></span><span class="hs-comment">-- result type (the 'Type).</span><span>
</span><span id="line-1834"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unravelType"><span class="hs-identifier hs-type">unravelType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span>
</span><span id="line-1835"></span><span id="unravelType"><span class="annot"><span class="annottext">unravelType :: Type -&gt; (FunArgs, Type)
</span><a href="Language.Haskell.TH.Datatype.html#unravelType"><span class="hs-identifier hs-var hs-var">unravelType</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679074653"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074653"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679074654"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074654"><span class="hs-identifier hs-var">cxt</span></a></span></span><span> </span><span id="local-6989586621679074655"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074655"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1836"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074656"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074656"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074657"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074657"><span class="hs-identifier hs-var">res</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; (FunArgs, Type)
</span><a href="Language.Haskell.TH.Datatype.html#unravelType"><span class="hs-identifier hs-var">unravelType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074655"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1837"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ForallTelescope -&gt; FunArgs -&gt; FunArgs
</span><a href="Language.Haskell.TH.Datatype.html#FAForalls"><span class="hs-identifier hs-var">FAForalls</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; ForallTelescope
</span><a href="Language.Haskell.TH.Datatype.html#ForallInvis"><span class="hs-identifier hs-var">ForallInvis</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074653"><span class="hs-identifier hs-var">tvbs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; FunArgs -&gt; FunArgs
</span><a href="Language.Haskell.TH.Datatype.html#FACxt"><span class="hs-identifier hs-var">FACxt</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074654"><span class="hs-identifier hs-var">cxt</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074656"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074657"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1838"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unravelType"><span class="hs-identifier hs-var">unravelType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">ArrowT</span></span><span> </span><span id="local-6989586621679074658"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074658"><span class="hs-identifier hs-var">t1</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679074659"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074659"><span class="hs-identifier hs-var">t2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1839"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074660"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074660"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074661"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074661"><span class="hs-identifier hs-var">res</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; (FunArgs, Type)
</span><a href="Language.Haskell.TH.Datatype.html#unravelType"><span class="hs-identifier hs-var">unravelType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074659"><span class="hs-identifier hs-var">t2</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1840"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; FunArgs -&gt; FunArgs
</span><a href="Language.Haskell.TH.Datatype.html#FAAnon"><span class="hs-identifier hs-var">FAAnon</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074658"><span class="hs-identifier hs-var">t1</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074660"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074661"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
# if __GLASGOW_HASKELL__ &gt;= 809
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unravelType"><span class="hs-identifier hs-var">unravelType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallVisT</span></span><span> </span><span id="local-6989586621679074662"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074662"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679074663"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074663"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1843"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074664"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074664"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074665"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074665"><span class="hs-identifier hs-var">res</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; (FunArgs, Type)
</span><a href="Language.Haskell.TH.Datatype.html#unravelType"><span class="hs-identifier hs-var">unravelType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074663"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1844"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ForallTelescope -&gt; FunArgs -&gt; FunArgs
</span><a href="Language.Haskell.TH.Datatype.html#FAForalls"><span class="hs-identifier hs-var">FAForalls</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; ForallTelescope
</span><a href="Language.Haskell.TH.Datatype.html#ForallVis"><span class="hs-identifier hs-var">ForallVis</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074662"><span class="hs-identifier hs-var">tvbs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074664"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074665"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
# endif
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unravelType"><span class="hs-identifier hs-var">unravelType</span></a></span><span> </span><span id="local-6989586621679074666"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074666"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FunArgs
</span><a href="Language.Haskell.TH.Datatype.html#FANil"><span class="hs-identifier hs-var">FANil</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074666"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1847"></span><span>
</span><span id="line-1848"></span><span class="annot"><span class="hs-comment">-- | Reconstruct an arrow 'Type' from its argument and result types.</span></span><span>
</span><span id="line-1849"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ravelType"><span class="hs-identifier hs-type">ravelType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1850"></span><span id="ravelType"><span class="annot"><span class="annottext">ravelType :: FunArgs -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#ravelType"><span class="hs-identifier hs-var hs-var">ravelType</span></a></span></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="Language.Haskell.TH.Datatype.html#FANil"><span class="hs-identifier hs-var">FANil</span></a></span><span> </span><span id="local-6989586621679074668"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074668"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074668"><span class="hs-identifier hs-var">res</span></a></span><span>
</span><span id="line-1851"></span><span class="hs-comment">-- We need a special case for FAForalls ForallInvis followed by FACxt so that we may</span><span>
</span><span id="line-1852"></span><span class="hs-comment">-- collapse them into a single ForallT when raveling.</span><span>
</span><span id="line-1853"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ravelType"><span class="hs-identifier hs-var">ravelType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FAForalls"><span class="hs-identifier hs-type">FAForalls</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ForallInvis"><span class="hs-identifier hs-type">ForallInvis</span></a></span><span> </span><span id="local-6989586621679074669"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074669"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FACxt"><span class="hs-identifier hs-type">FACxt</span></a></span><span> </span><span id="local-6989586621679074670"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074670"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679074671"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074671"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span id="local-6989586621679074672"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074672"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1854"></span><span>  </span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; [Type] -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074669"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074670"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FunArgs -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#ravelType"><span class="hs-identifier hs-var">ravelType</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074671"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074672"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1855"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ravelType"><span class="hs-identifier hs-var">ravelType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FAForalls"><span class="hs-identifier hs-type">FAForalls</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ForallInvis"><span class="hs-identifier hs-type">ForallInvis</span></a></span><span>  </span><span id="local-6989586621679074673"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074673"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span class="hs-special">)</span><span>  </span><span id="local-6989586621679074674"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074674"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span>  </span><span id="local-6989586621679074675"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074675"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; [Type] -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074673"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FunArgs -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#ravelType"><span class="hs-identifier hs-var">ravelType</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074674"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074675"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1856"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ravelType"><span class="hs-identifier hs-var">ravelType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FAForalls"><span class="hs-identifier hs-type">FAForalls</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ForallVis"><span class="hs-identifier hs-type">ForallVis</span></a></span><span>   </span><span id="local-6989586621679074676"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074676"><span class="hs-identifier hs-var">_tvbs</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679074677"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074677"><span class="hs-identifier hs-var">_args</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679074678"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074678"><span class="hs-identifier hs-var">_res</span></a></span></span><span> </span><span class="hs-glyph">=</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 809
</span><span>      </span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallVisT</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074676"><span class="hs-identifier hs-var">_tvbs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FunArgs -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#ravelType"><span class="hs-identifier hs-var">ravelType</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074677"><span class="hs-identifier hs-var">_args</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074678"><span class="hs-identifier hs-var">_res</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span>      </span><span class="hs-identifier">error</span><span> </span><span class="hs-string">&quot;Visible dependent quantification supported only on GHC 8.10+&quot;</span><span class="hs-cpp">
#endif
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ravelType"><span class="hs-identifier hs-var">ravelType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FACxt"><span class="hs-identifier hs-type">FACxt</span></a></span><span> </span><span id="local-6989586621679074679"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074679"><span class="hs-identifier hs-var">cxt</span></a></span></span><span> </span><span id="local-6989586621679074680"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074680"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679074681"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074681"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; [Type] -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074679"><span class="hs-identifier hs-var">cxt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FunArgs -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#ravelType"><span class="hs-identifier hs-var">ravelType</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074680"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074681"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1863"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ravelType"><span class="hs-identifier hs-var">ravelType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FAAnon"><span class="hs-identifier hs-type">FAAnon</span></a></span><span> </span><span id="local-6989586621679074682"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074682"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679074683"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074683"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span>  </span><span id="local-6989586621679074684"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074684"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">ArrowT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074682"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FunArgs -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#ravelType"><span class="hs-identifier hs-var">ravelType</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074683"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074684"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1864"></span><span>
</span><span id="line-1865"></span><span class="hs-comment">-- | Convert a 'FunArg's value into the list of 'Type's that it contains.</span><span>
</span><span id="line-1866"></span><span class="hs-comment">-- For example, given this function type:</span><span>
</span><span id="line-1867"></span><span class="hs-comment">--</span><span>
</span><span id="line-1868"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1869"></span><span class="hs-comment">-- forall k (a :: k). Proxy a -&gt; forall b. Maybe b</span><span>
</span><span id="line-1870"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1871"></span><span class="hs-comment">--</span><span>
</span><span id="line-1872"></span><span class="hs-comment">-- Then calling @funArgTys@ on the arguments would yield:</span><span>
</span><span id="line-1873"></span><span class="hs-comment">--</span><span>
</span><span id="line-1874"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1875"></span><span class="hs-comment">-- [k, (a :: k), Proxy a, b, Maybe b]</span><span>
</span><span id="line-1876"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1877"></span><span class="hs-comment">--</span><span>
</span><span id="line-1878"></span><span class="hs-comment">-- This is primarily used for the purposes of computing all of the type</span><span>
</span><span id="line-1879"></span><span class="hs-comment">-- variables that appear in a 'FunArgs' value.</span><span>
</span><span id="line-1880"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#funArgTys"><span class="hs-identifier hs-type">funArgTys</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>
</span><span id="line-1881"></span><span id="funArgTys"><span class="annot"><span class="annottext">funArgTys :: FunArgs -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#funArgTys"><span class="hs-identifier hs-var hs-var">funArgTys</span></a></span></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="Language.Haskell.TH.Datatype.html#FANil"><span class="hs-identifier hs-var">FANil</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-1882"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#funArgTys"><span class="hs-identifier hs-var">funArgTys</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FAForalls"><span class="hs-identifier hs-type">FAForalls</span></a></span><span> </span><span id="local-6989586621679074685"><span class="annot"><span class="annottext">ForallTelescope
</span><a href="#local-6989586621679074685"><span class="hs-identifier hs-var">tele</span></a></span></span><span> </span><span id="local-6989586621679074686"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074686"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1883"></span><span>  </span><span class="annot"><span class="annottext">ForallTelescope -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#forallTelescopeTys"><span class="hs-identifier hs-var">forallTelescopeTys</span></a></span><span> </span><span class="annot"><span class="annottext">ForallTelescope
</span><a href="#local-6989586621679074685"><span class="hs-identifier hs-var">tele</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; [Type]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FunArgs -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#funArgTys"><span class="hs-identifier hs-var">funArgTys</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074686"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-cpp">
# if __GLASGOW_HASKELL__ &gt;= 800
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#funArgTys"><span class="hs-identifier hs-var">funArgTys</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FACxt"><span class="hs-identifier hs-type">FACxt</span></a></span><span> </span><span id="local-6989586621679074688"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074688"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621679074689"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074689"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1886"></span><span>  </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074688"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; [Type]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FunArgs -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#funArgTys"><span class="hs-identifier hs-var">funArgTys</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074689"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-cpp">
# else
</span><span class="hs-identifier">funArgTys</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">FACxt</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1889"></span><span>  </span><span class="hs-identifier">error</span><span> </span><span class="hs-string">&quot;Constraints in kinds not supported prior to GHC 8.0&quot;</span><span class="hs-cpp">
# endif
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#funArgTys"><span class="hs-identifier hs-var">funArgTys</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FAAnon"><span class="hs-identifier hs-type">FAAnon</span></a></span><span> </span><span id="local-6989586621679074690"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074690"><span class="hs-identifier hs-var">anon</span></a></span></span><span> </span><span id="local-6989586621679074691"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074691"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1892"></span><span>  </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074690"><span class="hs-identifier hs-var">anon</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Type] -&gt; [Type]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">FunArgs -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#funArgTys"><span class="hs-identifier hs-var">funArgTys</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074691"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-1893"></span><span>
</span><span id="line-1894"></span><span class="hs-comment">-- | Convert a 'ForallTelescope' value into the list of 'Type's that it</span><span>
</span><span id="line-1895"></span><span class="hs-comment">-- contains. See the Haddocks for 'funArgTys' for an example of what this does.</span><span>
</span><span id="line-1896"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#forallTelescopeTys"><span class="hs-identifier hs-type">forallTelescopeTys</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ForallTelescope"><span class="hs-identifier hs-type">ForallTelescope</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>
</span><span id="line-1897"></span><span id="forallTelescopeTys"><span class="annot"><span class="annottext">forallTelescopeTys :: ForallTelescope -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#forallTelescopeTys"><span class="hs-identifier hs-var hs-var">forallTelescopeTys</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ForallVis"><span class="hs-identifier hs-type">ForallVis</span></a></span><span> </span><span id="local-6989586621679074692"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074692"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; [Type]
forall flag. [TyVarBndr_ flag] -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#bndrParams"><span class="hs-identifier hs-var">bndrParams</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074692"><span class="hs-identifier hs-var">tvbs</span></a></span><span>
</span><span id="line-1898"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#forallTelescopeTys"><span class="hs-identifier hs-var">forallTelescopeTys</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ForallInvis"><span class="hs-identifier hs-type">ForallInvis</span></a></span><span> </span><span id="local-6989586621679074693"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074693"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; [Type]
forall flag. [TyVarBndr_ flag] -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#bndrParams"><span class="hs-identifier hs-var">bndrParams</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074693"><span class="hs-identifier hs-var">tvbs</span></a></span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1901"></span><span class="annot"><span class="hs-comment">-- | Reconstruct an arrow 'Kind' from its argument and result kinds.</span></span><span>
</span><span id="line-1902"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ravelKind"><span class="hs-identifier hs-type">ravelKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span id="ravelKind"><span class="annot"><span class="annottext">ravelKind :: FunArgs -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#ravelKind"><span class="hs-identifier hs-var hs-var">ravelKind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FunArgs -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#ravelType"><span class="hs-identifier hs-var">ravelType</span></a></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">ravelKind</span><span> </span><span class="hs-identifier">FANil</span><span> </span><span class="hs-identifier">res</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">res</span><span>
</span><span id="line-1907"></span><span class="hs-identifier">ravelKind</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">FAAnon</span><span> </span><span class="hs-identifier">k</span><span> </span><span class="hs-identifier">args</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">res</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">ArrowK</span><span> </span><span class="hs-identifier">k</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ravelKind</span><span> </span><span class="hs-identifier">args</span><span> </span><span class="hs-identifier">res</span><span class="hs-special">)</span><span>
</span><span id="line-1908"></span><span class="hs-identifier">ravelKind</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">FAForalls</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">_res</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1909"></span><span>  </span><span class="hs-identifier">error</span><span> </span><span class="hs-string">&quot;TH doesn't support `forall`s in kinds prior to template-haskell-2.8.0.0&quot;</span><span>
</span><span id="line-1910"></span><span class="hs-identifier">ravelKind</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">FACxt</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">_res</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1911"></span><span>  </span><span class="hs-identifier">error</span><span> </span><span class="hs-string">&quot;TH doesn't support contexts in kinds prior to template-haskell-2.8.0.0&quot;</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1914"></span><span class="hs-comment">-- | Decompose a function 'Kind' into its arguments (the 'FunArgs') and its</span><span>
</span><span id="line-1915"></span><span class="hs-comment">-- result type (the 'Kind).</span><span>
</span><span id="line-1916"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unravelKind"><span class="hs-identifier hs-type">unravelKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-special">)</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span id="unravelKind"><span class="annot"><span class="annottext">unravelKind :: Type -&gt; (FunArgs, Type)
</span><a href="Language.Haskell.TH.Datatype.html#unravelKind"><span class="hs-identifier hs-var hs-var">unravelKind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; (FunArgs, Type)
</span><a href="Language.Haskell.TH.Datatype.html#unravelType"><span class="hs-identifier hs-var">unravelType</span></a></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">unravelKind</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ArrowK</span><span> </span><span class="hs-identifier">k1</span><span> </span><span class="hs-identifier">k2</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1921"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">args</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">res</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">unravelKind</span><span> </span><span class="hs-identifier">k2</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1922"></span><span>  </span><span class="hs-special">(</span><span class="hs-identifier">FAAnon</span><span> </span><span class="hs-identifier">k1</span><span> </span><span class="hs-identifier">args</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">res</span><span class="hs-special">)</span><span>
</span><span id="line-1923"></span><span class="hs-identifier">unravelKind</span><span> </span><span class="hs-identifier">StarK</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1924"></span><span>  </span><span class="hs-special">(</span><span class="hs-identifier">FANil</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">StarK</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1927"></span><span class="hs-comment">-- | @'filterVisFunArgsUpTo' xs args@ will split @args@ into 'VisFunArg's as</span><span>
</span><span id="line-1928"></span><span class="hs-comment">-- many times as there are elements in @xs@, pairing up each entry in @xs@ with</span><span>
</span><span id="line-1929"></span><span class="hs-comment">-- the corresponding 'VisFunArg' in the process. This will stop after the last</span><span>
</span><span id="line-1930"></span><span class="hs-comment">-- entry in @xs@ has been paired up.</span><span>
</span><span id="line-1931"></span><span class="hs-comment">--</span><span>
</span><span id="line-1932"></span><span class="hs-comment">-- For example, this:</span><span>
</span><span id="line-1933"></span><span class="hs-comment">--</span><span>
</span><span id="line-1934"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1935"></span><span class="hs-comment">-- 'filterVisFunArgsUpTo'</span><span>
</span><span id="line-1936"></span><span class="hs-comment">--   [Bool, True]</span><span>
</span><span id="line-1937"></span><span class="hs-comment">--   [ FAForalls (ForallVis [j])</span><span>
</span><span id="line-1938"></span><span class="hs-comment">--   , FAAnon j</span><span>
</span><span id="line-1939"></span><span class="hs-comment">--   , FAForalls (ForallInvis [k])</span><span>
</span><span id="line-1940"></span><span class="hs-comment">--   , FAAnon k</span><span>
</span><span id="line-1941"></span><span class="hs-comment">--   ]</span><span>
</span><span id="line-1942"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1943"></span><span class="hs-comment">--</span><span>
</span><span id="line-1944"></span><span class="hs-comment">-- Will yield:</span><span>
</span><span id="line-1945"></span><span class="hs-comment">--</span><span>
</span><span id="line-1946"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1947"></span><span class="hs-comment">-- ( [(Bool, VisFADep j), (True, VisFAAnon j)]</span><span>
</span><span id="line-1948"></span><span class="hs-comment">-- , [FAForalls (ForallInvis [k]), FAAnon k]</span><span>
</span><span id="line-1949"></span><span class="hs-comment">-- )</span><span>
</span><span id="line-1950"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1951"></span><span class="hs-comment">--</span><span>
</span><span id="line-1952"></span><span class="hs-comment">-- This function assumes the precondition that there are at least as many</span><span>
</span><span id="line-1953"></span><span class="hs-comment">-- visible function arguments in @args@ as there are elements in @xs@. If this</span><span>
</span><span id="line-1954"></span><span class="hs-comment">-- is not the case, this function will raise an error.</span><span>
</span><span id="line-1955"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#filterVisFunArgsUpTo"><span class="hs-identifier hs-type">filterVisFunArgsUpTo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679072583"><span class="annot"><a href="#local-6989586621679072583"><span class="hs-identifier hs-type">a</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072583"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679072583"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#VisFunArg"><span class="hs-identifier hs-type">VisFunArg</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1956"></span><span id="filterVisFunArgsUpTo"><span class="annot"><span class="annottext">filterVisFunArgsUpTo :: forall a. [a] -&gt; FunArgs -&gt; ([(a, VisFunArg)], FunArgs)
</span><a href="Language.Haskell.TH.Datatype.html#filterVisFunArgsUpTo"><span class="hs-identifier hs-var hs-var">filterVisFunArgsUpTo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a] -&gt; FunArgs -&gt; ([(a, VisFunArg)], FunArgs)
</span><a href="#local-6989586621679074698"><span class="hs-identifier hs-var">go_fun_args</span></a></span><span>
</span><span id="line-1957"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1958"></span><span>    </span><span class="annot"><a href="#local-6989586621679074698"><span class="hs-identifier hs-type">go_fun_args</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072583"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679072583"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#VisFunArg"><span class="hs-identifier hs-type">VisFunArg</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1959"></span><span>    </span><span id="local-6989586621679074698"><span class="annot"><span class="annottext">go_fun_args :: [a] -&gt; FunArgs -&gt; ([(a, VisFunArg)], FunArgs)
</span><a href="#local-6989586621679074698"><span class="hs-identifier hs-var hs-var">go_fun_args</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span id="local-6989586621679074699"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074699"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1960"></span><span>      </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074699"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1961"></span><span>    </span><span class="annot"><a href="#local-6989586621679074698"><span class="hs-identifier hs-var">go_fun_args</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span class="annot"><span class="annottext">[a]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="Language.Haskell.TH.Datatype.html#FANil"><span class="hs-identifier hs-var">FANil</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1962"></span><span>      </span><span class="annot"><span class="annottext">String -&gt; ([(a, VisFunArg)], FunArgs)
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;filterVisFunArgsUpTo.go_fun_args: Too few FunArgs&quot;</span></span><span>
</span><span id="line-1963"></span><span>    </span><span class="annot"><a href="#local-6989586621679074698"><span class="hs-identifier hs-var">go_fun_args</span></a></span><span> </span><span id="local-6989586621679074700"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679074700"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FACxt"><span class="hs-identifier hs-type">FACxt</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679074701"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074701"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1964"></span><span>      </span><span class="annot"><span class="annottext">[a] -&gt; FunArgs -&gt; ([(a, VisFunArg)], FunArgs)
</span><a href="#local-6989586621679074698"><span class="hs-identifier hs-var">go_fun_args</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679074700"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074701"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-1965"></span><span>    </span><span class="annot"><a href="#local-6989586621679074698"><span class="hs-identifier hs-var">go_fun_args</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074702"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679074702"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679074703"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679074703"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FAAnon"><span class="hs-identifier hs-type">FAAnon</span></a></span><span> </span><span id="local-6989586621679074704"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074704"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679074705"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074705"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1966"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074706"><span class="annot"><span class="annottext">[(a, VisFunArg)]
</span><a href="#local-6989586621679074706"><span class="hs-identifier hs-var">xs'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074707"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074707"><span class="hs-identifier hs-var">args'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a] -&gt; FunArgs -&gt; ([(a, VisFunArg)], FunArgs)
</span><a href="#local-6989586621679074698"><span class="hs-identifier hs-var">go_fun_args</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679074703"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074705"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1967"></span><span>      </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679074702"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type -&gt; VisFunArg
</span><a href="Language.Haskell.TH.Datatype.html#VisFAAnon"><span class="hs-identifier hs-var">VisFAAnon</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074704"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="annot"><span class="annottext">(a, VisFunArg) -&gt; [(a, VisFunArg)] -&gt; [(a, VisFunArg)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[(a, VisFunArg)]
</span><a href="#local-6989586621679074706"><span class="hs-identifier hs-var">xs'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074707"><span class="hs-identifier hs-var">args'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1968"></span><span>    </span><span class="annot"><a href="#local-6989586621679074698"><span class="hs-identifier hs-var">go_fun_args</span></a></span><span> </span><span id="local-6989586621679074708"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679074708"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FAForalls"><span class="hs-identifier hs-type">FAForalls</span></a></span><span> </span><span id="local-6989586621679074709"><span class="annot"><span class="annottext">ForallTelescope
</span><a href="#local-6989586621679074709"><span class="hs-identifier hs-var">tele</span></a></span></span><span> </span><span id="local-6989586621679074710"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074710"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1969"></span><span>      </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">ForallTelescope
</span><a href="#local-6989586621679074709"><span class="hs-identifier hs-var">tele</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1970"></span><span>        </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ForallVis"><span class="hs-identifier hs-type">ForallVis</span></a></span><span> </span><span id="local-6989586621679074711"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074711"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1971"></span><span>          </span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; [a] -&gt; FunArgs -&gt; ([(a, VisFunArg)], FunArgs)
</span><a href="#local-6989586621679074712"><span class="hs-identifier hs-var">go_vis_tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074711"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679074708"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074710"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-1972"></span><span>        </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ForallInvis"><span class="hs-identifier hs-type">ForallInvis</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1973"></span><span>          </span><span class="annot"><span class="annottext">[a] -&gt; FunArgs -&gt; ([(a, VisFunArg)], FunArgs)
</span><a href="#local-6989586621679074698"><span class="hs-identifier hs-var">go_fun_args</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679074708"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074710"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-1974"></span><span>
</span><span id="line-1975"></span><span>    </span><span class="annot"><a href="#local-6989586621679074712"><span class="hs-identifier hs-type">go_vis_tvbs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072583"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679072583"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#VisFunArg"><span class="hs-identifier hs-type">VisFunArg</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FunArgs"><span class="hs-identifier hs-type">FunArgs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1976"></span><span>    </span><span id="local-6989586621679074712"><span class="annot"><span class="annottext">go_vis_tvbs :: [TyVarBndrUnit] -&gt; [a] -&gt; FunArgs -&gt; ([(a, VisFunArg)], FunArgs)
</span><a href="#local-6989586621679074712"><span class="hs-identifier hs-var hs-var">go_vis_tvbs</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span id="local-6989586621679074713"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679074713"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621679074714"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074714"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1977"></span><span>      </span><span class="annot"><span class="annottext">[a] -&gt; FunArgs -&gt; ([(a, VisFunArg)], FunArgs)
</span><a href="#local-6989586621679074698"><span class="hs-identifier hs-var">go_fun_args</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679074713"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074714"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-1978"></span><span>    </span><span class="annot"><a href="#local-6989586621679074712"><span class="hs-identifier hs-var">go_vis_tvbs</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074715"><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679074715"><span class="hs-identifier hs-var">tvb</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679074716"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074716"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074717"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679074717"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679074718"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679074718"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679074719"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074719"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1979"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074720"><span class="annot"><span class="annottext">[(a, VisFunArg)]
</span><a href="#local-6989586621679074720"><span class="hs-identifier hs-var">xs'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074721"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074721"><span class="hs-identifier hs-var">args'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; [a] -&gt; FunArgs -&gt; ([(a, VisFunArg)], FunArgs)
</span><a href="#local-6989586621679074712"><span class="hs-identifier hs-var">go_vis_tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074716"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679074718"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074719"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1980"></span><span>      </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679074717"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit -&gt; VisFunArg
</span><a href="Language.Haskell.TH.Datatype.html#VisFADep"><span class="hs-identifier hs-var">VisFADep</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679074715"><span class="hs-identifier hs-var">tvb</span></a></span><span class="hs-special">)</span><span class="annot"><span class="annottext">(a, VisFunArg) -&gt; [(a, VisFunArg)] -&gt; [(a, VisFunArg)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[(a, VisFunArg)]
</span><a href="#local-6989586621679074720"><span class="hs-identifier hs-var">xs'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074721"><span class="hs-identifier hs-var">args'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1981"></span><span>    </span><span class="annot"><a href="#local-6989586621679074712"><span class="hs-identifier hs-var">go_vis_tvbs</span></a></span><span> </span><span id="local-6989586621679074722"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074722"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span id="local-6989586621679074723"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074723"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1982"></span><span>      </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ForallTelescope -&gt; FunArgs -&gt; FunArgs
</span><a href="Language.Haskell.TH.Datatype.html#FAForalls"><span class="hs-identifier hs-var">FAForalls</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; ForallTelescope
</span><a href="Language.Haskell.TH.Datatype.html#ForallVis"><span class="hs-identifier hs-var">ForallVis</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074722"><span class="hs-identifier hs-var">tvbs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074723"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1983"></span><span>
</span><span id="line-1984"></span><span class="hs-comment">-- | @'unravelKindUpTo' xs k@ will split the function kind @k@ into its argument</span><span>
</span><span id="line-1985"></span><span class="hs-comment">-- kinds @args@ and result kind @res@, and then it will call</span><span>
</span><span id="line-1986"></span><span class="hs-comment">-- @'filterVisFunArgsUpTo' xs args@. The leftover arguments that were not split</span><span>
</span><span id="line-1987"></span><span class="hs-comment">-- apart by 'filterVisFunArgsUpTo' are then raveled back into @res@.</span><span>
</span><span id="line-1988"></span><span class="hs-comment">--</span><span>
</span><span id="line-1989"></span><span class="hs-comment">-- For example, this:</span><span>
</span><span id="line-1990"></span><span class="hs-comment">--</span><span>
</span><span id="line-1991"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1992"></span><span class="hs-comment">-- 'filterVisFunArgsUpTo'</span><span>
</span><span id="line-1993"></span><span class="hs-comment">--   [Bool, True]</span><span>
</span><span id="line-1994"></span><span class="hs-comment">--   (forall j -&gt; j -&gt; forall k. k -&gt; Type)</span><span>
</span><span id="line-1995"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1996"></span><span class="hs-comment">--</span><span>
</span><span id="line-1997"></span><span class="hs-comment">-- Will yield:</span><span>
</span><span id="line-1998"></span><span class="hs-comment">--</span><span>
</span><span id="line-1999"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-2000"></span><span class="hs-comment">-- ( [(Bool, VisFADep j), (True, VisFAAnon j)]</span><span>
</span><span id="line-2001"></span><span class="hs-comment">-- , forall k. k -&gt; Type</span><span>
</span><span id="line-2002"></span><span class="hs-comment">-- )</span><span>
</span><span id="line-2003"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-2004"></span><span class="hs-comment">--</span><span>
</span><span id="line-2005"></span><span class="hs-comment">-- This function assumes the precondition that there are at least as many</span><span>
</span><span id="line-2006"></span><span class="hs-comment">-- visible function arguments in @args@ as there are elements in @xs@. If this</span><span>
</span><span id="line-2007"></span><span class="hs-comment">-- is not the case, this function will raise an error.</span><span>
</span><span id="line-2008"></span><span id="local-6989586621679072481"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unravelKindUpTo"><span class="hs-identifier hs-type">unravelKindUpTo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072481"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679072481"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#VisFunArg"><span class="hs-identifier hs-type">VisFunArg</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-special">)</span></span><span>
</span><span id="line-2009"></span><span id="unravelKindUpTo"><span class="annot"><span class="annottext">unravelKindUpTo :: forall a. [a] -&gt; Type -&gt; ([(a, VisFunArg)], Type)
</span><a href="Language.Haskell.TH.Datatype.html#unravelKindUpTo"><span class="hs-identifier hs-var hs-var">unravelKindUpTo</span></a></span></span><span> </span><span id="local-6989586621679074724"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679074724"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621679074725"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074725"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(a, VisFunArg)]
</span><a href="#local-6989586621679074726"><span class="hs-identifier hs-var">xs'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">FunArgs -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#ravelKind"><span class="hs-identifier hs-var">ravelKind</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074727"><span class="hs-identifier hs-var">args'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074728"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2010"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-2011"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679074729"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074729"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074728"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074728"><span class="hs-identifier hs-var">res</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; (FunArgs, Type)
</span><a href="Language.Haskell.TH.Datatype.html#unravelKind"><span class="hs-identifier hs-var">unravelKind</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074725"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-2012"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679074726"><span class="annot"><span class="annottext">[(a, VisFunArg)]
</span><a href="#local-6989586621679074726"><span class="hs-identifier hs-var">xs'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074727"><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074727"><span class="hs-identifier hs-var">args'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a] -&gt; FunArgs -&gt; ([(a, VisFunArg)], FunArgs)
forall a. [a] -&gt; FunArgs -&gt; ([(a, VisFunArg)], FunArgs)
</span><a href="Language.Haskell.TH.Datatype.html#filterVisFunArgsUpTo"><span class="hs-identifier hs-var">filterVisFunArgsUpTo</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679074724"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">FunArgs
</span><a href="#local-6989586621679074729"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-2013"></span><span>
</span><span id="line-2014"></span><span class="hs-comment">-- | Resolve any infix type application in a type using the fixities that</span><span>
</span><span id="line-2015"></span><span class="hs-comment">-- are currently available. Starting in `template-haskell-2.11` types could</span><span>
</span><span id="line-2016"></span><span class="hs-comment">-- contain unresolved infix applications.</span><span>
</span><span id="line-2017"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-type">resolveInfixT</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-cpp">

#if MIN_VERSION_template_haskell(2,11,0)
</span><span id="resolveInfixT"><span class="annot"><span class="annottext">resolveInfixT :: Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var hs-var">resolveInfixT</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679074730"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074730"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span id="local-6989586621679074731"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074731"><span class="hs-identifier hs-var">cx</span></a></span></span><span> </span><span id="local-6989586621679074732"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074732"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; [Type] -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="annot"><span class="annottext">([TyVarBndrSpec] -&gt; [Type] -&gt; Type -&gt; Type)
-&gt; Q [TyVarBndrSpec] -&gt; Q ([Type] -&gt; Type -&gt; Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(TyVarBndrSpec -&gt; Q TyVarBndrSpec)
-&gt; [TyVarBndrSpec] -&gt; Q [TyVarBndrSpec]
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; [a] -&gt; f [b]
</span><span class="hs-identifier hs-var">traverse</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; TyVarBndrSpec -&gt; Q TyVarBndrSpec
forall (f :: * -&gt; *) flag.
Applicative f =&gt;
(Type -&gt; f Type) -&gt; TyVarBndr_ flag -&gt; f (TyVarBndr_ flag)
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#traverseTVKind"><span class="hs-identifier hs-var">traverseTVKind</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074730"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-2021"></span><span>                                          </span><span class="annot"><span class="annottext">Q ([Type] -&gt; Type -&gt; Type) -&gt; Q [Type] -&gt; Q (Type -&gt; Type)
forall a b. Q (a -&gt; b) -&gt; Q a -&gt; Q b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; [Type] -&gt; Q [Type]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074731"><span class="hs-identifier hs-var">cx</span></a></span><span>
</span><span id="line-2022"></span><span>                                          </span><span class="annot"><span class="annottext">Q (Type -&gt; Type) -&gt; Q Type -&gt; Q Type
forall a b. Q (a -&gt; b) -&gt; Q a -&gt; Q b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074732"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-2023"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074735"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074735"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`AppT`</span></span><span> </span><span id="local-6989586621679074736"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074736"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074735"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Q Type -&gt; Q Type -&gt; Q Type
forall (m :: * -&gt; *). Quote m =&gt; m Type -&gt; m Type -&gt; m Type
</span><span class="hs-operator hs-var">`appT`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074736"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-2024"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ParensT</span></span><span> </span><span id="local-6989586621679074737"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074737"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074737"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-2025"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">InfixT</span></span><span> </span><span id="local-6989586621679074738"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074738"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679074739"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074739"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621679074740"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074740"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q Type
forall (m :: * -&gt; *). Quote m =&gt; Name -&gt; m Type
</span><span class="hs-identifier hs-var">conT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074739"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">Q Type -&gt; Q Type -&gt; Q Type
forall (m :: * -&gt; *). Quote m =&gt; m Type -&gt; m Type -&gt; m Type
</span><span class="hs-operator hs-var">`appT`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074738"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Q Type -&gt; Q Type -&gt; Q Type
forall (m :: * -&gt; *). Quote m =&gt; m Type -&gt; m Type -&gt; m Type
</span><span class="hs-operator hs-var">`appT`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074740"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-2026"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679074741"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074741"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679074742"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074742"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">SigT</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type -&gt; Type) -&gt; Q Type -&gt; Q (Type -&gt; Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074741"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Q (Type -&gt; Type) -&gt; Q Type -&gt; Q Type
forall a b. Q (a -&gt; b) -&gt; Q a -&gt; Q b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074742"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-2027"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span id="local-6989586621679074743"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679074743"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><span class="hs-identifier hs-type">UInfixT</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; Q Type -&gt; Q Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">InfixList -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT1"><span class="hs-identifier hs-var">resolveInfixT1</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var">gatherUInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074743"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,15,0)
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074746"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074746"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`AppKindT`</span></span><span> </span><span id="local-6989586621679074747"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074747"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Q Type -&gt; Q Type -&gt; Q Type
forall (m :: * -&gt; *). Quote m =&gt; m Type -&gt; m Type -&gt; m Type
</span><span class="hs-identifier hs-var">appKindT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074746"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074747"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2030"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ImplicitParamT</span></span><span> </span><span id="local-6989586621679074748"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679074748"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679074749"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074749"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-2031"></span><span>                                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q Type -&gt; Q Type
forall (m :: * -&gt; *). Quote m =&gt; String -&gt; m Type -&gt; m Type
</span><span class="hs-identifier hs-var">implicitParamT</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679074748"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(Q Type -&gt; Q Type) -&gt; Q Type -&gt; Q Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074749"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-cpp">
# endif
</span><span class="hs-cpp"># if MIN_VERSION_template_haskell(2,16,0)
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallVisT</span></span><span> </span><span id="local-6989586621679074750"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074750"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span id="local-6989586621679074751"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074751"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallVisT</span></span><span> </span><span class="annot"><span class="annottext">([TyVarBndrUnit] -&gt; Type -&gt; Type)
-&gt; Q [TyVarBndrUnit] -&gt; Q (Type -&gt; Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(TyVarBndrUnit -&gt; Q TyVarBndrUnit)
-&gt; [TyVarBndrUnit] -&gt; Q [TyVarBndrUnit]
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; [a] -&gt; f [b]
</span><span class="hs-identifier hs-var">traverse</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; TyVarBndrUnit -&gt; Q TyVarBndrUnit
forall (f :: * -&gt; *) flag.
Applicative f =&gt;
(Type -&gt; f Type) -&gt; TyVarBndr_ flag -&gt; f (TyVarBndr_ flag)
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#traverseTVKind"><span class="hs-identifier hs-var">traverseTVKind</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074750"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-2035"></span><span>                                             </span><span class="annot"><span class="annottext">Q (Type -&gt; Type) -&gt; Q Type -&gt; Q Type
forall a b. Q (a -&gt; b) -&gt; Q a -&gt; Q b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074751"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-cpp">
# endif
</span><span class="hs-cpp"># if MIN_VERSION_template_haskell(2,19,0)
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">PromotedInfixT</span></span><span> </span><span id="local-6989586621679074752"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074752"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679074753"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074753"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621679074754"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074754"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-2039"></span><span>                                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q Type
forall (m :: * -&gt; *). Quote m =&gt; Name -&gt; m Type
</span><span class="hs-identifier hs-var">promotedT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074753"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">Q Type -&gt; Q Type -&gt; Q Type
forall (m :: * -&gt; *). Quote m =&gt; m Type -&gt; m Type -&gt; m Type
</span><span class="hs-operator hs-var">`appT`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074752"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Q Type -&gt; Q Type -&gt; Q Type
forall (m :: * -&gt; *). Quote m =&gt; m Type -&gt; m Type -&gt; m Type
</span><span class="hs-operator hs-var">`appT`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074754"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-2040"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span id="local-6989586621679074755"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679074755"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><span class="hs-identifier hs-type">PromotedUInfixT</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span>
</span><span id="line-2041"></span><span>                                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; Q Type -&gt; Q Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">InfixList -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT1"><span class="hs-identifier hs-var">resolveInfixT1</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var">gatherUInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074755"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
# endif
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span id="local-6989586621679074756"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074756"><span class="hs-identifier hs-var">t</span></a></span></span><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074756"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-2044"></span><span>
</span><span id="line-2045"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-type">gatherUInfixT</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a></span><span>
</span><span id="line-2046"></span><span id="gatherUInfixT"><span class="annot"><span class="annottext">gatherUInfixT :: Type -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var hs-var">gatherUInfixT</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">UInfixT</span></span><span> </span><span id="local-6989586621679074757"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074757"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679074758"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074758"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621679074759"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074759"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">InfixList -&gt; Name -&gt; Bool -&gt; InfixList -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#ilAppend"><span class="hs-identifier hs-var">ilAppend</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var">gatherUInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074757"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074758"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var">gatherUInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074759"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,19,0)
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var">gatherUInfixT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">PromotedUInfixT</span></span><span> </span><span id="local-6989586621679074761"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074761"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679074762"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074762"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621679074763"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074763"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">InfixList -&gt; Name -&gt; Bool -&gt; InfixList -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#ilAppend"><span class="hs-identifier hs-var">ilAppend</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var">gatherUInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074761"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074762"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var">gatherUInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074763"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
# endif
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var">gatherUInfixT</span></a></span><span> </span><span id="local-6989586621679074764"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074764"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#ILNil"><span class="hs-identifier hs-var">ILNil</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074764"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-2051"></span><span>
</span><span id="line-2052"></span><span class="hs-comment">-- This can fail due to incompatible fixities</span><span>
</span><span id="line-2053"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT1"><span class="hs-identifier hs-type">resolveInfixT1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeQ</span></span><span>
</span><span id="line-2054"></span><span id="resolveInfixT1"><span class="annot"><span class="annottext">resolveInfixT1 :: InfixList -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT1"><span class="hs-identifier hs-var hs-var">resolveInfixT1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Type, Name, Bool, Fixity)] -&gt; InfixList -&gt; Q Type
</span><a href="#local-6989586621679074766"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-2055"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-2056"></span><span>    </span><span class="annot"><a href="#local-6989586621679074766"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeQ</span></span><span>
</span><span id="line-2057"></span><span>    </span><span id="local-6989586621679074766"><span class="annot"><span class="annottext">go :: [(Type, Name, Bool, Fixity)] -&gt; InfixList -&gt; Q Type
</span><a href="#local-6989586621679074766"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679074767"><span class="annot"><span class="annottext">[(Type, Name, Bool, Fixity)]
</span><a href="#local-6989586621679074767"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ILNil"><span class="hs-identifier hs-type">ILNil</span></a></span><span> </span><span id="local-6989586621679074768"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074768"><span class="hs-identifier hs-var">u</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; (Type, Name, Bool, Fixity) -&gt; Type)
-&gt; Type -&gt; [(Type, Name, Bool, Fixity)] -&gt; Type
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679074769"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074769"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074770"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074770"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679074771"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074771"><span class="hs-identifier hs-var">o</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679074772"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074772"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Fixity
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Name -&gt; Type
</span><a href="#local-6989586621679074773"><span class="hs-identifier hs-var">mkConT</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074772"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074771"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074770"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074769"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074768"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">[(Type, Name, Bool, Fixity)]
</span><a href="#local-6989586621679074767"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2058"></span><span>    </span><span class="annot"><a href="#local-6989586621679074766"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679074774"><span class="annot"><span class="annottext">[(Type, Name, Bool, Fixity)]
</span><a href="#local-6989586621679074774"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ILCons"><span class="hs-identifier hs-type">ILCons</span></a></span><span> </span><span id="local-6989586621679074776"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074776"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679074777"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074777"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621679074778"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074778"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679074779"><span class="annot"><span class="annottext">InfixList
</span><a href="#local-6989586621679074779"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2059"></span><span>      </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679074780"><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679074780"><span class="hs-identifier hs-var">ofx</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Fixity -&gt; Maybe Fixity -&gt; Fixity
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><span class="hs-identifier hs-var">defaultFixity</span></span><span> </span><span class="annot"><span class="annottext">(Maybe Fixity -&gt; Fixity) -&gt; Q (Maybe Fixity) -&gt; Q Fixity
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q (Maybe Fixity)
</span><a href="Language.Haskell.TH.Datatype.html#reifyFixityCompat"><span class="hs-identifier hs-var">reifyFixityCompat</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074777"><span class="hs-identifier hs-var">o</span></a></span><span>
</span><span id="line-2060"></span><span>         </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074782"><span class="annot"><span class="annottext">push :: Q Type
</span><a href="#local-6989586621679074782"><span class="hs-identifier hs-var hs-var">push</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Type, Name, Bool, Fixity)] -&gt; InfixList -&gt; Q Type
</span><a href="#local-6989586621679074766"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074776"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074777"><span class="hs-identifier hs-var">o</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074778"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679074780"><span class="hs-identifier hs-var">ofx</span></a></span><span class="hs-special">)</span><span class="annot"><span class="annottext">(Type, Name, Bool, Fixity)
-&gt; [(Type, Name, Bool, Fixity)] -&gt; [(Type, Name, Bool, Fixity)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[(Type, Name, Bool, Fixity)]
</span><a href="#local-6989586621679074774"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">InfixList
</span><a href="#local-6989586621679074779"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-2061"></span><span>         </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[(Type, Name, Bool, Fixity)]
</span><a href="#local-6989586621679074774"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-2062"></span><span>           </span><span class="hs-special">(</span><span id="local-6989586621679074783"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074783"><span class="hs-identifier hs-var">l1</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679074784"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074784"><span class="hs-identifier hs-var">o1</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679074785"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074785"><span class="hs-identifier hs-var">p1</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679074786"><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679074786"><span class="hs-identifier hs-var">o1fx</span></a></span></span><span class="hs-special">)</span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679074787"><span class="annot"><span class="annottext">[(Type, Name, Bool, Fixity)]
</span><a href="#local-6989586621679074787"><span class="hs-identifier hs-var">ts'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2063"></span><span>             </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Fixity -&gt; Fixity -&gt; Maybe Bool
</span><a href="#local-6989586621679074788"><span class="hs-identifier hs-var">compareFixity</span></a></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679074786"><span class="hs-identifier hs-var">o1fx</span></a></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679074780"><span class="hs-identifier hs-var">ofx</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-2064"></span><span>               </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[(Type, Name, Bool, Fixity)] -&gt; InfixList -&gt; Q Type
</span><a href="#local-6989586621679074766"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Name -&gt; Type
</span><a href="#local-6989586621679074773"><span class="hs-identifier hs-var">mkConT</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074785"><span class="hs-identifier hs-var">p1</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074784"><span class="hs-identifier hs-var">o1</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074783"><span class="hs-identifier hs-var">l1</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074776"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074777"><span class="hs-identifier hs-var">o</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074778"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679074780"><span class="hs-identifier hs-var">ofx</span></a></span><span class="hs-special">)</span><span class="annot"><span class="annottext">(Type, Name, Bool, Fixity)
-&gt; [(Type, Name, Bool, Fixity)] -&gt; [(Type, Name, Bool, Fixity)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[(Type, Name, Bool, Fixity)]
</span><a href="#local-6989586621679074787"><span class="hs-identifier hs-var">ts'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">InfixList
</span><a href="#local-6989586621679074779"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-2065"></span><span>               </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Q Type
</span><a href="#local-6989586621679074782"><span class="hs-identifier hs-var">push</span></a></span><span>
</span><span id="line-2066"></span><span>               </span><span class="annot"><span class="annottext">Maybe Bool
</span><span class="hs-identifier hs-var">Nothing</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q Type
forall a. String -&gt; Q a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Fixity -&gt; Name -&gt; Fixity -&gt; String
</span><a href="#local-6989586621679074789"><span class="hs-identifier hs-var">precedenceError</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074784"><span class="hs-identifier hs-var">o1</span></a></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679074786"><span class="hs-identifier hs-var">o1fx</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074777"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679074780"><span class="hs-identifier hs-var">ofx</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2067"></span><span>           </span><span class="annot"><span class="annottext">[(Type, Name, Bool, Fixity)]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Q Type
</span><a href="#local-6989586621679074782"><span class="hs-identifier hs-var">push</span></a></span><span>
</span><span id="line-2068"></span><span>
</span><span id="line-2069"></span><span>    </span><span class="annot"><a href="#local-6989586621679074773"><span class="hs-identifier hs-type">mkConT</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-2070"></span><span>    </span><span id="local-6989586621679074773"><span class="annot"><span class="annottext">mkConT :: Bool -&gt; Name -&gt; Type
</span><a href="#local-6989586621679074773"><span class="hs-identifier hs-var hs-var">mkConT</span></a></span></span><span> </span><span id="local-6989586621679074790"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074790"><span class="hs-identifier hs-var">promoted</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074790"><span class="hs-identifier hs-var">promoted</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">PromotedT</span></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">ConT</span></span><span>
</span><span id="line-2071"></span><span>
</span><span id="line-2072"></span><span>    </span><span class="annot"><a href="#local-6989586621679074788"><span class="hs-identifier hs-type">compareFixity</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-2073"></span><span>    </span><span id="local-6989586621679074788"><span class="annot"><span class="annottext">compareFixity :: Fixity -&gt; Fixity -&gt; Maybe Bool
</span><a href="#local-6989586621679074788"><span class="hs-identifier hs-var hs-var">compareFixity</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span id="local-6989586621679074793"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679074793"><span class="hs-identifier hs-var">n1</span></a></span></span><span> </span><span class="annot"><span class="annottext">FixityDirection
</span><span class="hs-identifier hs-var">InfixL</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span id="local-6989586621679074795"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679074795"><span class="hs-identifier hs-var">n2</span></a></span></span><span> </span><span class="annot"><span class="annottext">FixityDirection
</span><span class="hs-identifier hs-var">InfixL</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Maybe Bool
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679074793"><span class="hs-identifier hs-var">n1</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679074795"><span class="hs-identifier hs-var">n2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2074"></span><span>    </span><span class="annot"><a href="#local-6989586621679074788"><span class="hs-identifier hs-var">compareFixity</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span id="local-6989586621679074796"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679074796"><span class="hs-identifier hs-var">n1</span></a></span></span><span> </span><span class="annot"><span class="annottext">FixityDirection
</span><span class="hs-identifier hs-var">InfixR</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span id="local-6989586621679074798"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679074798"><span class="hs-identifier hs-var">n2</span></a></span></span><span> </span><span class="annot"><span class="annottext">FixityDirection
</span><span class="hs-identifier hs-var">InfixR</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Maybe Bool
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679074796"><span class="hs-identifier hs-var">n1</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span>  </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679074798"><span class="hs-identifier hs-var">n2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2075"></span><span>    </span><span class="annot"><a href="#local-6989586621679074788"><span class="hs-identifier hs-var">compareFixity</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span id="local-6989586621679074800"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679074800"><span class="hs-identifier hs-var">n1</span></a></span></span><span> </span><span class="annot"><span class="annottext">FixityDirection
</span><span class="hs-identifier">_</span></span><span>     </span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span id="local-6989586621679074801"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679074801"><span class="hs-identifier hs-var">n2</span></a></span></span><span> </span><span class="annot"><span class="annottext">FixityDirection
</span><span class="hs-identifier">_</span></span><span>     </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2076"></span><span>      </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Ordering
forall a. Ord a =&gt; a -&gt; a -&gt; Ordering
</span><span class="hs-identifier hs-var">compare</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679074800"><span class="hs-identifier hs-var">n1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679074801"><span class="hs-identifier hs-var">n2</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-2077"></span><span>        </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">GT</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Maybe Bool
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-2078"></span><span>        </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">LT</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Maybe Bool
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-2079"></span><span>        </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier hs-var">EQ</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Bool
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-2080"></span><span>
</span><span id="line-2081"></span><span>    </span><span class="annot"><a href="#local-6989586621679074789"><span class="hs-identifier hs-type">precedenceError</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-2082"></span><span>    </span><span id="local-6989586621679074789"><span class="annot"><span class="annottext">precedenceError :: Name -&gt; Fixity -&gt; Name -&gt; Fixity -&gt; String
</span><a href="#local-6989586621679074789"><span class="hs-identifier hs-var hs-var">precedenceError</span></a></span></span><span> </span><span id="local-6989586621679074803"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074803"><span class="hs-identifier hs-var">o1</span></a></span></span><span> </span><span id="local-6989586621679074804"><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679074804"><span class="hs-identifier hs-var">ofx1</span></a></span></span><span> </span><span id="local-6989586621679074805"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074805"><span class="hs-identifier hs-var">o2</span></a></span></span><span> </span><span id="local-6989586621679074806"><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679074806"><span class="hs-identifier hs-var">ofx2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2083"></span><span>      </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Precedence parsing error: cannot mix &#8216;&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span>
</span><span id="line-2084"></span><span>      </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074803"><span class="hs-identifier hs-var">o1</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;&#8217; [&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Fixity -&gt; String
</span><a href="Language.Haskell.TH.Datatype.html#showFixity"><span class="hs-identifier hs-var">showFixity</span></a></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679074804"><span class="hs-identifier hs-var">ofx1</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;] and &#8216;&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span>
</span><span id="line-2085"></span><span>      </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074805"><span class="hs-identifier hs-var">o2</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;&#8217; [&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Fixity -&gt; String
</span><a href="Language.Haskell.TH.Datatype.html#showFixity"><span class="hs-identifier hs-var">showFixity</span></a></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679074806"><span class="hs-identifier hs-var">ofx2</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span>
</span><span id="line-2086"></span><span>      </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;] in the same infix type expression&quot;</span></span><span>
</span><span id="line-2087"></span><span>
</span><span id="line-2088"></span><span class="hs-keyword">data</span><span> </span><span id="InfixList"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-var">InfixList</span></a></span></span><span>
</span><span id="line-2089"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ILCons"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ILCons"><span class="hs-identifier hs-var">ILCons</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>      </span><span class="hs-comment">-- The first argument to the type operator</span><span>
</span><span id="line-2090"></span><span>           </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>      </span><span class="hs-comment">-- The name of the infix type operator</span><span>
</span><span id="line-2091"></span><span>           </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>      </span><span class="hs-comment">-- 'True' if this is a promoted infix data constructor,</span><span>
</span><span id="line-2092"></span><span>                     </span><span class="hs-comment">-- 'False' otherwise</span><span>
</span><span id="line-2093"></span><span>           </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a></span><span> </span><span class="hs-comment">-- The rest of the infix applications to resolve</span><span>
</span><span id="line-2094"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ILNil"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ILNil"><span class="hs-identifier hs-var">ILNil</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-2095"></span><span>
</span><span id="line-2096"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ilAppend"><span class="hs-identifier hs-type">ilAppend</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a></span><span>
</span><span id="line-2097"></span><span id="ilAppend"><span class="annot"><span class="annottext">ilAppend :: InfixList -&gt; Name -&gt; Bool -&gt; InfixList -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#ilAppend"><span class="hs-identifier hs-var hs-var">ilAppend</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ILNil"><span class="hs-identifier hs-type">ILNil</span></a></span><span> </span><span id="local-6989586621679074807"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074807"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>            </span><span id="local-6989586621679074808"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074808"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621679074809"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074809"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679074810"><span class="annot"><span class="annottext">InfixList
</span><a href="#local-6989586621679074810"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Bool -&gt; InfixList -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#ILCons"><span class="hs-identifier hs-var">ILCons</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074807"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074808"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074809"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">InfixList
</span><a href="#local-6989586621679074810"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-2098"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ilAppend"><span class="hs-identifier hs-var">ilAppend</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ILCons"><span class="hs-identifier hs-type">ILCons</span></a></span><span> </span><span id="local-6989586621679074811"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074811"><span class="hs-identifier hs-var">l1</span></a></span></span><span> </span><span id="local-6989586621679074812"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074812"><span class="hs-identifier hs-var">o1</span></a></span></span><span> </span><span id="local-6989586621679074813"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074813"><span class="hs-identifier hs-var">p1</span></a></span></span><span> </span><span id="local-6989586621679074814"><span class="annot"><span class="annottext">InfixList
</span><a href="#local-6989586621679074814"><span class="hs-identifier hs-var">r1</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679074815"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074815"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621679074816"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074816"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679074817"><span class="annot"><span class="annottext">InfixList
</span><a href="#local-6989586621679074817"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Bool -&gt; InfixList -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#ILCons"><span class="hs-identifier hs-var">ILCons</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074811"><span class="hs-identifier hs-var">l1</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074812"><span class="hs-identifier hs-var">o1</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074813"><span class="hs-identifier hs-var">p1</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InfixList -&gt; Name -&gt; Bool -&gt; InfixList -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#ilAppend"><span class="hs-identifier hs-var">ilAppend</span></a></span><span> </span><span class="annot"><span class="annottext">InfixList
</span><a href="#local-6989586621679074814"><span class="hs-identifier hs-var">r1</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074815"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679074816"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">InfixList
</span><a href="#local-6989586621679074817"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-cpp">

#else
</span><span class="hs-comment">-- older template-haskell packages don't have UInfixT</span><span>
</span><span id="line-2102"></span><span class="hs-identifier">resolveInfixT</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">return</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2105"></span><span>
</span><span id="line-2106"></span><span class="hs-comment">-- | Render a 'Fixity' as it would appear in Haskell source.</span><span>
</span><span id="line-2107"></span><span class="hs-comment">--</span><span>
</span><span id="line-2108"></span><span class="hs-comment">-- Example: @infixl 5@</span><span>
</span><span id="line-2109"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#showFixity"><span class="hs-identifier hs-type">showFixity</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-2110"></span><span id="showFixity"><span class="annot"><span class="annottext">showFixity :: Fixity -&gt; String
</span><a href="Language.Haskell.TH.Datatype.html#showFixity"><span class="hs-identifier hs-var hs-var">showFixity</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span id="local-6989586621679074818"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679074818"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679074819"><span class="annot"><span class="annottext">FixityDirection
</span><a href="#local-6989586621679074819"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FixityDirection -&gt; String
</span><a href="Language.Haskell.TH.Datatype.html#showFixityDirection"><span class="hs-identifier hs-var">showFixityDirection</span></a></span><span> </span><span class="annot"><span class="annottext">FixityDirection
</span><a href="#local-6989586621679074819"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot; &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679074818"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-2111"></span><span>
</span><span id="line-2112"></span><span>
</span><span id="line-2113"></span><span class="hs-comment">-- | Render a 'FixityDirection' like it would appear in Haskell source.</span><span>
</span><span id="line-2114"></span><span class="hs-comment">--</span><span>
</span><span id="line-2115"></span><span class="hs-comment">-- Examples: @infixl@ @infixr@ @infix@</span><span>
</span><span id="line-2116"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#showFixityDirection"><span class="hs-identifier hs-type">showFixityDirection</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FixityDirection</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-2117"></span><span id="showFixityDirection"><span class="annot"><span class="annottext">showFixityDirection :: FixityDirection -&gt; String
</span><a href="Language.Haskell.TH.Datatype.html#showFixityDirection"><span class="hs-identifier hs-var hs-var">showFixityDirection</span></a></span></span><span> </span><span class="annot"><span class="annottext">FixityDirection
</span><span class="hs-identifier hs-var">InfixL</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;infixl&quot;</span></span><span>
</span><span id="line-2118"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#showFixityDirection"><span class="hs-identifier hs-var">showFixityDirection</span></a></span><span> </span><span class="annot"><span class="annottext">FixityDirection
</span><span class="hs-identifier hs-var">InfixR</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;infixr&quot;</span></span><span>
</span><span id="line-2119"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#showFixityDirection"><span class="hs-identifier hs-var">showFixityDirection</span></a></span><span> </span><span class="annot"><span class="annottext">FixityDirection
</span><span class="hs-identifier hs-var">InfixN</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;infix&quot;</span></span><span>
</span><span id="line-2120"></span><span>
</span><span id="line-2121"></span><span id="local-6989586621679072513"><span id="local-6989586621679072514"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#takeFieldNames"><span class="hs-identifier hs-type">takeFieldNames</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679072513"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679072514"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span></span></span><span>
</span><span id="line-2122"></span><span id="takeFieldNames"><span class="annot"><span class="annottext">takeFieldNames :: forall a b. [(Name, a, b)] -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldNames"><span class="hs-identifier hs-var hs-var">takeFieldNames</span></a></span></span><span> </span><span id="local-6989586621679074821"><span class="annot"><span class="annottext">[(Name, a, b)]
</span><a href="#local-6989586621679074821"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074822"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074822"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074822"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">b
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Name, a, b)]
</span><a href="#local-6989586621679074821"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">]</span><span class="hs-cpp">

#if MIN_VERSION_template_haskell(2,11,0)
</span><span id="local-6989586621679072515"><span id="local-6989586621679072516"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#takeFieldStrictness"><span class="hs-identifier hs-type">takeFieldStrictness</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679072515"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Bang</span></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679072516"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a></span><span class="hs-special">]</span></span></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">takeFieldStrictness</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="hs-identifier">a</span><span class="hs-special">,</span><span class="hs-identifier">Strict</span><span class="hs-special">,</span><span class="hs-identifier">b</span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">FieldStrictness</span><span class="hs-special">]</span><span class="hs-cpp">
#endif
</span><span id="takeFieldStrictness"><span class="annot"><span class="annottext">takeFieldStrictness :: forall a b. [(a, Bang, b)] -&gt; [FieldStrictness]
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldStrictness"><span class="hs-identifier hs-var hs-var">takeFieldStrictness</span></a></span></span><span> </span><span id="local-6989586621679074823"><span class="annot"><span class="annottext">[(a, Bang, b)]
</span><a href="#local-6989586621679074823"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Bang -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-var">normalizeStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">Bang
</span><a href="#local-6989586621679074824"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span id="local-6989586621679074824"><span class="annot"><span class="annottext">Bang
</span><a href="#local-6989586621679074824"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">b
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(a, Bang, b)]
</span><a href="#local-6989586621679074823"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2130"></span><span>
</span><span id="line-2131"></span><span id="local-6989586621679072517"><span id="local-6989586621679072518"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#takeFieldTypes"><span class="hs-identifier hs-type">takeFieldTypes</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679072517"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679072518"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span></span></span><span>
</span><span id="line-2132"></span><span id="takeFieldTypes"><span class="annot"><span class="annottext">takeFieldTypes :: forall a b. [(a, b, Type)] -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldTypes"><span class="hs-identifier hs-var hs-var">takeFieldTypes</span></a></span></span><span> </span><span id="local-6989586621679074825"><span class="annot"><span class="annottext">[(a, b, Type)]
</span><a href="#local-6989586621679074825"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074826"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">b
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span id="local-6989586621679074826"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074826"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(a, b, Type)]
</span><a href="#local-6989586621679074825"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2133"></span><span>
</span><span id="line-2134"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#conHasRecord"><span class="hs-identifier hs-type">conHasRecord</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-2135"></span><span id="conHasRecord"><span class="annot"><span class="annottext">conHasRecord :: Name -&gt; ConstructorInfo -&gt; Bool
</span><a href="Language.Haskell.TH.Datatype.html#conHasRecord"><span class="hs-identifier hs-var hs-var">conHasRecord</span></a></span></span><span> </span><span id="local-6989586621679074827"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074827"><span class="hs-identifier hs-var">recName</span></a></span></span><span> </span><span id="local-6989586621679074828"><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679074828"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2136"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">ConstructorInfo -&gt; ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#constructorVariant"><span class="hs-identifier hs-var">constructorVariant</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679074828"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-2137"></span><span>    </span><span class="annot"><span class="annottext">ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#NormalConstructor"><span class="hs-identifier hs-var">NormalConstructor</span></a></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-2138"></span><span>    </span><span class="annot"><span class="annottext">ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#InfixConstructor"><span class="hs-identifier hs-var">InfixConstructor</span></a></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-2139"></span><span>    </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#RecordConstructor"><span class="hs-identifier hs-type">RecordConstructor</span></a></span><span> </span><span id="local-6989586621679074829"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074829"><span class="hs-identifier hs-var">fields</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074827"><span class="hs-identifier hs-var">recName</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; Bool
forall a. Eq a =&gt; a -&gt; [a] -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-operator hs-var">`elem`</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074829"><span class="hs-identifier hs-var">fields</span></a></span><span>
</span><span id="line-2140"></span><span>
</span><span id="line-2141"></span><span class="hs-comment">------------------------------------------------------------------------</span><span>
</span><span id="line-2142"></span><span>
</span><span id="line-2143"></span><span class="hs-comment">-- | Add universal quantifier for all free variables in the type. This is</span><span>
</span><span id="line-2144"></span><span class="hs-comment">-- useful when constructing a type signature for a declaration.</span><span>
</span><span id="line-2145"></span><span class="hs-comment">-- This code is careful to ensure that the order of the variables quantified</span><span>
</span><span id="line-2146"></span><span class="hs-comment">-- is determined by their order of appearance in the type signature. (In</span><span>
</span><span id="line-2147"></span><span class="hs-comment">-- contrast with being dependent upon the Ord instance for 'Name')</span><span>
</span><span id="line-2148"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#quantifyType"><span class="hs-identifier hs-type">quantifyType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-2149"></span><span id="quantifyType"><span class="annot"><span class="annottext">quantifyType :: Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#quantifyType"><span class="hs-identifier hs-var hs-var">quantifyType</span></a></span></span><span> </span><span id="local-6989586621679074830"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074830"><span class="hs-identifier hs-var">t</span></a></span></span><span>
</span><span id="line-2150"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074832"><span class="hs-identifier hs-var">tvbs</span></a></span><span>
</span><span id="line-2151"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074830"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-2152"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679074833"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074833"><span class="hs-identifier hs-var">tvbs'</span></a></span></span><span> </span><span id="local-6989586621679074834"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074834"><span class="hs-identifier hs-var">ctxt'</span></a></span></span><span> </span><span id="local-6989586621679074835"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074835"><span class="hs-identifier hs-var">t'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074830"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-comment">-- Collapse two consecutive foralls (#63)</span><span>
</span><span id="line-2153"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; [Type] -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074832"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; [TyVarBndrSpec] -&gt; [TyVarBndrSpec]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074833"><span class="hs-identifier hs-var">tvbs'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074834"><span class="hs-identifier hs-var">ctxt'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074835"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-2154"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-2155"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; [Type] -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074832"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074830"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-2156"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-2157"></span><span>    </span><span id="local-6989586621679074832"><span class="annot"><span class="annottext">tvbs :: [TyVarBndrSpec]
</span><a href="#local-6989586621679074832"><span class="hs-identifier hs-var hs-var">tvbs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Specificity -&gt; [TyVarBndrUnit] -&gt; [TyVarBndrSpec]
forall newFlag oldFlag.
newFlag -&gt; [TyVarBndr_ oldFlag] -&gt; [TyVarBndr_ newFlag]
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#changeTVFlags"><span class="hs-identifier hs-var">changeTVFlags</span></a></span><span> </span><span class="annot"><span class="annottext">Specificity
</span><span class="hs-identifier hs-var">SpecifiedSpec</span></span><span> </span><span class="annot"><span class="annottext">([TyVarBndrUnit] -&gt; [TyVarBndrSpec])
-&gt; [TyVarBndrUnit] -&gt; [TyVarBndrSpec]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [TyVarBndrUnit]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier hs-var">freeVariablesWellScoped</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074830"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2158"></span><span>
</span><span id="line-2159"></span><span class="hs-comment">-- | Take a list of 'Type's, find their free variables, and sort them</span><span>
</span><span id="line-2160"></span><span class="hs-comment">-- according to dependency order.</span><span>
</span><span id="line-2161"></span><span class="hs-comment">--</span><span>
</span><span id="line-2162"></span><span class="hs-comment">-- As an example of how this function works, consider the following type:</span><span>
</span><span id="line-2163"></span><span class="hs-comment">--</span><span>
</span><span id="line-2164"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-2165"></span><span class="hs-comment">-- Proxy (a :: k)</span><span>
</span><span id="line-2166"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-2167"></span><span class="hs-comment">--</span><span>
</span><span id="line-2168"></span><span class="hs-comment">-- Calling 'freeVariables' on this type would yield @[a, k]@, since that is</span><span>
</span><span id="line-2169"></span><span class="hs-comment">-- the order in which those variables appear in a left-to-right fashion. But</span><span>
</span><span id="line-2170"></span><span class="hs-comment">-- this order does not preserve the fact that @k@ is the kind of @a@. Moreover,</span><span>
</span><span id="line-2171"></span><span class="hs-comment">-- if you tried writing the type @forall a k. Proxy (a :: k)@, GHC would reject</span><span>
</span><span id="line-2172"></span><span class="hs-comment">-- this, since GHC would demand that @k@ come before @a@.</span><span>
</span><span id="line-2173"></span><span class="hs-comment">--</span><span>
</span><span id="line-2174"></span><span class="hs-comment">-- 'freeVariablesWellScoped' orders the free variables of a type in a way that</span><span>
</span><span id="line-2175"></span><span class="hs-comment">-- preserves this dependency ordering. If one were to call</span><span>
</span><span id="line-2176"></span><span class="hs-comment">-- 'freeVariablesWellScoped' on the type above, it would return</span><span>
</span><span id="line-2177"></span><span class="hs-comment">-- @[k, (a :: k)]@. (This is why 'freeVariablesWellScoped' returns a list of</span><span>
</span><span id="line-2178"></span><span class="hs-comment">-- 'TyVarBndr's instead of 'Name's, since it must make it explicit that @k@</span><span>
</span><span id="line-2179"></span><span class="hs-comment">-- is the kind of @a@.)</span><span>
</span><span id="line-2180"></span><span class="hs-comment">--</span><span>
</span><span id="line-2181"></span><span class="hs-comment">-- 'freeVariablesWellScoped' guarantees the free variables returned will be</span><span>
</span><span id="line-2182"></span><span class="hs-comment">-- ordered such that:</span><span>
</span><span id="line-2183"></span><span class="hs-comment">--</span><span>
</span><span id="line-2184"></span><span class="hs-comment">-- 1. Whenever an explicit kind signature of the form @(A :: K)@ is</span><span>
</span><span id="line-2185"></span><span class="hs-comment">--    encountered, the free variables of @K@ will always appear to the left of</span><span>
</span><span id="line-2186"></span><span class="hs-comment">--    the free variables of @A@ in the returned result.</span><span>
</span><span id="line-2187"></span><span class="hs-comment">--</span><span>
</span><span id="line-2188"></span><span class="hs-comment">-- 2. The constraint in (1) notwithstanding, free variables will appear in</span><span>
</span><span id="line-2189"></span><span class="hs-comment">--    left-to-right order of their original appearance.</span><span>
</span><span id="line-2190"></span><span class="hs-comment">--</span><span>
</span><span id="line-2191"></span><span class="hs-comment">-- On older GHCs, this takes measures to avoid returning explicitly bound</span><span>
</span><span id="line-2192"></span><span class="hs-comment">-- kind variables, which was not possible before @TypeInType@.</span><span>
</span><span id="line-2193"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier hs-type">freeVariablesWellScoped</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span><span>
</span><span id="line-2194"></span><span id="freeVariablesWellScoped"><span class="annot"><span class="annottext">freeVariablesWellScoped :: [Type] -&gt; [TyVarBndrUnit]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier hs-var hs-var">freeVariablesWellScoped</span></a></span></span><span> </span><span id="local-6989586621679074836"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074836"><span class="hs-identifier hs-var">tys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2195"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="annot"><a href="#local-6989586621679074837"><span class="hs-identifier hs-type">fvs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>
</span><span id="line-2196"></span><span>      </span><span id="local-6989586621679074837"><span class="annot"><span class="annottext">fvs :: [Name]
</span><a href="#local-6989586621679074837"><span class="hs-identifier hs-var hs-var">fvs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074836"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-2197"></span><span>
</span><span id="line-2198"></span><span>      </span><span class="annot"><a href="#local-6989586621679074838"><span class="hs-identifier hs-type">varKindSigs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-2199"></span><span>      </span><span id="local-6989586621679074838"><span class="annot"><span class="annottext">varKindSigs :: Map Name Type
</span><a href="#local-6989586621679074838"><span class="hs-identifier hs-var hs-var">varKindSigs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Map Name Type) -&gt; [Type] -&gt; Map Name Type
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; [a] -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074836"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-2200"></span><span>        </span><span class="hs-keyword">where</span><span>
</span><span id="line-2201"></span><span>          </span><span class="annot"><a href="#local-6989586621679074839"><span class="hs-identifier hs-type">go_ty</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-2202"></span><span>          </span><span id="local-6989586621679074839"><span class="annot"><span class="annottext">go_ty :: Type -&gt; Map Name Type
</span><a href="#local-6989586621679074839"><span class="hs-identifier hs-var hs-var">go_ty</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679074840"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074840"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679074841"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074841"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621679074842"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074842"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2203"></span><span>            </span><span class="annot"><span class="annottext">(TyVarBndrSpec -&gt; Map Name Type -&gt; Map Name Type)
-&gt; Map Name Type -&gt; [TyVarBndrSpec] -&gt; Map Name Type
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679074843"><span class="annot"><span class="annottext">TyVarBndrSpec
</span><a href="#local-6989586621679074843"><span class="hs-identifier hs-var">tvb</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.delete</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyVarBndrSpec -&gt; Name
forall flag. TyVarBndr_ flag -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndrSpec
</span><a href="#local-6989586621679074843"><span class="hs-identifier hs-var">tvb</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-2204"></span><span>                  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; Map Name Type) -&gt; [Type] -&gt; Map Name Type
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; [a] -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074845"><span class="hs-identifier hs-var">go_pred</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074841"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
forall a. Monoid a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">`mappend`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074842"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074840"><span class="hs-identifier hs-var">tvbs</span></a></span><span>
</span><span id="line-2205"></span><span>          </span><span class="annot"><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679074846"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074846"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621679074847"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074847"><span class="hs-identifier hs-var">t2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074846"><span class="hs-identifier hs-var">t1</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
forall a. Monoid a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">`mappend`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074847"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-2206"></span><span>          </span><span class="annot"><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679074848"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074848"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679074849"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074849"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2207"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074850"><span class="annot"><span class="annottext">kSigs :: Map Name Type
</span><a href="#local-6989586621679074850"><span class="hs-identifier hs-var hs-var">kSigs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span>                  </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074849"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-cpp">
#else
</span><span>                  </span><span class="hs-identifier">mempty</span><span class="hs-cpp">
#endif
</span><span>            </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074848"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-2214"></span><span>                 </span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679074851"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074851"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.insert</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074851"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074849"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074850"><span class="hs-identifier hs-var">kSigs</span></a></span><span>
</span><span id="line-2215"></span><span>                 </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074848"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
forall a. Monoid a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">`mappend`</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074850"><span class="hs-identifier hs-var">kSigs</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,15,0)
</span><span>          </span><span class="annot"><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppKindT</span></span><span> </span><span id="local-6989586621679074852"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074852"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679074853"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074853"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074852"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
forall a. Monoid a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">`mappend`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074853"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-2218"></span><span>          </span><span class="annot"><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ImplicitParamT</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679074854"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074854"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074854"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,16,0)
</span><span>          </span><span class="annot"><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallVisT</span></span><span> </span><span id="local-6989586621679074855"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074855"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679074856"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074856"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2222"></span><span>            </span><span class="annot"><span class="annottext">(TyVarBndrUnit -&gt; Map Name Type -&gt; Map Name Type)
-&gt; Map Name Type -&gt; [TyVarBndrUnit] -&gt; Map Name Type
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679074857"><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679074857"><span class="hs-identifier hs-var">tvb</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.delete</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyVarBndrUnit -&gt; Name
forall flag. TyVarBndr_ flag -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679074857"><span class="hs-identifier hs-var">tvb</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074856"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074855"><span class="hs-identifier hs-var">tvbs</span></a></span><span class="hs-cpp">
#endif
</span><span>          </span><span class="annot"><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-2225"></span><span>
</span><span id="line-2226"></span><span>          </span><span class="annot"><a href="#local-6989586621679074845"><span class="hs-identifier hs-type">go_pred</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,10,0)
</span><span>          </span><span id="local-6989586621679074845"><span class="annot"><span class="annottext">go_pred :: Type -&gt; Map Name Type
</span><a href="#local-6989586621679074845"><span class="hs-identifier hs-var hs-var">go_pred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679074839"><span class="hs-identifier hs-var">go_ty</span></a></span><span class="hs-cpp">
#else
</span><span>          </span><span class="hs-identifier">go_pred</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">foldMap</span><span> </span><span class="hs-identifier">go_ty</span><span> </span><span class="hs-identifier">ts</span><span>
</span><span id="line-2231"></span><span>          </span><span class="hs-identifier">go_pred</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-identifier">t2</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">go_ty</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-special">`</span><span class="hs-identifier">mappend</span><span class="hs-special">`</span><span> </span><span class="hs-identifier">go_ty</span><span> </span><span class="hs-identifier">t2</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2234"></span><span>      </span><span class="hs-comment">-- | Do a topological sort on a list of tyvars,</span><span>
</span><span id="line-2235"></span><span>      </span><span class="hs-comment">--   so that binders occur before occurrences</span><span>
</span><span id="line-2236"></span><span>      </span><span class="hs-comment">-- E.g. given  [ a::k, k::*, b::k ]</span><span>
</span><span id="line-2237"></span><span>      </span><span class="hs-comment">-- it'll return a well-scoped list [ k::*, a::k, b::k ]</span><span>
</span><span id="line-2238"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-2239"></span><span>      </span><span class="hs-comment">-- This is a deterministic sorting operation</span><span>
</span><span id="line-2240"></span><span>      </span><span class="hs-comment">-- (that is, doesn't depend on Uniques).</span><span>
</span><span id="line-2241"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-2242"></span><span>      </span><span class="hs-comment">-- It is also meant to be stable: that is, variables should not</span><span>
</span><span id="line-2243"></span><span>      </span><span class="hs-comment">-- be reordered unnecessarily.</span><span>
</span><span id="line-2244"></span><span>      </span><span class="annot"><a href="#local-6989586621679074858"><span class="hs-identifier hs-type">scopedSort</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>
</span><span id="line-2245"></span><span>      </span><span id="local-6989586621679074858"><span class="annot"><span class="annottext">scopedSort :: [Name] -&gt; [Name]
</span><a href="#local-6989586621679074858"><span class="hs-identifier hs-var hs-var">scopedSort</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Set Name] -&gt; [Name] -&gt; [Name]
</span><a href="#local-6989586621679074859"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-2246"></span><span>
</span><span id="line-2247"></span><span>      </span><span class="annot"><a href="#local-6989586621679074859"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>     </span><span class="hs-comment">-- already sorted, in reverse order</span><span>
</span><span id="line-2248"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Set</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- each set contains all the variables which must be placed</span><span>
</span><span id="line-2249"></span><span>                       </span><span class="hs-comment">-- before the tv corresponding to the set; they are accumulations</span><span>
</span><span id="line-2250"></span><span>                       </span><span class="hs-comment">-- of the fvs in the sorted tvs' kinds</span><span>
</span><span id="line-2251"></span><span>
</span><span id="line-2252"></span><span>                       </span><span class="hs-comment">-- This list is in 1-to-1 correspondence with the sorted tyvars</span><span>
</span><span id="line-2253"></span><span>                       </span><span class="hs-comment">-- INVARIANT:</span><span>
</span><span id="line-2254"></span><span>                       </span><span class="hs-comment">--   all (\tl -&gt; all (`isSubsetOf` head tl) (tail tl)) (tails fv_list)</span><span>
</span><span id="line-2255"></span><span>                       </span><span class="hs-comment">-- That is, each set in the list is a superset of all later sets.</span><span>
</span><span id="line-2256"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>     </span><span class="hs-comment">-- yet to be sorted</span><span>
</span><span id="line-2257"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>
</span><span id="line-2258"></span><span>      </span><span id="local-6989586621679074859"><span class="annot"><span class="annottext">go :: [Name] -&gt; [Set Name] -&gt; [Name] -&gt; [Name]
</span><a href="#local-6989586621679074859"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679074860"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074860"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span id="local-6989586621679074861"><span class="annot"><span class="annottext">[Set Name]
</span><a href="#local-6989586621679074861"><span class="hs-identifier hs-var">_fv_list</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name]
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074860"><span class="hs-identifier hs-var">acc</span></a></span><span>
</span><span id="line-2259"></span><span>      </span><span class="annot"><a href="#local-6989586621679074859"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679074862"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074862"><span class="hs-identifier hs-var">acc</span></a></span></span><span>  </span><span id="local-6989586621679074863"><span class="annot"><span class="annottext">[Set Name]
</span><a href="#local-6989586621679074863"><span class="hs-identifier hs-var">fv_list</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074864"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074864"><span class="hs-identifier hs-var">tv</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679074865"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074865"><span class="hs-identifier hs-var">tvs</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-2260"></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Set Name] -&gt; [Name] -&gt; [Name]
</span><a href="#local-6989586621679074859"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074866"><span class="hs-identifier hs-var">acc'</span></a></span><span> </span><span class="annot"><span class="annottext">[Set Name]
</span><a href="#local-6989586621679074867"><span class="hs-identifier hs-var">fv_list'</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074865"><span class="hs-identifier hs-var">tvs</span></a></span><span>
</span><span id="line-2261"></span><span>        </span><span class="hs-keyword">where</span><span>
</span><span id="line-2262"></span><span>          </span><span class="hs-special">(</span><span id="local-6989586621679074866"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074866"><span class="hs-identifier hs-var">acc'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074867"><span class="annot"><span class="annottext">[Set Name]
</span><a href="#local-6989586621679074867"><span class="hs-identifier hs-var">fv_list'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Set Name] -&gt; ([Name], [Set Name])
</span><a href="#local-6989586621679074868"><span class="hs-identifier hs-var">insert</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074864"><span class="hs-identifier hs-var">tv</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074862"><span class="hs-identifier hs-var">acc</span></a></span><span> </span><span class="annot"><span class="annottext">[Set Name]
</span><a href="#local-6989586621679074863"><span class="hs-identifier hs-var">fv_list</span></a></span><span>
</span><span id="line-2263"></span><span>
</span><span id="line-2264"></span><span>      </span><span class="annot"><a href="#local-6989586621679074868"><span class="hs-identifier hs-type">insert</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>       </span><span class="hs-comment">-- var to insert</span><span>
</span><span id="line-2265"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>     </span><span class="hs-comment">-- sorted list, in reverse order</span><span>
</span><span id="line-2266"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Set</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- list of fvs, as above</span><span>
</span><span id="line-2267"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Set</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- augmented lists</span><span>
</span><span id="line-2268"></span><span>      </span><span id="local-6989586621679074868"><span class="annot"><span class="annottext">insert :: Name -&gt; [Name] -&gt; [Set Name] -&gt; ([Name], [Set Name])
</span><a href="#local-6989586621679074868"><span class="hs-identifier hs-var hs-var">insert</span></a></span></span><span> </span><span id="local-6989586621679074869"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074869"><span class="hs-identifier hs-var">tv</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>     </span><span class="hs-special">[</span><span class="hs-special">]</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074869"><span class="hs-identifier hs-var">tv</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name -&gt; Set Name
</span><a href="#local-6989586621679074870"><span class="hs-identifier hs-var">kindFVSet</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074869"><span class="hs-identifier hs-var">tv</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-2269"></span><span>      </span><span class="annot"><a href="#local-6989586621679074868"><span class="hs-identifier hs-var">insert</span></a></span><span> </span><span id="local-6989586621679074871"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074871"><span class="hs-identifier hs-var">tv</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074872"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074872"><span class="hs-identifier hs-var">a</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679074873"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074873"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074874"><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679074874"><span class="hs-identifier hs-var">fvs</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679074875"><span class="annot"><span class="annottext">[Set Name]
</span><a href="#local-6989586621679074875"><span class="hs-identifier hs-var">fvss</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-2270"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074871"><span class="hs-identifier hs-var">tv</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Set Name -&gt; Bool
forall a. Ord a =&gt; a -&gt; Set a -&gt; Bool
</span><span class="hs-operator hs-var">`Set.member`</span></span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679074874"><span class="hs-identifier hs-var">fvs</span></a></span><span>
</span><span id="line-2271"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074877"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074877"><span class="hs-identifier hs-var">as'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074878"><span class="annot"><span class="annottext">[Set Name]
</span><a href="#local-6989586621679074878"><span class="hs-identifier hs-var">fvss'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Set Name] -&gt; ([Name], [Set Name])
</span><a href="#local-6989586621679074868"><span class="hs-identifier hs-var">insert</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074871"><span class="hs-identifier hs-var">tv</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074873"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">[Set Name]
</span><a href="#local-6989586621679074875"><span class="hs-identifier hs-var">fvss</span></a></span><span>
</span><span id="line-2272"></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074872"><span class="hs-identifier hs-var">a</span></a></span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074877"><span class="hs-identifier hs-var">as'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679074874"><span class="hs-identifier hs-var">fvs</span></a></span><span> </span><span class="annot"><span class="annottext">Set Name -&gt; Set Name -&gt; Set Name
forall a. Ord a =&gt; Set a -&gt; Set a -&gt; Set a
</span><span class="hs-operator hs-var">`Set.union`</span></span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679074880"><span class="hs-identifier hs-var">fv_tv</span></a></span><span> </span><span class="annot"><span class="annottext">Set Name -&gt; [Set Name] -&gt; [Set Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[Set Name]
</span><a href="#local-6989586621679074878"><span class="hs-identifier hs-var">fvss'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2273"></span><span>
</span><span id="line-2274"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-2275"></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074871"><span class="hs-identifier hs-var">tv</span></a></span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074872"><span class="hs-identifier hs-var">a</span></a></span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074873"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679074874"><span class="hs-identifier hs-var">fvs</span></a></span><span> </span><span class="annot"><span class="annottext">Set Name -&gt; Set Name -&gt; Set Name
forall a. Ord a =&gt; Set a -&gt; Set a -&gt; Set a
</span><span class="hs-operator hs-var">`Set.union`</span></span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679074880"><span class="hs-identifier hs-var">fv_tv</span></a></span><span> </span><span class="annot"><span class="annottext">Set Name -&gt; [Set Name] -&gt; [Set Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679074874"><span class="hs-identifier hs-var">fvs</span></a></span><span> </span><span class="annot"><span class="annottext">Set Name -&gt; [Set Name] -&gt; [Set Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[Set Name]
</span><a href="#local-6989586621679074875"><span class="hs-identifier hs-var">fvss</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2276"></span><span>        </span><span class="hs-keyword">where</span><span>
</span><span id="line-2277"></span><span>          </span><span id="local-6989586621679074880"><span class="annot"><span class="annottext">fv_tv :: Set Name
</span><a href="#local-6989586621679074880"><span class="hs-identifier hs-var hs-var">fv_tv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Set Name
</span><a href="#local-6989586621679074870"><span class="hs-identifier hs-var">kindFVSet</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074871"><span class="hs-identifier hs-var">tv</span></a></span><span>
</span><span id="line-2278"></span><span>
</span><span id="line-2279"></span><span>         </span><span class="hs-comment">-- lists not in correspondence</span><span>
</span><span id="line-2280"></span><span>      </span><span class="annot"><a href="#local-6989586621679074868"><span class="hs-identifier hs-var">insert</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Set Name]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; ([Name], [Set Name])
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;scopedSort&quot;</span></span><span>
</span><span id="line-2281"></span><span>
</span><span id="line-2282"></span><span>      </span><span id="local-6989586621679074870"><span class="annot"><span class="annottext">kindFVSet :: Name -&gt; Set Name
</span><a href="#local-6989586621679074870"><span class="hs-identifier hs-var hs-var">kindFVSet</span></a></span></span><span> </span><span id="local-6989586621679074884"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074884"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2283"></span><span>        </span><span class="annot"><span class="annottext">Set Name -&gt; (Type -&gt; Set Name) -&gt; Maybe Type -&gt; Set Name
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="annot"><span class="annottext">Set Name
forall a. Set a
</span><span class="hs-identifier hs-var">Set.empty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; Set Name
forall a. Ord a =&gt; [a] -&gt; Set a
</span><span class="hs-identifier hs-var">Set.fromList</span></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; Set Name) -&gt; (Type -&gt; [Name]) -&gt; Type -&gt; Set Name
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Maybe Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Map.lookup</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074884"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074838"><span class="hs-identifier hs-var">varKindSigs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2284"></span><span>      </span><span id="local-6989586621679074892"><span class="annot"><span class="annottext">ascribeWithKind :: Name -&gt; TyVarBndr flag
</span><a href="#local-6989586621679074892"><span class="hs-identifier hs-var hs-var">ascribeWithKind</span></a></span></span><span> </span><span id="local-6989586621679074893"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074893"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2285"></span><span>        </span><span class="annot"><span class="annottext">TyVarBndr flag
-&gt; (Type -&gt; TyVarBndr flag) -&gt; Maybe Type -&gt; TyVarBndr flag
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; TyVarBndr flag
forall flag. DefaultBndrFlag flag =&gt; Name -&gt; TyVarBndr flag
</span><span class="hs-identifier hs-var">plainTV</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074893"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; TyVarBndr flag
forall flag. DefaultBndrFlag flag =&gt; Name -&gt; Type -&gt; TyVarBndr flag
</span><span class="hs-identifier hs-var">kindedTV</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074893"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Maybe Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Map.lookup</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074893"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074838"><span class="hs-identifier hs-var">varKindSigs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2286"></span><span>
</span><span id="line-2287"></span><span>      </span><span class="hs-comment">-- An annoying wrinkle: GHCs before 8.0 don't support explicitly</span><span>
</span><span id="line-2288"></span><span>      </span><span class="hs-comment">-- quantifying kinds, so something like @forall k (a :: k)@ would be</span><span>
</span><span id="line-2289"></span><span>      </span><span class="hs-comment">-- rejected. To work around this, we filter out any binders whose names</span><span>
</span><span id="line-2290"></span><span>      </span><span class="hs-comment">-- also appear in a kind on old GHCs.</span><span>
</span><span id="line-2291"></span><span>      </span><span id="local-6989586621679074894"><span class="annot"><span class="annottext">isKindBinderOnOldGHCs :: b -&gt; Bool
</span><a href="#local-6989586621679074894"><span class="hs-identifier hs-var hs-var">isKindBinderOnOldGHCs</span></a></span></span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 800
</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; b -&gt; Bool
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-cpp">
#else
</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">`</span><span class="hs-identifier">elem</span><span class="hs-special">`</span><span> </span><span class="hs-identifier">kindVars</span><span class="hs-special">)</span><span>
</span><span id="line-2296"></span><span>          </span><span class="hs-keyword">where</span><span>
</span><span id="line-2297"></span><span>            </span><span class="hs-identifier">kindVars</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">Map.elems</span><span> </span><span class="hs-identifier">varKindSigs</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2300"></span><span>  </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; TyVarBndrUnit) -&gt; [Name] -&gt; [TyVarBndrUnit]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; TyVarBndrUnit
forall flag. DefaultBndrFlag flag =&gt; Name -&gt; TyVarBndr flag
</span><a href="#local-6989586621679074892"><span class="hs-identifier hs-var">ascribeWithKind</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; [TyVarBndrUnit]) -&gt; [Name] -&gt; [TyVarBndrUnit]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-2301"></span><span>     </span><span class="annot"><span class="annottext">(Name -&gt; Bool) -&gt; [Name] -&gt; [Name]
forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">filter</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Bool) -&gt; (Name -&gt; Bool) -&gt; Name -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Bool
forall {b}. b -&gt; Bool
</span><a href="#local-6989586621679074894"><span class="hs-identifier hs-var">isKindBinderOnOldGHCs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; [Name]) -&gt; [Name] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-2302"></span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; [Name]
</span><a href="#local-6989586621679074858"><span class="hs-identifier hs-var">scopedSort</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679074837"><span class="hs-identifier hs-var">fvs</span></a></span><span>
</span><span id="line-2303"></span><span>
</span><span id="line-2304"></span><span class="annot"><span class="hs-comment">-- | Substitute all of the free variables in a type with fresh ones</span></span><span>
</span><span id="line-2305"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#freshenFreeVariables"><span class="hs-identifier hs-type">freshenFreeVariables</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-2306"></span><span id="freshenFreeVariables"><span class="annot"><span class="annottext">freshenFreeVariables :: Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#freshenFreeVariables"><span class="hs-identifier hs-var hs-var">freshenFreeVariables</span></a></span></span><span> </span><span id="local-6989586621679074896"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074896"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2307"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679074903"><span class="annot"><span class="annottext">xs :: [(Name, Q Type)]
</span><a href="#local-6989586621679074903"><span class="hs-identifier hs-var hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074904"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Type) -&gt; Q Name -&gt; Q Type
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; Q Name
forall (m :: * -&gt; *). Quote m =&gt; String -&gt; m Name
</span><span class="hs-identifier hs-var">newName</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074904"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679074904"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074904"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074896"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2308"></span><span>     </span><span id="local-6989586621679074905"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074905"><span class="hs-identifier hs-var">subst</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Map Name (Q Type) -&gt; Q (Map Name Type)
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; Map Name (m a) -&gt; m (Map Name a)
</span><span class="hs-identifier hs-var">T.sequence</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(Name, Q Type)] -&gt; Map Name (Q Type)
forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.fromList</span></span><span> </span><span class="annot"><span class="annottext">[(Name, Q Type)]
</span><a href="#local-6989586621679074903"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2309"></span><span>     </span><span class="annot"><span class="annottext">Type -&gt; Q Type
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074905"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074896"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2310"></span><span>
</span><span id="line-2311"></span><span>
</span><span id="line-2312"></span><span class="annot"><span class="hs-comment">-- | Class for types that support type variable substitution.</span></span><span>
</span><span id="line-2313"></span><span class="hs-keyword">class</span><span> </span><span id="TypeSubstitution"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier hs-var">TypeSubstitution</span></a></span></span><span> </span><span id="local-6989586621679072490"><span class="annot"><a href="#local-6989586621679072490"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-2314"></span><span>  </span><span class="hs-comment">-- | Apply a type variable substitution.</span><span>
</span><span id="line-2315"></span><span>  </span><span id="applySubstitution"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-type">applySubstitution</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679072490"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679072490"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-2316"></span><span>  </span><span class="hs-comment">-- | Compute the free type variables</span><span>
</span><span id="line-2317"></span><span>  </span><span id="freeVariables"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-type">freeVariables</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679072490"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>
</span><span id="line-2318"></span><span>
</span><span id="line-2319"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679072333"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier hs-type">TypeSubstitution</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072333"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier hs-type">TypeSubstitution</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072333"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-2320"></span><span>  </span><span id="local-6989586621679074913"><span class="annot"><span class="annottext">freeVariables :: [a] -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var hs-var hs-var hs-var">freeVariables</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">nub</span></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; [Name]) -&gt; ([a] -&gt; [Name]) -&gt; [a] -&gt; [Name]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">[[Name]] -&gt; [Name]
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="annot"><span class="annottext">([[Name]] -&gt; [Name]) -&gt; ([a] -&gt; [[Name]]) -&gt; [a] -&gt; [Name]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; [Name]) -&gt; [a] -&gt; [[Name]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span>
</span><span id="line-2321"></span><span>  </span><span id="local-6989586621679074917"><span class="annot"><span class="annottext">applySubstitution :: Map Name Type -&gt; [a] -&gt; [a]
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var hs-var hs-var hs-var">applySubstitution</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; a) -&gt; [a] -&gt; [a]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">((a -&gt; a) -&gt; [a] -&gt; [a])
-&gt; (Map Name Type -&gt; a -&gt; a) -&gt; Map Name Type -&gt; [a] -&gt; [a]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; a -&gt; a
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span>
</span><span id="line-2322"></span><span>
</span><span id="line-2323"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier hs-type">TypeSubstitution</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-2324"></span><span>  </span><span id="local-6989586621679074920"><span class="annot"><span class="annottext">applySubstitution :: Map Name Type -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var hs-var hs-var hs-var">applySubstitution</span></a></span></span><span> </span><span id="local-6989586621679074921"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074921"><span class="hs-identifier hs-var">subst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-2325"></span><span>    </span><span class="hs-keyword">where</span><span>
</span><span id="line-2326"></span><span>      </span><span id="local-6989586621679074922"><span class="annot"><span class="annottext">go :: Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679074929"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074929"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621679074930"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074930"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679074931"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074931"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2327"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074932"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074932"><span class="hs-identifier hs-var">subst'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074933"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074933"><span class="hs-identifier hs-var">tvs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type
-&gt; [TyVarBndrSpec] -&gt; (Map Name Type, [TyVarBndrSpec])
forall flag.
Map Name Type
-&gt; [TyVarBndr_ flag] -&gt; (Map Name Type, [TyVarBndr_ flag])
</span><a href="Language.Haskell.TH.Datatype.html#substTyVarBndrs"><span class="hs-identifier hs-var">substTyVarBndrs</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074921"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074929"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-2328"></span><span>        </span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; [Type] -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074933"><span class="hs-identifier hs-var">tvs'</span></a></span><span>
</span><span id="line-2329"></span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; [Type] -&gt; [Type]
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074932"><span class="hs-identifier hs-var">subst'</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074930"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2330"></span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074932"><span class="hs-identifier hs-var">subst'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074931"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2331"></span><span>      </span><span class="annot"><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679074935"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074935"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679074936"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074936"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074935"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074936"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2332"></span><span>      </span><span class="annot"><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679074937"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074937"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679074938"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074938"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">SigT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074937"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074921"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074938"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- k could be Kind</span><span>
</span><span id="line-2333"></span><span>      </span><span class="annot"><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679074939"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074939"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Map Name Type -&gt; Type
forall k a. Ord k =&gt; a -&gt; k -&gt; Map k a -&gt; a
</span><span class="hs-identifier hs-var">Map.findWithDefault</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074939"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074939"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074921"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>      </span><span class="annot"><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">InfixT</span></span><span> </span><span id="local-6989586621679074941"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074941"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679074942"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074942"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679074943"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074943"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">InfixT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074941"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074942"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074943"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2336"></span><span>      </span><span class="annot"><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">UInfixT</span></span><span> </span><span id="local-6989586621679074944"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074944"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679074945"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074945"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679074946"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074946"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">UInfixT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074944"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074945"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074946"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2337"></span><span>      </span><span class="annot"><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ParensT</span></span><span> </span><span id="local-6989586621679074947"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074947"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><span class="hs-identifier hs-var">ParensT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074947"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,15,0)
</span><span>      </span><span class="annot"><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppKindT</span></span><span> </span><span id="local-6989586621679074948"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074948"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679074949"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074949"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppKindT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074948"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074949"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2341"></span><span>      </span><span class="annot"><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ImplicitParamT</span></span><span> </span><span id="local-6989586621679074950"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679074950"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679074951"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074951"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-2342"></span><span>                         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ImplicitParamT</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679074950"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074951"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,16,0)
</span><span>      </span><span class="annot"><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallVisT</span></span><span> </span><span id="local-6989586621679074952"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074952"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621679074953"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074953"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2346"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679074954"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074954"><span class="hs-identifier hs-var">subst'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679074955"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074955"><span class="hs-identifier hs-var">tvs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type
-&gt; [TyVarBndrUnit] -&gt; (Map Name Type, [TyVarBndrUnit])
forall flag.
Map Name Type
-&gt; [TyVarBndr_ flag] -&gt; (Map Name Type, [TyVarBndr_ flag])
</span><a href="Language.Haskell.TH.Datatype.html#substTyVarBndrs"><span class="hs-identifier hs-var">substTyVarBndrs</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074921"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074952"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-2347"></span><span>        </span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallVisT</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679074955"><span class="hs-identifier hs-var">tvs'</span></a></span><span>
</span><span id="line-2348"></span><span>                   </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074954"><span class="hs-identifier hs-var">subst'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074953"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,19,0)
</span><span>      </span><span class="annot"><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">PromotedInfixT</span></span><span> </span><span id="local-6989586621679074956"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074956"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679074957"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074957"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679074958"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074958"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-2352"></span><span>                         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">PromotedInfixT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074956"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074957"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074958"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2353"></span><span>      </span><span class="annot"><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">PromotedUInfixT</span></span><span> </span><span id="local-6989586621679074959"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074959"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679074960"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074960"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679074961"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074961"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-2354"></span><span>                         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">PromotedUInfixT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074959"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679074960"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074961"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>      </span><span class="annot"><a href="#local-6989586621679074922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679074962"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074962"><span class="hs-identifier hs-var">t</span></a></span></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074962"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-2357"></span><span>
</span><span id="line-2358"></span><span>      </span><span id="local-6989586621679072621"><span id="local-6989586621679072622"><span class="annot"><a href="#local-6989586621679074963"><span class="hs-identifier hs-type">subst_tvbs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072621"><span class="hs-identifier hs-type">flag</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679072622"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679072622"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-2359"></span><span>      </span><span id="local-6989586621679074963"><span class="annot"><span class="annottext">subst_tvbs :: forall flag a. [TyVarBndr_ flag] -&gt; (Map Name Type -&gt; a) -&gt; a
</span><a href="#local-6989586621679074963"><span class="hs-identifier hs-var hs-var">subst_tvbs</span></a></span></span><span> </span><span id="local-6989586621679074966"><span class="annot"><span class="annottext">[TyVarBndr_ flag]
</span><a href="#local-6989586621679074966"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621679074967"><span class="annot"><span class="annottext">Map Name Type -&gt; a
</span><a href="#local-6989586621679074967"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; a
</span><a href="#local-6989586621679074967"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">(Map Name Type -&gt; a) -&gt; Map Name Type -&gt; a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Map Name Type -&gt; Name -&gt; Map Name Type)
-&gt; Map Name Type -&gt; [Name] -&gt; Map Name Type
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl'</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Name -&gt; Map Name Type -&gt; Map Name Type)
-&gt; Map Name Type -&gt; Name -&gt; Map Name Type
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.delete</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679074921"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(TyVarBndr_ flag -&gt; Name) -&gt; [TyVarBndr_ flag] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr_ flag -&gt; Name
forall flag. TyVarBndr_ flag -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr_ flag]
</span><a href="#local-6989586621679074966"><span class="hs-identifier hs-var">tvs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2360"></span><span>
</span><span id="line-2361"></span><span>  </span><span id="local-6989586621679074996"><span class="annot"><span class="annottext">freeVariables :: Type -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var hs-var hs-var hs-var">freeVariables</span></a></span></span><span> </span><span id="local-6989586621679074997"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074997"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2362"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679074997"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-2363"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679074998"><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074998"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621679074999"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074999"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679075000"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075000"><span class="hs-identifier hs-var">t'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2364"></span><span>          </span><span class="annot"><span class="annottext">[TyVarBndrSpec] -&gt; [Name] -&gt; [Name]
forall flag. [TyVarBndr_ flag] -&gt; [Name] -&gt; [Name]
</span><a href="#local-6989586621679075001"><span class="hs-identifier hs-var">fvs_under_forall</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrSpec]
</span><a href="#local-6989586621679074998"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679074999"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075000"><span class="hs-identifier hs-var">t'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2365"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679075002"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075002"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679075003"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075003"><span class="hs-identifier hs-var">x</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075002"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075003"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-2366"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679075004"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075004"><span class="hs-identifier hs-var">t'</span></a></span></span><span> </span><span id="local-6989586621679075005"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075005"><span class="hs-identifier hs-var">k</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075004"><span class="hs-identifier hs-var">t'</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075005"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-2367"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679075006"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075006"><span class="hs-identifier hs-var">v</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075006"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">]</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>      </span><span class="annot"><span class="hs-identifier hs-type">InfixT</span></span><span> </span><span id="local-6989586621679075007"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075007"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679075008"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075008"><span class="hs-identifier hs-var">r</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075007"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075008"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-2370"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">UInfixT</span></span><span> </span><span id="local-6989586621679075009"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075009"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679075010"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075010"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075009"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075010"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-2371"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">ParensT</span></span><span> </span><span id="local-6989586621679075011"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075011"><span class="hs-identifier hs-var">t'</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075011"><span class="hs-identifier hs-var">t'</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,15,0)
</span><span>      </span><span class="annot"><span class="hs-identifier hs-type">AppKindT</span></span><span> </span><span id="local-6989586621679075012"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075012"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679075013"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075013"><span class="hs-identifier hs-var">k</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075012"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075013"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-2375"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">ImplicitParamT</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679075014"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075014"><span class="hs-identifier hs-var">t</span></a></span></span><span>
</span><span id="line-2376"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075014"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,16,0)
</span><span>      </span><span class="annot"><span class="hs-identifier hs-type">ForallVisT</span></span><span> </span><span id="local-6989586621679075015"><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679075015"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621679075016"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075016"><span class="hs-identifier hs-var">t'</span></a></span></span><span>
</span><span id="line-2380"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit] -&gt; [Name] -&gt; [Name]
forall flag. [TyVarBndr_ flag] -&gt; [Name] -&gt; [Name]
</span><a href="#local-6989586621679075001"><span class="hs-identifier hs-var">fvs_under_forall</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndrUnit]
</span><a href="#local-6989586621679075015"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075016"><span class="hs-identifier hs-var">t'</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,19,0)
</span><span>      </span><span class="annot"><span class="hs-identifier hs-type">PromotedInfixT</span></span><span> </span><span id="local-6989586621679075017"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075017"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679075018"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075018"><span class="hs-identifier hs-var">r</span></a></span></span><span>
</span><span id="line-2384"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075017"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075018"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-2385"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">PromotedUInfixT</span></span><span> </span><span id="local-6989586621679075019"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075019"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679075020"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075020"><span class="hs-identifier hs-var">r</span></a></span></span><span>
</span><span id="line-2386"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075019"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075020"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-cpp">
#endif
</span><span>      </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-2389"></span><span>    </span><span class="hs-keyword">where</span><span>
</span><span id="line-2390"></span><span>      </span><span id="local-6989586621679072628"><span class="annot"><a href="#local-6989586621679075001"><span class="hs-identifier hs-type">fvs_under_forall</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072628"><span class="hs-identifier hs-type">flag</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span></span><span>
</span><span id="line-2391"></span><span>      </span><span id="local-6989586621679075001"><span class="annot"><span class="annottext">fvs_under_forall :: forall flag. [TyVarBndr_ flag] -&gt; [Name] -&gt; [Name]
</span><a href="#local-6989586621679075001"><span class="hs-identifier hs-var hs-var">fvs_under_forall</span></a></span></span><span> </span><span id="local-6989586621679075024"><span class="annot"><span class="annottext">[TyVarBndr_ flag]
</span><a href="#local-6989586621679075024"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621679075025"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679075025"><span class="hs-identifier hs-var">fvs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2392"></span><span>        </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(TyVarBndr_ flag -&gt; Type) -&gt; [TyVarBndr_ flag] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr_ flag -&gt; Type
forall flag. TyVarBndr_ flag -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvKind"><span class="hs-identifier hs-var">tvKind</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr_ flag]
</span><a href="#local-6989586621679075024"><span class="hs-identifier hs-var">tvs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679075025"><span class="hs-identifier hs-var">fvs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2393"></span><span>        </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">\\</span></span><span> </span><span class="annot"><span class="annottext">(TyVarBndr_ flag -&gt; Name) -&gt; [TyVarBndr_ flag] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr_ flag -&gt; Name
forall flag. TyVarBndr_ flag -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr_ flag]
</span><a href="#local-6989586621679075024"><span class="hs-identifier hs-var">tvs</span></a></span><span>
</span><span id="line-2394"></span><span>
</span><span id="line-2395"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier hs-type">TypeSubstitution</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-2396"></span><span>  </span><span id="local-6989586621679075035"><span class="annot"><span class="annottext">freeVariables :: ConstructorInfo -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var hs-var hs-var hs-var">freeVariables</span></a></span></span><span> </span><span id="local-6989586621679075036"><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679075036"><span class="hs-identifier hs-var">ci</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2397"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(TyVarBndrUnit -&gt; Type) -&gt; [TyVarBndrUnit] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit -&gt; Type
forall flag. TyVarBndr_ flag -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvKind"><span class="hs-identifier hs-var">tvKind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConstructorInfo -&gt; [TyVarBndrUnit]
</span><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var">constructorVars</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679075036"><span class="hs-identifier hs-var">ci</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-2398"></span><span>          </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConstructorInfo -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#constructorContext"><span class="hs-identifier hs-var">constructorContext</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679075036"><span class="hs-identifier hs-var">ci</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2399"></span><span>          </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConstructorInfo -&gt; [Type]
</span><a href="Language.Haskell.TH.Datatype.html#constructorFields"><span class="hs-identifier hs-var">constructorFields</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679075036"><span class="hs-identifier hs-var">ci</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-2400"></span><span>      </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">\\</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyVarBndrUnit -&gt; Name
forall flag. TyVarBndr_ flag -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">(TyVarBndrUnit -&gt; Name) -&gt; [TyVarBndrUnit] -&gt; [Name]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo -&gt; [TyVarBndrUnit]
</span><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var">constructorVars</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679075036"><span class="hs-identifier hs-var">ci</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2401"></span><span>
</span><span id="line-2402"></span><span>  </span><span id="local-6989586621679075040"><span class="annot"><span class="annottext">applySubstitution :: Map Name Type -&gt; ConstructorInfo -&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var hs-var hs-var hs-var">applySubstitution</span></a></span></span><span> </span><span id="local-6989586621679075041"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075041"><span class="hs-identifier hs-var">subst</span></a></span></span><span> </span><span id="local-6989586621679075042"><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679075042"><span class="hs-identifier hs-var">ci</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2403"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679075045"><span class="annot"><span class="annottext">subst' :: Map Name Type
</span><a href="#local-6989586621679075045"><span class="hs-identifier hs-var hs-var">subst'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Map Name Type -&gt; Name -&gt; Map Name Type)
-&gt; Map Name Type -&gt; [Name] -&gt; Map Name Type
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl'</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Name -&gt; Map Name Type -&gt; Map Name Type)
-&gt; Map Name Type -&gt; Name -&gt; Map Name Type
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.delete</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075041"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(TyVarBndrUnit -&gt; Name) -&gt; [TyVarBndrUnit] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit -&gt; Name
forall flag. TyVarBndr_ flag -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConstructorInfo -&gt; [TyVarBndrUnit]
</span><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var">constructorVars</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679075042"><span class="hs-identifier hs-var">ci</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-2404"></span><span>    </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679075042"><span class="hs-identifier hs-var">ci</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var">constructorVars</span></a></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#mapTVKind"><span class="hs-identifier hs-type">mapTVKind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-type">applySubstitution</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679075045"><span class="hs-identifier hs-type">subst'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-2405"></span><span>                                  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var">constructorVars</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679075042"><span class="hs-identifier hs-type">ci</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2406"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#constructorContext"><span class="hs-identifier hs-var">constructorContext</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-type">applySubstitution</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679075045"><span class="hs-identifier hs-type">subst'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#constructorContext"><span class="hs-identifier hs-var">constructorContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679075042"><span class="hs-identifier hs-type">ci</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2407"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#constructorFields"><span class="hs-identifier hs-var">constructorFields</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-type">applySubstitution</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679075045"><span class="hs-identifier hs-type">subst'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#constructorFields"><span class="hs-identifier hs-var">constructorFields</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679075042"><span class="hs-identifier hs-type">ci</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2408"></span><span>       </span><span class="hs-special">}</span><span>
</span><span id="line-2409"></span><span>
</span><span id="line-2410"></span><span class="hs-comment">-- 'Pred' became a type synonym for 'Type'</span><span class="hs-cpp">
#if !MIN_VERSION_template_haskell(2,10,0)
</span><span class="hs-keyword">instance</span><span> </span><span class="hs-identifier">TypeSubstitution</span><span> </span><span class="hs-identifier">Pred</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-2413"></span><span>  </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">xs</span><span>
</span><span id="line-2414"></span><span>  </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-identifier">y</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-special">`</span><span class="hs-identifier">union</span><span class="hs-special">`</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">y</span><span>
</span><span id="line-2415"></span><span>
</span><span id="line-2416"></span><span>  </span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">p</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">p</span><span> </span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span>
</span><span id="line-2417"></span><span>  </span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">p</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-identifier">y</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">p</span><span> </span><span class="hs-identifier">x</span><span class="hs-special">)</span><span>
</span><span id="line-2418"></span><span>                                            </span><span class="hs-special">(</span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">p</span><span> </span><span class="hs-identifier">y</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2421"></span><span class="hs-comment">-- 'Kind' became a type synonym for 'Type'. Previously there were no kind variables</span><span class="hs-cpp">
#if !MIN_VERSION_template_haskell(2,8,0)
</span><span class="hs-keyword">instance</span><span> </span><span class="hs-identifier">TypeSubstitution</span><span> </span><span class="hs-identifier">Kind</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-2424"></span><span>  </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-2425"></span><span>  </span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">k</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">k</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2428"></span><span class="hs-comment">-- | Substitutes into the kinds of type variable binders. This makes an effort</span><span>
</span><span id="line-2429"></span><span class="hs-comment">-- to avoid capturing the 'TyVarBndr' names during substitution by</span><span>
</span><span id="line-2430"></span><span class="hs-comment">-- alpha-renaming names if absolutely necessary. For a version of this function</span><span>
</span><span id="line-2431"></span><span class="hs-comment">-- which does /not/ avoid capture, see 'substTyVarBndrKinds'.</span><span>
</span><span id="line-2432"></span><span id="local-6989586621679072618"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#substTyVarBndrs"><span class="hs-identifier hs-type">substTyVarBndrs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072618"><span class="hs-identifier hs-type">flag</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072618"><span class="hs-identifier hs-type">flag</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span></span><span>
</span><span id="line-2433"></span><span id="substTyVarBndrs"><span class="annot"><span class="annottext">substTyVarBndrs :: forall flag.
Map Name Type
-&gt; [TyVarBndr_ flag] -&gt; (Map Name Type, [TyVarBndr_ flag])
</span><a href="Language.Haskell.TH.Datatype.html#substTyVarBndrs"><span class="hs-identifier hs-var hs-var">substTyVarBndrs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Map Name Type
 -&gt; TyVarBndr_ flag -&gt; (Map Name Type, TyVarBndr_ flag))
-&gt; Map Name Type
-&gt; [TyVarBndr_ flag]
-&gt; (Map Name Type, [TyVarBndr_ flag])
forall (t :: * -&gt; *) s a b.
Traversable t =&gt;
(s -&gt; a -&gt; (s, b)) -&gt; s -&gt; t a -&gt; (s, t b)
</span><span class="hs-identifier hs-var">mapAccumL</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type
-&gt; TyVarBndr_ flag -&gt; (Map Name Type, TyVarBndr_ flag)
forall flag.
Map Name Type
-&gt; TyVarBndr_ flag -&gt; (Map Name Type, TyVarBndr_ flag)
</span><a href="Language.Haskell.TH.Datatype.html#substTyVarBndr"><span class="hs-identifier hs-var">substTyVarBndr</span></a></span><span>
</span><span id="line-2434"></span><span>
</span><span id="line-2435"></span><span class="annot"><span class="hs-comment">-- | The workhorse for 'substTyVarBndrs'.</span></span><span>
</span><span id="line-2436"></span><span id="local-6989586621679072637"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#substTyVarBndr"><span class="hs-identifier hs-type">substTyVarBndr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072637"><span class="hs-identifier hs-type">flag</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072637"><span class="hs-identifier hs-type">flag</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-2437"></span><span id="substTyVarBndr"><span class="annot"><span class="annottext">substTyVarBndr :: forall flag.
Map Name Type
-&gt; TyVarBndr_ flag -&gt; (Map Name Type, TyVarBndr_ flag)
</span><a href="Language.Haskell.TH.Datatype.html#substTyVarBndr"><span class="hs-identifier hs-var hs-var">substTyVarBndr</span></a></span></span><span> </span><span id="local-6989586621679075059"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075059"><span class="hs-identifier hs-var">subst</span></a></span></span><span> </span><span id="local-6989586621679075060"><span class="annot"><span class="annottext">TyVarBndr_ flag
</span><a href="#local-6989586621679075060"><span class="hs-identifier hs-var">tvb</span></a></span></span><span>
</span><span id="line-2438"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075061"><span class="hs-identifier hs-var">tvbName</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Bool
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Bool
</span><span class="hs-operator hs-var">`Map.member`</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075059"><span class="hs-identifier hs-var">subst</span></a></span><span>
</span><span id="line-2439"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.delete</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075061"><span class="hs-identifier hs-var">tvbName</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075059"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; TyVarBndr_ flag -&gt; TyVarBndr_ flag
forall flag. (Type -&gt; Type) -&gt; TyVarBndr_ flag -&gt; TyVarBndr_ flag
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#mapTVKind"><span class="hs-identifier hs-var">mapTVKind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075059"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">TyVarBndr_ flag
</span><a href="#local-6989586621679075060"><span class="hs-identifier hs-var">tvb</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2440"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075061"><span class="hs-identifier hs-var">tvbName</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Set Name -&gt; Bool
forall a. Ord a =&gt; a -&gt; Set a -&gt; Bool
</span><span class="hs-operator hs-var">`Set.notMember`</span></span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679075064"><span class="hs-identifier hs-var">substRangeFVs</span></a></span><span>
</span><span id="line-2441"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075059"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; TyVarBndr_ flag -&gt; TyVarBndr_ flag
forall flag. (Type -&gt; Type) -&gt; TyVarBndr_ flag -&gt; TyVarBndr_ flag
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#mapTVKind"><span class="hs-identifier hs-var">mapTVKind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075059"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">TyVarBndr_ flag
</span><a href="#local-6989586621679075060"><span class="hs-identifier hs-var">tvb</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2442"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-2443"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679075065"><span class="annot"><span class="annottext">tvbName' :: Name
</span><a href="#local-6989586621679075065"><span class="hs-identifier hs-var hs-var">tvbName'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name
</span><a href="#local-6989586621679075066"><span class="hs-identifier hs-var">evade</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075061"><span class="hs-identifier hs-var">tvbName</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-2444"></span><span>    </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.insert</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075061"><span class="hs-identifier hs-var">tvbName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075065"><span class="hs-identifier hs-var">tvbName'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075059"><span class="hs-identifier hs-var">subst</span></a></span><span>
</span><span id="line-2445"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Name)
-&gt; (flag -&gt; flag)
-&gt; (Type -&gt; Type)
-&gt; TyVarBndr_ flag
-&gt; TyVarBndr_ flag
forall flag flag'.
(Name -&gt; Name)
-&gt; (flag -&gt; flag')
-&gt; (Type -&gt; Type)
-&gt; TyVarBndr_ flag
-&gt; TyVarBndr_ flag'
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#mapTV"><span class="hs-identifier hs-var">mapTV</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075065"><span class="hs-identifier hs-var">tvbName'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">flag -&gt; flag
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075059"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">TyVarBndr_ flag
</span><a href="#local-6989586621679075060"><span class="hs-identifier hs-var">tvb</span></a></span><span>
</span><span id="line-2446"></span><span>    </span><span class="hs-special">)</span><span>
</span><span id="line-2447"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-2448"></span><span>    </span><span class="annot"><a href="#local-6989586621679075061"><span class="hs-identifier hs-type">tvbName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-2449"></span><span>    </span><span id="local-6989586621679075061"><span class="annot"><span class="annottext">tvbName :: Name
</span><a href="#local-6989586621679075061"><span class="hs-identifier hs-var hs-var">tvbName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyVarBndr_ flag -&gt; Name
forall flag. TyVarBndr_ flag -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndr_ flag
</span><a href="#local-6989586621679075060"><span class="hs-identifier hs-var">tvb</span></a></span><span>
</span><span id="line-2450"></span><span>
</span><span id="line-2451"></span><span>    </span><span class="annot"><a href="#local-6989586621679075064"><span class="hs-identifier hs-type">substRangeFVs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Set</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-2452"></span><span>    </span><span id="local-6989586621679075064"><span class="annot"><span class="annottext">substRangeFVs :: Set Name
</span><a href="#local-6989586621679075064"><span class="hs-identifier hs-var hs-var">substRangeFVs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Set Name
forall a. Ord a =&gt; [a] -&gt; Set a
</span><span class="hs-identifier hs-var">Set.fromList</span></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; Set Name) -&gt; [Name] -&gt; Set Name
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">([Type] -&gt; [Name]) -&gt; [Type] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; [Type]
forall k a. Map k a -&gt; [a]
</span><span class="hs-identifier hs-var">Map.elems</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075059"><span class="hs-identifier hs-var">subst</span></a></span><span>
</span><span id="line-2453"></span><span>
</span><span id="line-2454"></span><span>    </span><span class="annot"><a href="#local-6989586621679075066"><span class="hs-identifier hs-type">evade</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-2455"></span><span>    </span><span id="local-6989586621679075066"><span class="annot"><span class="annottext">evade :: Name -&gt; Name
</span><a href="#local-6989586621679075066"><span class="hs-identifier hs-var hs-var">evade</span></a></span></span><span> </span><span id="local-6989586621679075070"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075070"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075070"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Set Name -&gt; Bool
forall a. Ord a =&gt; a -&gt; Set a -&gt; Bool
</span><span class="hs-operator hs-var">`Set.member`</span></span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679075064"><span class="hs-identifier hs-var">substRangeFVs</span></a></span><span>
</span><span id="line-2456"></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name
</span><a href="#local-6989586621679075066"><span class="hs-identifier hs-var">evade</span></a></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Name) -&gt; Name -&gt; Name
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name
</span><a href="#local-6989586621679075071"><span class="hs-identifier hs-var">bump</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075070"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-2457"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-2458"></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075070"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-2459"></span><span>
</span><span id="line-2460"></span><span>    </span><span class="hs-comment">-- An improvement would be to try a variety of different characters instead</span><span>
</span><span id="line-2461"></span><span>    </span><span class="hs-comment">-- of prepending the same character repeatedly. Let's wait to see if</span><span>
</span><span id="line-2462"></span><span>    </span><span class="hs-comment">-- someone complains about this before making this more complicated,</span><span>
</span><span id="line-2463"></span><span>    </span><span class="hs-comment">-- however.</span><span>
</span><span id="line-2464"></span><span>    </span><span class="annot"><a href="#local-6989586621679075071"><span class="hs-identifier hs-type">bump</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-2465"></span><span>    </span><span id="local-6989586621679075071"><span class="annot"><span class="annottext">bump :: Name -&gt; Name
</span><a href="#local-6989586621679075071"><span class="hs-identifier hs-var hs-var">bump</span></a></span></span><span> </span><span id="local-6989586621679075072"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075072"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Name
</span><span class="hs-identifier hs-var">mkName</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Name) -&gt; String -&gt; Name
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'f'</span></span><span class="annot"><span class="annottext">Char -&gt; ShowS
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075072"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-2466"></span><span>
</span><span id="line-2467"></span><span class="hs-comment">-- | Substitutes into the kinds of type variable binders. This is slightly more</span><span>
</span><span id="line-2468"></span><span class="hs-comment">-- efficient than 'substTyVarBndrs', but at the expense of not avoiding</span><span>
</span><span id="line-2469"></span><span class="hs-comment">-- capture. Only use this function in situations where you know that none of</span><span>
</span><span id="line-2470"></span><span class="hs-comment">-- the 'TyVarBndr' names are contained in the range of the substitution.</span><span>
</span><span id="line-2471"></span><span id="local-6989586621679072539"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#substTyVarBndrKinds"><span class="hs-identifier hs-type">substTyVarBndrKinds</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072539"><span class="hs-identifier hs-type">flag</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072539"><span class="hs-identifier hs-type">flag</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-2472"></span><span id="substTyVarBndrKinds"><span class="annot"><span class="annottext">substTyVarBndrKinds :: forall flag.
Map Name Type -&gt; [TyVarBndr_ flag] -&gt; [TyVarBndr_ flag]
</span><a href="Language.Haskell.TH.Datatype.html#substTyVarBndrKinds"><span class="hs-identifier hs-var hs-var">substTyVarBndrKinds</span></a></span></span><span> </span><span id="local-6989586621679075073"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075073"><span class="hs-identifier hs-var">subst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyVarBndr_ flag -&gt; TyVarBndr_ flag)
-&gt; [TyVarBndr_ flag] -&gt; [TyVarBndr_ flag]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; TyVarBndr_ flag -&gt; TyVarBndr_ flag
forall flag. Map Name Type -&gt; TyVarBndr_ flag -&gt; TyVarBndr_ flag
</span><a href="Language.Haskell.TH.Datatype.html#substTyVarBndrKind"><span class="hs-identifier hs-var">substTyVarBndrKind</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075073"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2473"></span><span>
</span><span id="line-2474"></span><span class="annot"><span class="hs-comment">-- | The workhorse for 'substTyVarBndrKinds'.</span></span><span>
</span><span id="line-2475"></span><span id="local-6989586621679072645"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#substTyVarBndrKind"><span class="hs-identifier hs-type">substTyVarBndrKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072645"><span class="hs-identifier hs-type">flag</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#TyVarBndr_"><span class="hs-identifier hs-type">TyVarBndr_</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072645"><span class="hs-identifier hs-type">flag</span></a></span></span><span>
</span><span id="line-2476"></span><span id="substTyVarBndrKind"><span class="annot"><span class="annottext">substTyVarBndrKind :: forall flag. Map Name Type -&gt; TyVarBndr_ flag -&gt; TyVarBndr_ flag
</span><a href="Language.Haskell.TH.Datatype.html#substTyVarBndrKind"><span class="hs-identifier hs-var hs-var">substTyVarBndrKind</span></a></span></span><span> </span><span id="local-6989586621679075076"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075076"><span class="hs-identifier hs-var">subst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; TyVarBndr_ flag -&gt; TyVarBndr_ flag
forall flag. (Type -&gt; Type) -&gt; TyVarBndr_ flag -&gt; TyVarBndr_ flag
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#mapTVKind"><span class="hs-identifier hs-var">mapTVKind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075076"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2477"></span><span>
</span><span id="line-2478"></span><span class="hs-comment">------------------------------------------------------------------------</span><span>
</span><span id="line-2479"></span><span>
</span><span id="line-2480"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#combineSubstitutions"><span class="hs-identifier hs-type">combineSubstitutions</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-2481"></span><span id="combineSubstitutions"><span class="annot"><span class="annottext">combineSubstitutions :: Map Name Type -&gt; Map Name Type -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#combineSubstitutions"><span class="hs-identifier hs-var hs-var">combineSubstitutions</span></a></span></span><span> </span><span id="local-6989586621679075078"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075078"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679075079"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075079"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; Map k a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.union</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Map Name Type -&gt; Map Name Type
forall a b. (a -&gt; b) -&gt; Map Name a -&gt; Map Name b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075079"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075078"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075079"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-2482"></span><span>
</span><span id="line-2483"></span><span class="hs-comment">-- | Compute the type variable substitution that unifies a list of types,</span><span>
</span><span id="line-2484"></span><span class="hs-comment">-- or fail in 'Q'.</span><span>
</span><span id="line-2485"></span><span class="hs-comment">--</span><span>
</span><span id="line-2486"></span><span class="hs-comment">-- All infix issue should be resolved before using 'unifyTypes'</span><span>
</span><span id="line-2487"></span><span class="hs-comment">--</span><span>
</span><span id="line-2488"></span><span class="hs-comment">-- Alpha equivalent quantified types are not unified.</span><span>
</span><span id="line-2489"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unifyTypes"><span class="hs-identifier hs-type">unifyTypes</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span>
</span><span id="line-2490"></span><span id="unifyTypes"><span class="annot"><span class="annottext">unifyTypes :: [Type] -&gt; Q (Map Name Type)
</span><a href="Language.Haskell.TH.Datatype.html#unifyTypes"><span class="hs-identifier hs-var hs-var">unifyTypes</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Q (Map Name Type)
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span>
</span><span id="line-2491"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unifyTypes"><span class="hs-identifier hs-var">unifyTypes</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679075080"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075080"><span class="hs-identifier hs-var">t</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679075081"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679075081"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2492"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679075082"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075082"><span class="hs-identifier hs-var">t'</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679075083"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679075083"><span class="hs-identifier hs-var">ts'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; [Type] -&gt; Q [Type]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075080"><span class="hs-identifier hs-var">t</span></a></span><span class="annot"><span class="annottext">Type -&gt; [Type] -&gt; [Type]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679075081"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2493"></span><span>     </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679075088"><span class="annot"><span class="annottext">aux :: Map Name Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="#local-6989586621679075088"><span class="hs-identifier hs-var hs-var">aux</span></a></span></span><span> </span><span id="local-6989586621679075089"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075089"><span class="hs-identifier hs-var">sub</span></a></span></span><span> </span><span id="local-6989586621679075090"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075090"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2494"></span><span>           </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679075091"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075091"><span class="hs-identifier hs-var">sub'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075089"><span class="hs-identifier hs-var">sub</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075082"><span class="hs-identifier hs-var">t'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2495"></span><span>                             </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075089"><span class="hs-identifier hs-var">sub</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075090"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2496"></span><span>              </span><span class="annot"><span class="annottext">Map Name Type -&gt; Either (Type, Type) (Map Name Type)
forall a. a -&gt; Either (Type, Type) a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#combineSubstitutions"><span class="hs-identifier hs-var">combineSubstitutions</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075089"><span class="hs-identifier hs-var">sub</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075091"><span class="hs-identifier hs-var">sub'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2497"></span><span>
</span><span id="line-2498"></span><span>     </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(Map Name Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type))
-&gt; Map Name Type -&gt; [Type] -&gt; Either (Type, Type) (Map Name Type)
forall (t :: * -&gt; *) (m :: * -&gt; *) b a.
(Foldable t, Monad m) =&gt;
(b -&gt; a -&gt; m b) -&gt; b -&gt; t a -&gt; m b
</span><span class="hs-identifier hs-var">foldM</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="#local-6989586621679075088"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679075083"><span class="hs-identifier hs-var">ts'</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-2499"></span><span>       </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span id="local-6989586621679075094"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075094"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Q (Map Name Type)
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075094"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-2500"></span><span>       </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679075095"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075095"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679075096"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075096"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2501"></span><span>         </span><span class="annot"><span class="annottext">String -&gt; Q (Map Name Type)
forall a. String -&gt; Q a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Q (Map Name Type)) -&gt; String -&gt; Q (Map Name Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
</span><span class="hs-identifier hs-var">showString</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Unable to unify types &quot;</span></span><span>
</span><span id="line-2502"></span><span>              </span><span class="annot"><span class="annottext">ShowS -&gt; ShowS -&gt; ShowS
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Type -&gt; ShowS
forall a. Show a =&gt; Int -&gt; a -&gt; ShowS
</span><span class="hs-identifier hs-var">showsPrec</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">11</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075095"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-2503"></span><span>              </span><span class="annot"><span class="annottext">ShowS -&gt; ShowS -&gt; ShowS
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
</span><span class="hs-identifier hs-var">showString</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot; and &quot;</span></span><span>
</span><span id="line-2504"></span><span>              </span><span class="annot"><span class="annottext">ShowS -&gt; ShowS -&gt; ShowS
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Type -&gt; ShowS
forall a. Show a =&gt; Int -&gt; a -&gt; ShowS
</span><span class="hs-identifier hs-var">showsPrec</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">11</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075096"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-2505"></span><span>              </span><span class="annot"><span class="annottext">ShowS -&gt; ShowS
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;&quot;</span></span><span>
</span><span id="line-2506"></span><span>
</span><span id="line-2507"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-type">unify'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span>
</span><span id="line-2508"></span><span>
</span><span id="line-2509"></span><span id="unify%27"><span class="annot"><span class="annottext">unify' :: Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var hs-var">unify'</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679075099"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075099"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679075100"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075100"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075099"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075100"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Either (Type, Type) (Map Name Type)
forall a. a -&gt; Either (Type, Type) a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span>
</span><span id="line-2510"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679075101"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075101"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679075102"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075102"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075101"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; Bool
forall a. Eq a =&gt; a -&gt; [a] -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-operator hs-var">`elem`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075102"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; Either (Type, Type) (Map Name Type)
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075101"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075102"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2511"></span><span>                  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Either (Type, Type) (Map Name Type)
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Map Name Type
forall k a. k -&gt; a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.singleton</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075101"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075102"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2512"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span id="local-6989586621679075103"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075103"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679075104"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075104"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075104"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; Bool
forall a. Eq a =&gt; a -&gt; [a] -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-operator hs-var">`elem`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075103"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; Either (Type, Type) (Map Name Type)
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075104"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075103"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2513"></span><span>                  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Either (Type, Type) (Map Name Type)
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Map Name Type
forall k a. k -&gt; a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.singleton</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075104"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075103"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2514"></span><span>
</span><span id="line-2515"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679075105"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075105"><span class="hs-identifier hs-var">f1</span></a></span></span><span> </span><span id="local-6989586621679075106"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075106"><span class="hs-identifier hs-var">x1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679075107"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075107"><span class="hs-identifier hs-var">f2</span></a></span></span><span> </span><span id="local-6989586621679075108"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075108"><span class="hs-identifier hs-var">x2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2516"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679075109"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075109"><span class="hs-identifier hs-var">sub1</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075105"><span class="hs-identifier hs-var">f1</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075107"><span class="hs-identifier hs-var">f2</span></a></span><span>
</span><span id="line-2517"></span><span>     </span><span id="local-6989586621679075110"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075110"><span class="hs-identifier hs-var">sub2</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075109"><span class="hs-identifier hs-var">sub1</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075106"><span class="hs-identifier hs-var">x1</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075109"><span class="hs-identifier hs-var">sub1</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075108"><span class="hs-identifier hs-var">x2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2518"></span><span>     </span><span class="annot"><span class="annottext">Map Name Type -&gt; Either (Type, Type) (Map Name Type)
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#combineSubstitutions"><span class="hs-identifier hs-var">combineSubstitutions</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075109"><span class="hs-identifier hs-var">sub1</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075110"><span class="hs-identifier hs-var">sub2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2519"></span><span>
</span><span id="line-2520"></span><span class="hs-comment">-- Doesn't unify kind signatures</span><span>
</span><span id="line-2521"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679075111"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075111"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679075112"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075112"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075111"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075112"><span class="hs-identifier hs-var">u</span></a></span><span>
</span><span id="line-2522"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span id="local-6989586621679075113"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075113"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679075114"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075114"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075113"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075114"><span class="hs-identifier hs-var">u</span></a></span><span>
</span><span id="line-2523"></span><span>
</span><span id="line-2524"></span><span class="hs-comment">-- only non-recursive cases should remain at this point</span><span>
</span><span id="line-2525"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span id="local-6989586621679075115"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075115"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679075116"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075116"><span class="hs-identifier hs-var">u</span></a></span></span><span>
</span><span id="line-2526"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075115"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075116"><span class="hs-identifier hs-var">u</span></a></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Either (Type, Type) (Map Name Type)
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span>
</span><span id="line-2527"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; Either (Type, Type) (Map Name Type)
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075115"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075116"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2528"></span><span>
</span><span id="line-2529"></span><span>
</span><span id="line-2530"></span><span class="hs-comment">-- | Construct an equality constraint. The implementation of 'Pred' varies</span><span>
</span><span id="line-2531"></span><span class="hs-comment">-- across versions of Template Haskell.</span><span>
</span><span id="line-2532"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#equalPred"><span class="hs-identifier hs-type">equalPred</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span>
</span><span id="line-2533"></span><span id="equalPred"><span class="annot"><span class="annottext">equalPred :: Type -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#equalPred"><span class="hs-identifier hs-var hs-var">equalPred</span></a></span></span><span> </span><span id="local-6989586621679075117"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075117"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679075118"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075118"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">=</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,10,0)
</span><span>  </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">EqualityT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075117"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075118"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-cpp">
#else
</span><span>  </span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-identifier">y</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2540"></span><span class="hs-comment">-- | Construct a typeclass constraint. The implementation of 'Pred' varies</span><span>
</span><span id="line-2541"></span><span class="hs-comment">-- across versions of Template Haskell.</span><span>
</span><span id="line-2542"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#classPred"><span class="hs-identifier hs-type">classPred</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-comment">{- ^ class -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">{- ^ parameters -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span>
</span><span id="line-2543"></span><span id="classPred"><span class="annot"><span class="annottext">classPred :: Name -&gt; [Type] -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#classPred"><span class="hs-identifier hs-var hs-var">classPred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,10,0)
</span><span>  </span><span class="annot"><span class="annottext">(Type -&gt; Type -&gt; Type) -&gt; Type -&gt; [Type] -&gt; Type
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; [Type] -&gt; Type)
-&gt; (Name -&gt; Type) -&gt; Name -&gt; [Type] -&gt; Type
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">ConT</span></span><span class="hs-cpp">
#else
</span><span>  </span><span class="hs-identifier">ClassP</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2550"></span><span class="hs-comment">-- | Match a 'Pred' representing an equality constraint. Returns</span><span>
</span><span id="line-2551"></span><span class="hs-comment">-- arguments to the equality constraint if successful.</span><span>
</span><span id="line-2552"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#asEqualPred"><span class="hs-identifier hs-type">asEqualPred</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,10,0)
</span><span id="asEqualPred"><span class="annot"><span class="annottext">asEqualPred :: Type -&gt; Maybe (Type, Type)
</span><a href="Language.Haskell.TH.Datatype.html#asEqualPred"><span class="hs-identifier hs-var hs-var">asEqualPred</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">EqualityT</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`AppT`</span></span><span> </span><span id="local-6989586621679075120"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075120"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`AppT`</span></span><span> </span><span id="local-6989586621679075121"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075121"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; Maybe (Type, Type)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075120"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075121"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2555"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#asEqualPred"><span class="hs-identifier hs-var">asEqualPred</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ConT</span></span><span> </span><span id="local-6989586621679075122"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075122"><span class="hs-identifier hs-var">eq</span></a></span></span><span>   </span><span class="annot"><span class="hs-operator hs-type">`AppT`</span></span><span> </span><span id="local-6989586621679075123"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075123"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`AppT`</span></span><span> </span><span id="local-6989586621679075124"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075124"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075122"><span class="hs-identifier hs-var">eq</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Language.Haskell.TH.Datatype.Internal.html#eqTypeName"><span class="hs-identifier hs-var">eqTypeName</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; Maybe (Type, Type)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075123"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075124"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">asEqualPred</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span>            </span><span class="hs-identifier">x</span><span>        </span><span class="hs-identifier">y</span><span class="hs-special">)</span><span>                   </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">x</span><span class="hs-special">,</span><span class="hs-identifier">y</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#asEqualPred"><span class="hs-identifier hs-var">asEqualPred</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span>                                                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (Type, Type)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-2560"></span><span>
</span><span id="line-2561"></span><span class="hs-comment">-- | Match a 'Pred' representing a class constraint.</span><span>
</span><span id="line-2562"></span><span class="hs-comment">-- Returns the classname and parameters if successful.</span><span>
</span><span id="line-2563"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#asClassPred"><span class="hs-identifier hs-type">asClassPred</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,10,0)
</span><span id="asClassPred"><span class="annot"><span class="annottext">asClassPred :: Type -&gt; Maybe (Name, [Type])
</span><a href="Language.Haskell.TH.Datatype.html#asClassPred"><span class="hs-identifier hs-var hs-var">asClassPred</span></a></span></span><span> </span><span id="local-6989586621679075126"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075126"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2566"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type -&gt; NonEmpty Type
</span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075126"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-2567"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">ConT</span></span><span> </span><span id="local-6989586621679075127"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075127"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679075128"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679075128"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075127"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Language.Haskell.TH.Datatype.Internal.html#eqTypeName"><span class="hs-identifier hs-var">eqTypeName</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Name, [Type]) -&gt; Maybe (Name, [Type])
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075127"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679075128"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2568"></span><span>    </span><span class="annot"><span class="annottext">NonEmpty Type
</span><span class="hs-identifier">_</span></span><span>                              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (Name, [Type])
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">asClassPred</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">f</span><span> </span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">f</span><span class="hs-special">,</span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span>
</span><span id="line-2571"></span><span class="hs-identifier">asClassPred</span><span> </span><span class="hs-identifier">_</span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Nothing</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2574"></span><span class="hs-comment">------------------------------------------------------------------------</span><span>
</span><span id="line-2575"></span><span>
</span><span id="line-2576"></span><span class="hs-comment">-- | If we are working with a 'Dec' obtained via 'reify' (as opposed to one</span><span>
</span><span id="line-2577"></span><span class="hs-comment">-- created from, say, [d| ... |] quotes), then we need to apply more hacks than</span><span>
</span><span id="line-2578"></span><span class="hs-comment">-- we otherwise would to sanitize the 'Dec'. See #28.</span><span>
</span><span id="line-2579"></span><span class="hs-keyword">type</span><span> </span><span id="IsReifiedDec"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-var">IsReifiedDec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-2580"></span><span>
</span><span id="line-2581"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#isReified"><span class="hs-identifier hs-type">isReified</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#isn%27tReified"><span class="hs-identifier hs-type">isn'tReified</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a></span><span>
</span><span id="line-2582"></span><span id="isReified"><span class="annot"><span class="annottext">isReified :: Bool
</span><a href="Language.Haskell.TH.Datatype.html#isReified"><span class="hs-identifier hs-var hs-var">isReified</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-2583"></span><span id="isn%27tReified"><span class="annot"><span class="annottext">isn'tReified :: Bool
</span><a href="Language.Haskell.TH.Datatype.html#isn%27tReified"><span class="hs-identifier hs-var hs-var">isn'tReified</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-2584"></span><span>
</span><span id="line-2585"></span><span class="hs-comment">-- On old versions of GHC, reify would not give you kind signatures for</span><span>
</span><span id="line-2586"></span><span class="hs-comment">-- GADT type variables of kind *. To work around this, we insert the kinds</span><span>
</span><span id="line-2587"></span><span class="hs-comment">-- manually on any reified type variable binders without a signature. However,</span><span>
</span><span id="line-2588"></span><span class="hs-comment">-- don't do this for quoted type variable binders (#84).</span><span>
</span><span id="line-2589"></span><span>
</span><span id="line-2590"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#giveDIVarsStarKinds"><span class="hs-identifier hs-type">giveDIVarsStarKinds</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-2591"></span><span id="giveDIVarsStarKinds"><span class="annot"><span class="annottext">giveDIVarsStarKinds :: Bool -&gt; DatatypeInfo -&gt; DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#giveDIVarsStarKinds"><span class="hs-identifier hs-var hs-var">giveDIVarsStarKinds</span></a></span></span><span> </span><span id="local-6989586621679075130"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679075130"><span class="hs-identifier hs-var">isReified</span></a></span></span><span> </span><span id="local-6989586621679075131"><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679075131"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2592"></span><span>  </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679075131"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#datatypeVars"><span class="hs-identifier hs-var">datatypeVars</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#giveTyVarBndrStarKind"><span class="hs-identifier hs-type">giveTyVarBndrStarKind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679075130"><span class="hs-identifier hs-type">isReified</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#datatypeVars"><span class="hs-identifier hs-var">datatypeVars</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679075131"><span class="hs-identifier hs-type">info</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2593"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#datatypeInstTypes"><span class="hs-identifier hs-var">datatypeInstTypes</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#giveTypeStarKind"><span class="hs-identifier hs-type">giveTypeStarKind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679075130"><span class="hs-identifier hs-type">isReified</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#datatypeInstTypes"><span class="hs-identifier hs-var">datatypeInstTypes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679075131"><span class="hs-identifier hs-type">info</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-2594"></span><span>
</span><span id="line-2595"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#giveCIVarsStarKinds"><span class="hs-identifier hs-type">giveCIVarsStarKinds</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span>
</span><span id="line-2596"></span><span id="giveCIVarsStarKinds"><span class="annot"><span class="annottext">giveCIVarsStarKinds :: Bool -&gt; ConstructorInfo -&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#giveCIVarsStarKinds"><span class="hs-identifier hs-var hs-var">giveCIVarsStarKinds</span></a></span></span><span> </span><span id="local-6989586621679075134"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679075134"><span class="hs-identifier hs-var">isReified</span></a></span></span><span> </span><span id="local-6989586621679075135"><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679075135"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2597"></span><span>  </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679075135"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var">constructorVars</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#giveTyVarBndrStarKind"><span class="hs-identifier hs-type">giveTyVarBndrStarKind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679075134"><span class="hs-identifier hs-type">isReified</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var">constructorVars</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679075135"><span class="hs-identifier hs-type">info</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-2598"></span><span>
</span><span id="line-2599"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#giveTyVarBndrStarKind"><span class="hs-identifier hs-type">giveTyVarBndrStarKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>  </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span>
</span><span id="line-2600"></span><span id="giveTyVarBndrStarKind"><span class="annot"><span class="annottext">giveTyVarBndrStarKind :: Bool -&gt; TyVarBndrUnit -&gt; TyVarBndrUnit
</span><a href="Language.Haskell.TH.Datatype.html#giveTyVarBndrStarKind"><span class="hs-identifier hs-var hs-var">giveTyVarBndrStarKind</span></a></span></span><span> </span><span id="local-6989586621679075136"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679075136"><span class="hs-identifier hs-var">isReified</span></a></span></span><span> </span><span id="local-6989586621679075137"><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679075137"><span class="hs-identifier hs-var">tvb</span></a></span></span><span>
</span><span id="line-2601"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679075136"><span class="hs-identifier hs-var">isReified</span></a></span><span>
</span><span id="line-2602"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; TyVarBndrUnit)
-&gt; (Name -&gt; Type -&gt; TyVarBndrUnit)
-&gt; TyVarBndrUnit
-&gt; TyVarBndrUnit
forall r flag.
(Name -&gt; r) -&gt; (Name -&gt; Type -&gt; r) -&gt; TyVarBndr_ flag -&gt; r
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#elimTV"><span class="hs-identifier hs-var">elimTV</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679075138"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075138"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; TyVarBndrUnit
forall flag. DefaultBndrFlag flag =&gt; Name -&gt; Type -&gt; TyVarBndr flag
</span><span class="hs-identifier hs-var">kindedTV</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075138"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">starK</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679075137"><span class="hs-identifier hs-var">tvb</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679075137"><span class="hs-identifier hs-var">tvb</span></a></span><span>
</span><span id="line-2603"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-2604"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit
</span><a href="#local-6989586621679075137"><span class="hs-identifier hs-var">tvb</span></a></span><span>
</span><span id="line-2605"></span><span>
</span><span id="line-2606"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#giveTypeStarKind"><span class="hs-identifier hs-type">giveTypeStarKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-2607"></span><span id="giveTypeStarKind"><span class="annot"><span class="annottext">giveTypeStarKind :: Bool -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#giveTypeStarKind"><span class="hs-identifier hs-var hs-var">giveTypeStarKind</span></a></span></span><span> </span><span id="local-6989586621679075139"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679075139"><span class="hs-identifier hs-var">isReified</span></a></span></span><span> </span><span id="local-6989586621679075140"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075140"><span class="hs-identifier hs-var">t</span></a></span></span><span>
</span><span id="line-2608"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679075139"><span class="hs-identifier hs-var">isReified</span></a></span><span>
</span><span id="line-2609"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075140"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-2610"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679075141"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075141"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">SigT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075140"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">starK</span></span><span>
</span><span id="line-2611"></span><span>      </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075140"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-2612"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-2613"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075140"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-2614"></span><span>
</span><span id="line-2615"></span><span class="hs-comment">-- | Prior to GHC 8.2.1, reify was broken for data instances and newtype</span><span>
</span><span id="line-2616"></span><span class="hs-comment">-- instances. This code attempts to detect the problem and repair it if</span><span>
</span><span id="line-2617"></span><span class="hs-comment">-- possible.</span><span>
</span><span id="line-2618"></span><span class="hs-comment">--</span><span>
</span><span id="line-2619"></span><span class="hs-comment">-- The particular problem is that the type variables used in the patterns</span><span>
</span><span id="line-2620"></span><span class="hs-comment">-- while defining a data family instance do not completely match those</span><span>
</span><span id="line-2621"></span><span class="hs-comment">-- used when defining the fields of the value constructors beyond the</span><span>
</span><span id="line-2622"></span><span class="hs-comment">-- base names. This code attempts to recover the relationship between the</span><span>
</span><span id="line-2623"></span><span class="hs-comment">-- type variables.</span><span>
</span><span id="line-2624"></span><span class="hs-comment">--</span><span>
</span><span id="line-2625"></span><span class="hs-comment">-- It is possible, however, to generate these kinds of declarations by</span><span>
</span><span id="line-2626"></span><span class="hs-comment">-- means other than reify. In these cases the name bases might not be</span><span>
</span><span id="line-2627"></span><span class="hs-comment">-- unique and the declarations might be well formed. In such a case this</span><span>
</span><span id="line-2628"></span><span class="hs-comment">-- code attempts to avoid altering the declaration.</span><span>
</span><span id="line-2629"></span><span class="hs-comment">--</span><span>
</span><span id="line-2630"></span><span class="hs-comment">-- https://ghc.haskell.org/trac/ghc/ticket/13618</span><span>
</span><span id="line-2631"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#repair13618"><span class="hs-identifier hs-type">repair13618</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-2632"></span><span id="repair13618"><span class="annot"><span class="annottext">repair13618 :: DatatypeInfo -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#repair13618"><span class="hs-identifier hs-var hs-var">repair13618</span></a></span></span><span> </span><span id="local-6989586621679075142"><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679075142"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2633"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679075143"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679075143"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Map Name (Q Type) -&gt; Q (Map Name Type)
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; Map Name (m a) -&gt; m (Map Name a)
</span><span class="hs-identifier hs-var">T.sequence</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(Name, Q Type)] -&gt; Map Name (Q Type)
forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.fromList</span></span><span> </span><span class="annot"><span class="annottext">[(Name, Q Type)]
</span><a href="#local-6989586621679075144"><span class="hs-identifier hs-var">substList</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2634"></span><span>     </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Q DatatypeInfo
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679075142"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var">datatypeCons</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-type">applySubstitution</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679075143"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var">datatypeCons</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679075142"><span class="hs-identifier hs-type">info</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-2635"></span><span>
</span><span id="line-2636"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-2637"></span><span>    </span><span id="local-6989586621679075147"><span class="annot"><span class="annottext">used :: [Name]
</span><a href="#local-6989586621679075147"><span class="hs-identifier hs-var hs-var">used</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[ConstructorInfo] -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var">datatypeCons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679075142"><span class="hs-identifier hs-var">info</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2638"></span><span>    </span><span id="local-6989586621679075148"><span class="annot"><span class="annottext">bound :: [Name]
</span><a href="#local-6989586621679075148"><span class="hs-identifier hs-var hs-var">bound</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyVarBndrUnit -&gt; Name) -&gt; [TyVarBndrUnit] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndrUnit -&gt; Name
forall flag. TyVarBndr_ flag -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.TyVarBndr.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; [TyVarBndrUnit]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeVars"><span class="hs-identifier hs-var">datatypeVars</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679075142"><span class="hs-identifier hs-var">info</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2639"></span><span>    </span><span id="local-6989586621679075150"><span class="annot"><span class="annottext">free :: [Name]
</span><a href="#local-6989586621679075150"><span class="hs-identifier hs-var hs-var">free</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679075147"><span class="hs-identifier hs-var">used</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">\\</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679075148"><span class="hs-identifier hs-var">bound</span></a></span><span>
</span><span id="line-2640"></span><span>
</span><span id="line-2641"></span><span>    </span><span id="local-6989586621679075144"><span class="annot"><span class="annottext">substList :: [(Name, Q Type)]
</span><a href="#local-6989586621679075144"><span class="hs-identifier hs-var hs-var">substList</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2642"></span><span>      </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075160"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; Q Type
forall {m :: * -&gt; *} {a}.
(Quote m, MonadFail m, Show a) =&gt;
a -&gt; [Name] -&gt; m Type
</span><a href="#local-6989586621679075161"><span class="hs-identifier hs-var">substEntry</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075160"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679075162"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2643"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679075160"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075160"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679075150"><span class="hs-identifier hs-var">free</span></a></span><span>
</span><span id="line-2644"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679075162"><span class="annot"><span class="annottext">vs :: [Name]
</span><a href="#local-6989586621679075162"><span class="hs-identifier hs-var hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075166"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679075166"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075166"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679075148"><span class="hs-identifier hs-var">bound</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075166"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075160"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2645"></span><span>      </span><span class="hs-special">]</span><span>
</span><span id="line-2646"></span><span>
</span><span id="line-2647"></span><span>    </span><span id="local-6989586621679075161"><span class="annot"><span class="annottext">substEntry :: a -&gt; [Name] -&gt; m Type
</span><a href="#local-6989586621679075161"><span class="hs-identifier hs-var hs-var">substEntry</span></a></span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">[</span><span id="local-6989586621679075185"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075185"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; m Type
forall (m :: * -&gt; *). Quote m =&gt; Name -&gt; m Type
</span><span class="hs-identifier hs-var">varT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075185"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-2648"></span><span>    </span><span class="annot"><a href="#local-6989586621679075161"><span class="hs-identifier hs-var">substEntry</span></a></span><span> </span><span id="local-6989586621679075186"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679075186"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; m Type
forall a. String -&gt; m a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Impossible free variable: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679075186"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2649"></span><span>    </span><span class="annot"><a href="#local-6989586621679075161"><span class="hs-identifier hs-var">substEntry</span></a></span><span> </span><span id="local-6989586621679075187"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679075187"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; m Type
forall a. String -&gt; m a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Ambiguous free variable: &quot;</span></span><span>  </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679075187"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2650"></span><span>
</span><span id="line-2651"></span><span class="hs-comment">------------------------------------------------------------------------</span><span>
</span><span id="line-2652"></span><span>
</span><span id="line-2653"></span><span class="annot"><span class="hs-comment">-- | Backward compatible version of 'dataD'</span></span><span>
</span><span id="line-2654"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#dataDCompat"><span class="hs-identifier hs-type">dataDCompat</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-2655"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">CxtQ</span></span><span>           </span><span class="annot"><span class="hs-comment">{- ^ context                 -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2656"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>           </span><span class="annot"><span class="hs-comment">{- ^ type constructor        -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2657"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrVis</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">{- ^ type parameters         -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2658"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">ConQ</span></span><span class="hs-special">]</span><span>         </span><span class="annot"><span class="hs-comment">{- ^ constructor definitions -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2659"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>         </span><span class="annot"><span class="hs-comment">{- ^ derived class names     -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2660"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">DecQ</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,12,0)
</span><span id="dataDCompat"><span class="annot"><span class="annottext">dataDCompat :: Q [Type]
-&gt; Name -&gt; [TyVarBndr BndrVis] -&gt; [ConQ] -&gt; [Name] -&gt; Q Dec
</span><a href="Language.Haskell.TH.Datatype.html#dataDCompat"><span class="hs-identifier hs-var hs-var">dataDCompat</span></a></span></span><span> </span><span id="local-6989586621679075191"><span class="annot"><span class="annottext">Q [Type]
</span><a href="#local-6989586621679075191"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679075192"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075192"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679075193"><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679075193"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span id="local-6989586621679075194"><span class="annot"><span class="annottext">[ConQ]
</span><a href="#local-6989586621679075194"><span class="hs-identifier hs-var">cs</span></a></span></span><span> </span><span id="local-6989586621679075195"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679075195"><span class="hs-identifier hs-var">ds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2663"></span><span>  </span><span class="annot"><span class="annottext">Q [Type]
-&gt; Name
-&gt; [TyVarBndr BndrVis]
-&gt; Maybe Type
-&gt; [ConQ]
-&gt; [Q DerivClause]
-&gt; Q Dec
forall (m :: * -&gt; *).
Quote m =&gt;
m [Type]
-&gt; Name
-&gt; [TyVarBndr BndrVis]
-&gt; Maybe Type
-&gt; [m Con]
-&gt; [m DerivClause]
-&gt; m Dec
</span><span class="hs-identifier hs-var">dataD</span></span><span> </span><span class="annot"><span class="annottext">Q [Type]
</span><a href="#local-6989586621679075191"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075192"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679075193"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">[ConQ]
</span><a href="#local-6989586621679075194"><span class="hs-identifier hs-var">cs</span></a></span><span>
</span><span id="line-2664"></span><span>    </span><span class="hs-special">(</span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679075195"><span class="hs-identifier hs-var">ds</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe DerivStrategy -&gt; [Q Type] -&gt; Q DerivClause
forall (m :: * -&gt; *).
Quote m =&gt;
Maybe DerivStrategy -&gt; [m Type] -&gt; m DerivClause
</span><span class="hs-identifier hs-var">derivClause</span></span><span> </span><span class="annot"><span class="annottext">Maybe DerivStrategy
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Name -&gt; Q Type) -&gt; [Name] -&gt; [Q Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q Type
forall (m :: * -&gt; *). Quote m =&gt; Name -&gt; m Type
</span><span class="hs-identifier hs-var">conT</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679075195"><span class="hs-identifier hs-var">ds</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-cpp">
#elif MIN_VERSION_template_haskell(2,11,0)
</span><span class="hs-identifier">dataDCompat</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">cs</span><span> </span><span class="hs-identifier">ds</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2667"></span><span>  </span><span class="hs-identifier">dataD</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-identifier">cs</span><span>
</span><span id="line-2668"></span><span>    </span><span class="hs-special">(</span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">map</span><span> </span><span class="hs-identifier">ConT</span><span> </span><span class="hs-identifier">ds</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">dataDCompat</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">dataD</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2673"></span><span class="annot"><span class="hs-comment">-- | Backward compatible version of 'newtypeD'</span></span><span>
</span><span id="line-2674"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#newtypeDCompat"><span class="hs-identifier hs-type">newtypeDCompat</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-2675"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">CxtQ</span></span><span>           </span><span class="annot"><span class="hs-comment">{- ^ context                 -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2676"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>           </span><span class="annot"><span class="hs-comment">{- ^ type constructor        -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2677"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrVis</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">{- ^ type parameters         -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2678"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">ConQ</span></span><span>           </span><span class="annot"><span class="hs-comment">{- ^ constructor definition  -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2679"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>         </span><span class="annot"><span class="hs-comment">{- ^ derived class names     -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2680"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">DecQ</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,12,0)
</span><span id="newtypeDCompat"><span class="annot"><span class="annottext">newtypeDCompat :: Q [Type] -&gt; Name -&gt; [TyVarBndr BndrVis] -&gt; ConQ -&gt; [Name] -&gt; Q Dec
</span><a href="Language.Haskell.TH.Datatype.html#newtypeDCompat"><span class="hs-identifier hs-var hs-var">newtypeDCompat</span></a></span></span><span> </span><span id="local-6989586621679075198"><span class="annot"><span class="annottext">Q [Type]
</span><a href="#local-6989586621679075198"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679075199"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075199"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679075200"><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679075200"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span id="local-6989586621679075201"><span class="annot"><span class="annottext">ConQ
</span><a href="#local-6989586621679075201"><span class="hs-identifier hs-var">cs</span></a></span></span><span> </span><span id="local-6989586621679075202"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679075202"><span class="hs-identifier hs-var">ds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2683"></span><span>  </span><span class="annot"><span class="annottext">Q [Type]
-&gt; Name
-&gt; [TyVarBndr BndrVis]
-&gt; Maybe Type
-&gt; ConQ
-&gt; [Q DerivClause]
-&gt; Q Dec
forall (m :: * -&gt; *).
Quote m =&gt;
m [Type]
-&gt; Name
-&gt; [TyVarBndr BndrVis]
-&gt; Maybe Type
-&gt; m Con
-&gt; [m DerivClause]
-&gt; m Dec
</span><span class="hs-identifier hs-var">newtypeD</span></span><span> </span><span class="annot"><span class="annottext">Q [Type]
</span><a href="#local-6989586621679075198"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075199"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr BndrVis]
</span><a href="#local-6989586621679075200"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">ConQ
</span><a href="#local-6989586621679075201"><span class="hs-identifier hs-var">cs</span></a></span><span>
</span><span id="line-2684"></span><span>    </span><span class="hs-special">(</span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679075202"><span class="hs-identifier hs-var">ds</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe DerivStrategy -&gt; [Q Type] -&gt; Q DerivClause
forall (m :: * -&gt; *).
Quote m =&gt;
Maybe DerivStrategy -&gt; [m Type] -&gt; m DerivClause
</span><span class="hs-identifier hs-var">derivClause</span></span><span> </span><span class="annot"><span class="annottext">Maybe DerivStrategy
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Name -&gt; Q Type) -&gt; [Name] -&gt; [Q Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q Type
forall (m :: * -&gt; *). Quote m =&gt; Name -&gt; m Type
</span><span class="hs-identifier hs-var">conT</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679075202"><span class="hs-identifier hs-var">ds</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-cpp">
#elif MIN_VERSION_template_haskell(2,11,0)
</span><span class="hs-identifier">newtypeDCompat</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">cs</span><span> </span><span class="hs-identifier">ds</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2687"></span><span>  </span><span class="hs-identifier">newtypeD</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-identifier">cs</span><span>
</span><span id="line-2688"></span><span>    </span><span class="hs-special">(</span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">map</span><span> </span><span class="hs-identifier">ConT</span><span> </span><span class="hs-identifier">ds</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">newtypeDCompat</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">newtypeD</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2693"></span><span class="annot"><span class="hs-comment">-- | Backward compatible version of 'tySynInstD'</span></span><span>
</span><span id="line-2694"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#tySynInstDCompat"><span class="hs-identifier hs-type">tySynInstDCompat</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-2695"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>                    </span><span class="annot"><span class="hs-comment">{- ^ type family name    -}</span></span><span>   </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2696"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndrUnit</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">{- ^ type variable binders -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2697"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TypeQ</span></span><span class="hs-special">]</span><span>                 </span><span class="annot"><span class="hs-comment">{- ^ instance parameters -}</span></span><span>   </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2698"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">TypeQ</span></span><span>                   </span><span class="annot"><span class="hs-comment">{- ^ instance result     -}</span></span><span>   </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2699"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">DecQ</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,15,0)
</span><span id="tySynInstDCompat"><span class="annot"><span class="annottext">tySynInstDCompat :: Name -&gt; Maybe [Q TyVarBndrUnit] -&gt; [Q Type] -&gt; Q Type -&gt; Q Dec
</span><a href="Language.Haskell.TH.Datatype.html#tySynInstDCompat"><span class="hs-identifier hs-var hs-var">tySynInstDCompat</span></a></span></span><span> </span><span id="local-6989586621679075203"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075203"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679075204"><span class="annot"><span class="annottext">Maybe [Q TyVarBndrUnit]
</span><a href="#local-6989586621679075204"><span class="hs-identifier hs-var">mtvbs</span></a></span></span><span> </span><span id="local-6989586621679075205"><span class="annot"><span class="annottext">[Q Type]
</span><a href="#local-6989586621679075205"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span id="local-6989586621679075206"><span class="annot"><span class="annottext">Q Type
</span><a href="#local-6989586621679075206"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TySynEqn -&gt; Dec
</span><span class="hs-identifier hs-var">TySynInstD</span></span><span> </span><span class="annot"><span class="annottext">(TySynEqn -&gt; Dec) -&gt; Q TySynEqn -&gt; Q Dec
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe [TyVarBndrUnit] -&gt; Type -&gt; Type -&gt; TySynEqn
</span><span class="hs-identifier hs-var">TySynEqn</span></span><span> </span><span class="annot"><span class="annottext">(Maybe [TyVarBndrUnit] -&gt; Type -&gt; Type -&gt; TySynEqn)
-&gt; Q (Maybe [TyVarBndrUnit]) -&gt; Q (Type -&gt; Type -&gt; TySynEqn)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">([Q TyVarBndrUnit] -&gt; Q [TyVarBndrUnit])
-&gt; Maybe [Q TyVarBndrUnit] -&gt; Q (Maybe [TyVarBndrUnit])
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Maybe a -&gt; m (Maybe b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">[Q TyVarBndrUnit] -&gt; Q [TyVarBndrUnit]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">Maybe [Q TyVarBndrUnit]
</span><a href="#local-6989586621679075204"><span class="hs-identifier hs-var">mtvbs</span></a></span><span>
</span><span id="line-2702"></span><span>                                                         </span><span class="annot"><span class="annottext">Q (Type -&gt; Type -&gt; TySynEqn) -&gt; Q Type -&gt; Q (Type -&gt; TySynEqn)
forall a b. Q (a -&gt; b) -&gt; Q a -&gt; Q b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Q Type -&gt; Q Type -&gt; Q Type) -&gt; Q Type -&gt; [Q Type] -&gt; Q Type
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl'</span></span><span> </span><span class="annot"><span class="annottext">Q Type -&gt; Q Type -&gt; Q Type
forall (m :: * -&gt; *). Quote m =&gt; m Type -&gt; m Type -&gt; m Type
</span><span class="hs-identifier hs-var">appT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Q Type
forall (m :: * -&gt; *). Quote m =&gt; Name -&gt; m Type
</span><span class="hs-identifier hs-var">conT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075203"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Q Type]
</span><a href="#local-6989586621679075205"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-2703"></span><span>                                                         </span><span class="annot"><span class="annottext">Q (Type -&gt; TySynEqn) -&gt; Q Type -&gt; Q TySynEqn
forall a b. Q (a -&gt; b) -&gt; Q a -&gt; Q b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Q Type
</span><a href="#local-6989586621679075206"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#elif MIN_VERSION_template_haskell(2,9,0)
</span><span class="hs-identifier">tySynInstDCompat</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">ps</span><span> </span><span class="hs-identifier">r</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">TySynInstD</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-operator">&lt;$&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">TySynEqn</span><span> </span><span class="hs-operator">&lt;$&gt;</span><span> </span><span class="hs-identifier">sequence</span><span> </span><span class="hs-identifier">ps</span><span> </span><span class="hs-operator">&lt;*&gt;</span><span> </span><span class="hs-identifier">r</span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">tySynInstDCompat</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">_</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">tySynInstD</span><span> </span><span class="hs-identifier">n</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2710"></span><span class="hs-comment">-- | Backward compatible version of 'pragLineD'. Returns</span><span>
</span><span id="line-2711"></span><span class="hs-comment">-- 'Nothing' if line pragmas are not suported.</span><span>
</span><span id="line-2712"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#pragLineDCompat"><span class="hs-identifier hs-type">pragLineDCompat</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-2713"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>     </span><span class="annot"><span class="hs-comment">{- ^ line number -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2714"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>  </span><span class="annot"><span class="hs-comment">{- ^ file name   -}</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2715"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">DecQ</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,10,0)
</span><span id="pragLineDCompat"><span class="annot"><span class="annottext">pragLineDCompat :: Int -&gt; String -&gt; Maybe (Q Dec)
</span><a href="Language.Haskell.TH.Datatype.html#pragLineDCompat"><span class="hs-identifier hs-var hs-var">pragLineDCompat</span></a></span></span><span> </span><span id="local-6989586621679075210"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679075210"><span class="hs-identifier hs-var">ln</span></a></span></span><span> </span><span id="local-6989586621679075211"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679075211"><span class="hs-identifier hs-var">fn</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Q Dec -&gt; Maybe (Q Dec)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; String -&gt; Q Dec
forall (m :: * -&gt; *). Quote m =&gt; Int -&gt; String -&gt; m Dec
</span><span class="hs-identifier hs-var">pragLineD</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679075210"><span class="hs-identifier hs-var">ln</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679075211"><span class="hs-identifier hs-var">fn</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">pragLineDCompat</span><span> </span><span class="hs-identifier">_</span><span>  </span><span class="hs-identifier">_</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Nothing</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2722"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#arrowKCompat"><span class="hs-identifier hs-type">arrowKCompat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span id="arrowKCompat"><span class="annot"><span class="annottext">arrowKCompat :: Type -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#arrowKCompat"><span class="hs-identifier hs-var hs-var">arrowKCompat</span></a></span></span><span> </span><span id="local-6989586621679075212"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075212"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679075213"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075213"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">arrowK</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`appK`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075212"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`appK`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679075213"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">arrowKCompat</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">arrowK</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2729"></span><span class="hs-comment">------------------------------------------------------------------------</span><span>
</span><span id="line-2730"></span><span>
</span><span id="line-2731"></span><span class="hs-comment">-- | Backwards compatibility wrapper for 'Fixity' lookup.</span><span>
</span><span id="line-2732"></span><span class="hs-comment">--</span><span>
</span><span id="line-2733"></span><span class="hs-comment">-- In @template-haskell-2.11.0.0@ and later, the answer will always</span><span>
</span><span id="line-2734"></span><span class="hs-comment">-- be 'Just' of a fixity.</span><span>
</span><span id="line-2735"></span><span class="hs-comment">--</span><span>
</span><span id="line-2736"></span><span class="hs-comment">-- Before @template-haskell-2.11.0.0@ it was only possible to determine</span><span>
</span><span id="line-2737"></span><span class="hs-comment">-- fixity information for variables, class methods, and data constructors.</span><span>
</span><span id="line-2738"></span><span class="hs-comment">-- In this case for type operators the answer could be 'Nothing', which</span><span>
</span><span id="line-2739"></span><span class="hs-comment">-- indicates that the answer is unavailable.</span><span>
</span><span id="line-2740"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyFixityCompat"><span class="hs-identifier hs-type">reifyFixityCompat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span class="hs-special">)</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span id="reifyFixityCompat"><span class="annot"><span class="annottext">reifyFixityCompat :: Name -&gt; Q (Maybe Fixity)
</span><a href="Language.Haskell.TH.Datatype.html#reifyFixityCompat"><span class="hs-identifier hs-var hs-var">reifyFixityCompat</span></a></span></span><span> </span><span id="local-6989586621679075215"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075215"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Q (Maybe Fixity) -&gt; Q (Maybe Fixity) -&gt; Q (Maybe Fixity)
forall a. Q a -&gt; Q a -&gt; Q a
</span><span class="hs-identifier hs-var">recover</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe Fixity -&gt; Q (Maybe Fixity)
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Maybe Fixity
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe Fixity -&gt; Maybe Fixity -&gt; Maybe Fixity
forall a. Maybe a -&gt; Maybe a -&gt; Maybe a
forall (m :: * -&gt; *) a. MonadPlus m =&gt; m a -&gt; m a -&gt; m a
</span><span class="hs-operator hs-var">`mplus`</span></span><span> </span><span class="annot"><span class="annottext">Fixity -&gt; Maybe Fixity
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><span class="hs-identifier hs-var">defaultFixity</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Maybe Fixity -&gt; Maybe Fixity)
-&gt; Q (Maybe Fixity) -&gt; Q (Maybe Fixity)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q (Maybe Fixity)
</span><span class="hs-identifier hs-var">reifyFixity</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075215"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">reifyFixityCompat</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">recover</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">return</span><span> </span><span class="hs-identifier">Nothing</span><span class="hs-special">)</span><span> </span><span class="hs-operator">$</span><span>
</span><span id="line-2745"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">info</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">reify</span><span> </span><span class="hs-identifier">n</span><span>
</span><span id="line-2746"></span><span>     </span><span class="hs-identifier">return</span><span> </span><span class="hs-operator">$!</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">info</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-2747"></span><span>       </span><span class="hs-identifier">ClassOpI</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">fixity</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">fixity</span><span>
</span><span id="line-2748"></span><span>       </span><span class="hs-identifier">DataConI</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">fixity</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">fixity</span><span>
</span><span id="line-2749"></span><span>       </span><span class="hs-identifier">VarI</span><span>     </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">fixity</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">fixity</span><span>
</span><span id="line-2750"></span><span>       </span><span class="hs-identifier">_</span><span>                     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Nothing</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2753"></span><span class="hs-comment">-- | Call 'reify' and return @'Just' info@ if successful or 'Nothing' if</span><span>
</span><span id="line-2754"></span><span class="hs-comment">-- reification failed.</span><span>
</span><span id="line-2755"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyMaybe"><span class="hs-identifier hs-type">reifyMaybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Info</span></span><span class="hs-special">)</span><span>
</span><span id="line-2756"></span><span id="reifyMaybe"><span class="annot"><span class="annottext">reifyMaybe :: Name -&gt; Q (Maybe Info)
</span><a href="Language.Haskell.TH.Datatype.html#reifyMaybe"><span class="hs-identifier hs-var hs-var">reifyMaybe</span></a></span></span><span> </span><span id="local-6989586621679075217"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075217"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Info -&gt; Q (Maybe Info)
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Maybe Info
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">Q (Maybe Info) -&gt; Q (Maybe Info) -&gt; Q (Maybe Info)
forall a. Q a -&gt; Q a -&gt; Q a
</span><span class="hs-operator hs-var">`recover`</span></span><span> </span><span class="annot"><span class="annottext">(Info -&gt; Maybe Info) -&gt; Q Info -&gt; Q (Maybe Info)
forall a b. (a -&gt; b) -&gt; Q a -&gt; Q b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Info -&gt; Maybe Info
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Q Info
</span><span class="hs-identifier hs-var">reify</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679075217"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2757"></span></pre></body></html>