-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities to work with lists of types
--   
--   This packages reifies the concept of list of types, and application of
--   those to list constructors.
@package kind-apply
@version 0.4.0.0


-- | Representation of types as constructor + list of types.
module Data.PolyKinded

-- | <tt>LoT k</tt> represents a list of types which can be applied to a
--   data type of kind <tt>k</tt>.
data LoT k

-- | Empty list of types.
[LoT0] :: LoT Type

-- | Cons a type with a list of types.
[:&&:] :: forall k1 ks. k1 -> LoT ks -> LoT (k1 -> ks)
infixr 5 :&&:

-- | Apply a list of types to a type constructor.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Either :@@: (Int :&amp;&amp;: Bool :&amp;&amp;: LoT0)
--   Either Int Bool :: Type
--   </pre>
type family (f :: k) :@@: (tys :: LoT k)

-- | List of types with a single element.
type LoT1 (a :: k) = a ':&&: 'LoT0

-- | List of types with two elements.
type LoT2 (a :: k) (b :: k1) = a ':&&: b ':&&: 'LoT0

-- | Head of a non-empty list of types.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! HeadLoT (Int :&amp;&amp;: LoT0)
--   Int :: Type
--   </pre>
type family HeadLoT (tys :: LoT k -> k') :: k

-- | Tail of a non-empty list of types.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! TailLoT (Int :&amp;&amp;: Bool :&amp;&amp;: LoT0)
--   Bool :&amp;&amp;: LoT0 :: LoT (Type -&gt; Type)
--   </pre>
type family TailLoT (tys :: LoT k -> k') :: LoT k'

-- | Construct the spine of a list of types whose length is known.
--   
--   It can be useful to introduce unification variables for lists of types
--   which will be fully instantiated during constraint resolution. A
--   constraint <tt>p ~ SpineLoT p</tt> will thus instantiate the spine of
--   <tt>p</tt>.
--   
--   On concrete lists, this is the identity function.
type family SpineLoT (tys :: LoT k) = (tys' :: LoT k) | tys' -> k tys
data SLoT (l :: LoT k)
[SLoT0] :: SLoT 'LoT0
[SLoTA] :: forall {k1} {k2} (t :: k1) (ts :: LoT k2). Proxy t -> SLoT ts -> SLoT (t ':&&: ts)
class SForLoT (l :: LoT k)
slot :: SForLoT l => SLoT l

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k)
Proxy :: Proxy (t :: k)

-- | Split a type <tt>t</tt> until the constructor <tt>f</tt> is found.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! SplitF (Either Int Bool) Either
--   Int :&amp;&amp;: Bool :&amp;&amp;: LoT0 :: LoT (Type -&gt; Type -&gt; Type)
--   
--   &gt;&gt;&gt; :kind! SplitF (Either Int Bool) (Either Int)
--   Bool :&amp;&amp;: LoT0 :: LoT (Type -&gt; Type)
--   </pre>
type SplitF (t :: d) (f :: k) = SplitF' t f 'LoT0

-- | Simple natural numbers.
data Nat
Z :: Nat
S :: Nat -> Nat

-- | A type constructor and a list of types that can be applied to it.
data TyEnv
[TyEnv] :: forall k. k -> LoT k -> TyEnv

-- | Split a type <tt>t</tt> until its list of types has length <tt>n</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! SplitN (Either Int Bool) (S (S Z))
--   TyEnv Either (Int :&amp;&amp;: Bool :&amp;&amp;: LoT0) :: TyEnv
--   
--   &gt;&gt;&gt; :kind! SplitF (Either Int Bool) (S Z)
--   TyEnv (Either Int) (Bool :&amp;&amp;: LoT0) :: TyEnv
--   </pre>
type family SplitN (n :: Nat) t :: TyEnv
instance forall k k' (l :: Data.PolyKinded.LoT (k -> k')) (t :: k) (ts :: Data.PolyKinded.LoT k'). (l GHC.Types.~ (t 'Data.PolyKinded.:&&: ts), Data.PolyKinded.SForLoT ts) => Data.PolyKinded.SForLoT l
instance (l GHC.Types.~ 'Data.PolyKinded.LoT0) => Data.PolyKinded.SForLoT l


-- | <a>Atom</a>s represent the shape of a type, possibly with variables,
--   which can be <a>Interpret</a>ed given a list of types.
module Data.PolyKinded.Atom

-- | Shape of a type, possibly with type variables.
--   
--   <pre>
--   &gt;&gt;&gt; :kind Kon [] :@: Var0 -- the type [a] for unknown a
--   Kon [] :@: Var0 :: Atom (* -&gt; xs) *
--   </pre>
--   
--   <h3><b>Representation of type families</b></h3>
--   
--   Type families are represented using <a>first-class-families</a>.
--   
--   For example, the type-level <tt>n + m :: <a>Nat</a></tt>-- may expand
--   to the following--
--   
--   <pre>
--   n + m         -- using <tt>(<a>+</a>)</tt> from <a>GHC.TypeNats</a>
--   ~
--   <a>Eval</a> (n <a>+</a> m)  -- using <a>Eval</a> from <a>Fcf.Core</a> and <tt>(<a>+</a>)</tt> from <a>Fcf.Data.Nat</a>
--   </pre>
--   
--   which may be encoded as the following <a>Atom</a> (using <a>Var0</a>
--   for <tt>n</tt> and <a>Var1</a> for <tt>m</tt>):
--   
--   <pre>
--   <a>Eval</a> ((<a>Kon</a> (<a>+</a>) <a>:@:</a> <a>Var0</a>) <a>:@:</a> <a>Var1</a>)  -- <a>Eval</a> as <a>Atom</a>'s constructor
--     :: <a>Atom</a> (Nat -&gt; Nat -&gt; Type) Nat
--   </pre>
--   
--   <a>kind-generics</a> uses a different, more systematic encoding of
--   type families for <tt>GenericK</tt> instances; see <a>fcf-family</a>
--   for more details. For example, <tt>n + m</tt> is instead expanded to
--   the following:
--   
--   <pre>
--   n + m
--   ~
--   <a>Eval</a> (<a>NDFamily</a> (<a>MkName</a> "base" "GHC.TypeNats" "+") <a>P0</a> '(n, '(m, '())))
--   </pre>
--   
--   which gets encoded as the following <a>Atom</a>:
--   
--   <pre>
--   <a>Eval</a> (<a>Kon</a> (<a>NDFamily</a> (<a>MkName</a> "base" "GHC.TypeNats" "+") <a>P0</a>)
--           <a>:@:</a> ((<a>Kon</a> '(,) <a>:@:</a> <a>Var0</a>) <a>:@:</a> ((<a>Kon</a> '(,) <a>:@:</a> <a>Var1</a>) <a>:@:</a> <a>Kon</a> '())))
--     :: <a>Atom</a> (Nat -&gt; Nat -&gt; Type) Nat
--   </pre>
data Atom d (k :: TYPE r)

-- | Represents a type variable.
[Var] :: forall d k1. TyVar d k1 -> Atom d k1

-- | Represents a constant type, like <a>Int</a>.
[Kon] :: forall k1 d. k1 -> Atom d k1

-- | Represents type application.
[:@:] :: forall d k1 k2. Atom d (k1 -> k2) -> Atom d k1 -> Atom d k2

-- | Represents the conjunction of two constraints.
[:&:] :: forall d. Atom d Constraint -> Atom d Constraint -> Atom d Constraint

-- | Represents universal quantification.
[ForAll] :: forall d1 d. Atom (d1 -> d) Type -> Atom d Type

-- | Represents constraint requirement, the "thick arrow" <tt>=&gt;</tt>.
[:=>>:] :: forall d. Atom d Constraint -> Atom d Type -> Atom d Type

-- | Represents a type family application.
[Eval] :: forall d k1. Atom d (Exp k1) -> Atom d k1
infixr 5 :&:
infixr 5 :=>>:

-- | Represents an applied constructor. Instead of <tt>Kon [] :</tt>: Var0$
--   you can write @[] :$: Var0$.
type (f :: k1 -> k2) :$: (x :: Atom d k1) = 'Kon f :: Atom d k1 -> k2 ':@: x

-- | Represents (homogeneous) type equality.
type (a :: Atom d k1) :~: (b :: Atom d k1) = 'Kon (~) :: k1 -> k1 -> Constraint :: Atom d k1 -> k1 -> Constraint ':@: a ':@: b

-- | Represents heterogeneous type equality.
type (a :: Atom d k1) :~~: (b :: Atom d k2) = 'Kon (~~) :: k1 -> k2 -> Constraint :: Atom d k1 -> k2 -> Constraint ':@: a ':@: b

-- | Well-scoped de Bruijn representation of type variables. <tt>TyVar
--   d</tt> represents all the possible type variables which can refer to
--   the holes in kind <tt>d</tt>.
--   
--   We recommend using the aliases <a>Var0</a>, <a>Var1</a>, ... instead
--   of the constructors, for further clarity.
data TyVar d (k :: TYPE r)

-- | First hole in <tt>d</tt>.
[VZ] :: forall x xs. TyVar (x -> xs) x

-- | Successor hole, increases the hole reference by 1.
[VS] :: forall xs k1 x. TyVar xs k1 -> TyVar (x -> xs) k1
type Var0 = 'Var 'VZ :: TyVar k -> xs k
type Var1 = 'Var 'VS 'VZ :: TyVar k -> xs k :: TyVar x -> k -> xs k
type Var2 = 'Var 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x1 -> k -> xs k :: TyVar x -> x1 -> k -> xs k
type Var3 = 'Var 'VS 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x2 -> k -> xs k :: TyVar x1 -> x2 -> k -> xs k :: TyVar x -> x1 -> x2 -> k -> xs k
type Var4 = 'Var 'VS 'VS 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x3 -> k -> xs k :: TyVar x2 -> x3 -> k -> xs k :: TyVar x1 -> x2 -> x3 -> k -> xs k :: TyVar x -> x1 -> x2 -> x3 -> k -> xs k
type Var5 = 'Var 'VS 'VS 'VS 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x4 -> k -> xs k :: TyVar x3 -> x4 -> k -> xs k :: TyVar x2 -> x3 -> x4 -> k -> xs k :: TyVar x1 -> x2 -> x3 -> x4 -> k -> xs k :: TyVar x -> x1 -> x2 -> x3 -> x4 -> k -> xs k
type Var6 = 'Var 'VS 'VS 'VS 'VS 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x5 -> k -> xs k :: TyVar x4 -> x5 -> k -> xs k :: TyVar x3 -> x4 -> x5 -> k -> xs k :: TyVar x2 -> x3 -> x4 -> x5 -> k -> xs k :: TyVar x1 -> x2 -> x3 -> x4 -> x5 -> k -> xs k :: TyVar x -> x1 -> x2 -> x3 -> x4 -> x5 -> k -> xs k
type Var7 = 'Var 'VS 'VS 'VS 'VS 'VS 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x6 -> k -> xs k :: TyVar x5 -> x6 -> k -> xs k :: TyVar x4 -> x5 -> x6 -> k -> xs k :: TyVar x3 -> x4 -> x5 -> x6 -> k -> xs k :: TyVar x2 -> x3 -> x4 -> x5 -> x6 -> k -> xs k :: TyVar x1 -> x2 -> x3 -> x4 -> x5 -> x6 -> k -> xs k :: TyVar x -> x1 -> x2 -> x3 -> x4 -> x5 -> x6 -> k -> xs k
type Var8 = 'Var 'VS 'VS 'VS 'VS 'VS 'VS 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x7 -> k -> xs k :: TyVar x6 -> x7 -> k -> xs k :: TyVar x5 -> x6 -> x7 -> k -> xs k :: TyVar x4 -> x5 -> x6 -> x7 -> k -> xs k :: TyVar x3 -> x4 -> x5 -> x6 -> x7 -> k -> xs k :: TyVar x2 -> x3 -> x4 -> x5 -> x6 -> x7 -> k -> xs k :: TyVar x1 -> x2 -> x3 -> x4 -> x5 -> x6 -> x7 -> k -> xs k :: TyVar x -> x1 -> x2 -> x3 -> x4 -> x5 -> x6 -> x7 -> k -> xs k
type Var9 = 'Var 'VS 'VS 'VS 'VS 'VS 'VS 'VS 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x8 -> k -> xs k :: TyVar x7 -> x8 -> k -> xs k :: TyVar x6 -> x7 -> x8 -> k -> xs k :: TyVar x5 -> x6 -> x7 -> x8 -> k -> xs k :: TyVar x4 -> x5 -> x6 -> x7 -> x8 -> k -> xs k :: TyVar x3 -> x4 -> x5 -> x6 -> x7 -> x8 -> k -> xs k :: TyVar x2 -> x3 -> x4 -> x5 -> x6 -> x7 -> x8 -> k -> xs k :: TyVar x1 -> x2 -> x3 -> x4 -> x5 -> x6 -> x7 -> x8 -> k -> xs k :: TyVar x -> x1 -> x2 -> x3 -> x4 -> x5 -> x6 -> x7 -> x8 -> k -> xs k

-- | Replaces the holes in the <a>Atom</a> <tt>t</tt> by the elements of
--   the list of types <tt>tys</tt>. The amount and kind of types in
--   <tt>tys</tt> must match statically those required by the <a>Atom</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Interpret ([] :$: Var0) (LoT1 Int)
--   Interpret ([] :$: Var0) (LoT1 Int) :: *
--   = [Int]
--   </pre>
type family Interpret (t :: Atom d k) (tys :: LoT d) :: k

-- | Obtains the type in the list <tt>tys</tt> referenced by the type
--   variable <tt>t</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Interpret Var0 (LoT2 Int Bool)
--   Interpret Var0 (LoT2 Int Bool) :: *
--   = Int
--   
--   &gt;&gt;&gt; :kind! Interpret Var1 (LoT2 Int Bool)
--   Interpret Var1 (LoT2 Int Bool) :: *
--   = Bool
--   </pre>
type family InterpretVar (t :: TyVar d k) (tys :: LoT d) :: k

-- | Interprets a list of <a>Atom</a> representing constraints into the
--   actual constraints. This is a specialization of <a>Interpret</a> for
--   the case of constraints.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Satisfies '[Eq :$: Var0, Show :$: Var0] (LoT1 Int)
--   Satisfies '[Eq :$: Var0, Show :$: Var0] (LoT1 Int) :: Constraint
--   = (Eq Int, (Show Int, () :: Constraint))
--   </pre>
type family Satisfies (cs :: [Atom d Constraint]) (tys :: LoT d)

-- | Determines whether a given type variable <tt>v</tt> is used within an
--   <a>Atom</a> <tt>t</tt>. If not, we know that the atom is constant with
--   respect to that variable.
type family ContainsTyVar (v :: TyVar d k) (t :: Atom d p) :: Bool

-- | Auxiliary type for interpretation of the <a>ForAll</a> atom. Required
--   because a type family like <a>Interpret</a> cannot return a
--   polymorphic type.
newtype ForAllI (f :: Atom d1 -> d Type) (tys :: LoT d)
[ForAllI] :: forall {d1} {d} (f :: Atom (d1 -> d) Type) (tys :: LoT d). (forall (t :: d1). () => Interpret f (t ':&&: tys)) -> ForAllI f tys

-- | Auxiliary type for interpretation of the <a>(:=&gt;&gt;:)</a> atom.
--   Required because a type family like <a>Interpret</a> cannot return a
--   type with constraints.
newtype SuchThatI (c :: Atom d Constraint) (f :: Atom d Type) (tys :: LoT d)
[SuchThatI] :: forall {d} (c :: Atom d Constraint) (tys :: LoT d) (f :: Atom d Type). (Interpret c tys => Interpret f tys) -> SuchThatI c f tys

-- | Records a value of type <tt>f</tt> applied to the list <tt>tys</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; :t WrapI [1] :: WrappedI ([] :$: Var0) (LoT1 Int)
--   WrapI [1] :: WrappedI ([] :$: Var0) (LoT1 Int)
--   </pre>
newtype WrappedI (f :: Atom d Type) (tys :: LoT d)
WrapI :: Interpret f tys -> WrappedI (f :: Atom d Type) (tys :: LoT d)
[unwrapI] :: WrappedI (f :: Atom d Type) (tys :: LoT d) -> Interpret f tys
toWrappedI :: forall {d1} {ks} (f :: Atom (d1 -> ks) Type) (tys :: LoT ks) (t :: d1). ForAllI f tys -> WrappedI f (t ':&&: tys)
fromWrappedI :: forall {d1} {d} (f :: Atom (d1 -> d) Type) (tys :: LoT d). (forall (t :: d1). () => WrappedI f (t ':&&: tys)) -> ForAllI f tys


-- | Poly-kinded <a>Functor</a> type class. <a>KFunctor</a> generalizes
--   functors, bifunctors, profunctors, ... by declaring a list of
--   <a>Variance</a>s for a type constructor.
module Data.PolyKinded.Functor

-- | Declares that the type constructor <tt>f</tt> is a generalized functor
--   whose variances for each type argument are given by <tt>v</tt>.
class KFunctor (f :: k) (v :: Variances) (as :: LoT k) (bs :: LoT k) | f -> v

-- | The generalized version of <a>fmap</a>, <tt>bimap</tt>,
--   <tt>dimap</tt>, and so on.
kfmap :: KFunctor f v as bs => Mappings v as bs -> (f :@@: as) -> f :@@: bs

-- | The generalized version of <a>fmap</a>, <tt>bimap</tt>,
--   <tt>dimap</tt>, and so on. This version uses <tt>Split</tt> to obtain
--   better type inference.
kmapo :: forall {k} (f :: k) (v :: Variances) (as :: LoT k) (bs :: LoT k). KFunctor f v as bs => Mappings v as bs -> (f :@@: as) -> f :@@: bs

-- | Possible variances for each argument of a type constructor.
data Variance

-- | The functor is covariant in this position.
Co :: Variance

-- | The functor is contravariant in this position.
Contra :: Variance

-- | This position is not used in any constructor.
Phantom :: Variance
type Variances = [Variance]

-- | If a <a>KFunctor</a> needs to map an <tt>f ... a ...</tt> to an <tt>f
--   ... b ...</tt>, a <tt>Mapping v a b</tt> specifies which function
--   needs to be provided for that position depending on its variance
--   <tt>v</tt>.
type family Mapping (v :: Variance) a b

-- | List of mappings for the list of variances <tt>v</tt>.
data Mappings (v :: Variances) (x :: LoT k) (y :: LoT k)
[M0] :: Mappings ('[] :: [Variance]) 'LoT0 'LoT0
[:^:] :: forall {k1} (v1 :: Variance) a b (vs :: [Variance]) (as :: LoT k1) (bs :: LoT k1). Mapping v1 a b -> Mappings vs as bs -> Mappings (v1 ': vs) (a ':&&: as) (b ':&&: bs)
infixr 5 :^:


-- | Extensions to the <a>GHC.Generics</a> module.
module GHC.Generics.Extra

-- | Constraints: used to represent constraints in a constructor.
--   
--   <pre>
--   data Showable a = Show a =&gt; a -&gt; X a
--   
--   instance Generic (Showable a) where
--     type Rep (Showable a) = (Show a) :=&gt;: (K1 R a)
--   </pre>
data ( c :=>: (f :: k -> Type) ) (a :: k)
[SuchThat] :: forall {k} c (f :: k -> Type) (a :: k). c => f a -> (c :=>: f) a
