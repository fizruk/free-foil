-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient Type-Safe Capture-Avoiding Substitution for Free (Scoped Monads)
--   
--   Please see the README on GitHub at
--   <a>https://github.com/fizruk/free-foil#readme</a>
@package free-foil
@version 0.2.0

module Control.Monad.Foil.Internal.ValidNameBinders
type family SubstInRepK (i :: TyVar d k) (atom :: Atom d k) (f :: LoT d -> Type) :: LoT d -> Type
type family SubstInAtom (i :: TyVar d k) (atom :: Atom d k) (f :: Atom d k1) :: Atom d k1
type ShowKindedScope (oo :: Atom d s) (n :: Atom d s) (ll :: Atom d s) = ShowScope oo n ll ':<>: 'Text " : S"
type family ShowScope (oo :: Atom d s) (n :: Atom d s) (ll :: Atom d s) :: ErrorMessage
type family ShowScopeN (i :: Natural) (n :: Atom d s) :: ErrorMessage
type ShowSaturatedPatternType (pattern :: t) (oo :: Atom d s) (n :: Atom d s) (l :: Atom d s) (ll :: Atom d s) = 'ShowType pattern ':<>: 'Text " " ':<>: ShowScope oo n ll ':<>: 'Text " " ':<>: ShowScope oo l ll
type family GInnerScopeOfAtom (msg :: ErrorMessage) (icon :: Nat) (ifield :: Nat) (pattern :: s -> s -> Type) (atom :: Atom d Type) (oo :: Atom d s) (n :: Atom d s) (ll :: Atom d s) :: Atom d s
type family SameInnerScope (msg :: ErrorMessage) (icon :: Nat) (pattern :: s -> s -> Type) (n :: Atom k s) (l :: Atom k s) :: Atom k s
type family GValidNameBinders (pattern :: s -> s -> Type) (f :: LoT s -> s -> Type -> Type)
type family AtomSucc (atom :: Atom d k1) :: Atom k -> d k1
type family AtomUnSucc (msg :: ErrorMessage) (icon :: Nat) (pattern :: s -> s -> Type) (oo :: Atom d s) (ll :: Atom d s) (atom :: Atom k -> d k1) :: Atom d k1
type family First (x :: Atom d k1) (y :: Atom d1 k2) :: Atom d k1
type family AndShowFieldNumber (ifield :: Natural) (msg :: ErrorMessage) :: ErrorMessage
type family AndShowConNumber (icon :: Natural) (msg :: ErrorMessage) :: ErrorMessage
type AndShowDataType (pattern :: t) (n :: Atom d s) (l :: Atom d s) (msg :: ErrorMessage) = 'Text "when tracking Foil scopes for the data type" ':$$: 'Text "  " ':<>: ShowSaturatedPatternType pattern n n l l ':$$: msg
type ShowLocalizeError (msg :: ErrorMessage) (icon :: Natural) (ifield :: Natural) (pattern :: t) (o :: Atom d s) (l :: Atom d s) = AndShowFieldNumber ifield AndShowConNumber icon AndShowDataType pattern o l msg
type family CountCons (f :: k -> Type) :: Natural
type family CountFields (f :: k -> Type) :: Natural
type family GInnerScopeOfRepK (msg :: ErrorMessage) (icon :: Nat) (ifield :: Nat) (pattern :: s -> s -> Type) (f :: LoT k -> Type) (o :: Atom k s) (n :: Atom k s) (l :: Atom k s) :: Atom k s
type family PutBackLoT (i :: TyVar d s) (c :: s) (bs :: LoT k) :: LoT k


-- | Main definitions of the foil that can be reused for specific
--   implementations. This is an internal module, so it also contains
--   implementation details of the foil.
--   
--   The original description of this approach is described in the IFL 2022
--   paper by Maclaurin, Radul, and Paszke <a>«The Foil: Capture-Avoiding
--   Substitution With No Sharp Edges»</a>. This module also introduces
--   <a>CoSinkable</a> class, generalizing handling of patterns, as
--   described in <a>«Free Foil: Generating Efficient and Scope-Safe
--   Abstract Syntax»</a>.
--   
--   Since the representation of scopes and substitutions is either
--   <a>IntMap</a> or <a>IntSet</a>, many of the operations have a
--   worst-case complexity of &lt;math&gt;. This means that the operation
--   can become linear in the size of the scope &lt;math&gt; with a maximum
--   of &lt;math&gt; — the number of bits in an <a>Int</a> (32 or 64).
module Control.Monad.Foil.Internal

-- | <a>S</a> is a data kind of scope indices.
data S

-- | <a>VoidS</a> is the only explicit scope available to the users,
--   representing an empty scope. All other scopes are represented with
--   type variables, bound in rank-2 polymophic functions like
--   <a>withFreshBinder</a>.
VoidS :: S

-- | A safe scope, indexed by a type-level scope index <tt>n</tt>.
newtype Scope (n :: S)
UnsafeScope :: RawScope -> Scope (n :: S)

-- | A name in a safe scope, indexed by a type-level scope index
--   <tt>n</tt>.
newtype Name (n :: S)
UnsafeName :: RawName -> Name (n :: S)

-- | Convert <a>Name</a> into an identifier. This may be useful for
--   printing and debugging.
nameId :: forall (l :: S). Name l -> Id

-- | A name binder is a name that extends scope <tt>n</tt> to a (larger)
--   scope <tt>l</tt>.
newtype NameBinder (n :: S) (l :: S)
UnsafeNameBinder :: Name l -> NameBinder (n :: S) (l :: S)

-- | An empty scope (without any names).
emptyScope :: Scope 'VoidS

-- | A runtime check for potential name capture.
member :: forall (l :: S) (n :: S). Name l -> Scope n -> Bool

-- | &lt;math&gt;. Extend a scope with one name (safely). Note that as long
--   as the foil is used as intended, the name binder is guaranteed to
--   introduce a name that does not appear in the initial scope.
extendScope :: forall (n :: S) (l :: S). NameBinder n l -> Scope n -> Scope l

-- | Extend scope with variables inside a pattern. This is a more flexible
--   version of <a>extendScope</a>.
extendScopePattern :: forall (n :: S) pattern (l :: S). (Distinct n, CoSinkable pattern) => pattern n l -> Scope n -> Scope l

-- | Auxiliary data structure for scope extension. Used in
--   <a>extendScopePattern</a>.
newtype ExtendScope (n :: S) (l :: S) (o :: S) (o' :: S)
ExtendScope :: (Scope n -> Scope l) -> ExtendScope (n :: S) (l :: S) (o :: S) (o' :: S)

-- | Identity scope extension (no extension).
idExtendScope :: forall (n :: S) (o :: S) (o' :: S). ExtendScope n n o o'

-- | Compose scope extensions.
compExtendScope :: forall (n :: S) (i :: S) (o :: S) (o' :: S) (l :: S) (o'' :: S). ExtendScope n i o o' -> ExtendScope i l o' o'' -> ExtendScope n l o o''

-- | Extract name from a name binder.
nameOf :: forall (n :: S) (l :: S). NameBinder n l -> Name l

-- | Extract names from a pattern. This is a more flexible version of
--   <tt>namesOf</tt>.
namesOfPattern :: forall pattern (n :: S) (l :: S). (Distinct n, CoSinkable pattern) => pattern n l -> [Name l]

-- | Auxiliary structure collecting names in scope <tt>l</tt> that extend
--   scope <tt>n</tt>. Used in <a>namesOfPattern</a>.
newtype NamesOf (n :: S) (l :: S) (o :: S) (o' :: S)
NamesOf :: [Name l] -> NamesOf (n :: S) (l :: S) (o :: S) (o' :: S)

-- | Empty list of names in scope <tt>n</tt>.
idNamesOf :: forall (n :: S) (o :: S) (o' :: S). NamesOf n n o o'

-- | Concatenation of names, resulting in a list of names in <tt>l</tt>
--   that extend scope <tt>n</tt>.
compNamesOf :: forall (n :: S) (i :: S) (o :: S) (o' :: S) (l :: S) (o'' :: S). NamesOf n i o o' -> NamesOf i l o' o'' -> NamesOf n l o o''

-- | Allocate a fresh binder for a given scope.
withFreshBinder :: forall (n :: S) r. Scope n -> (forall (l :: S). () => NameBinder n l -> r) -> r

-- | Safely produce a fresh name binder with respect to a given scope.
withFresh :: forall (n :: S) r. Distinct n => Scope n -> (forall (l :: S). DExt n l => NameBinder n l -> r) -> r

-- | Rename a given pattern into a fresh version of it to extend a given
--   scope.
--   
--   This is similar to <tt>withRefreshPattern</tt>, except here renaming
--   always takes place.
withFreshPattern :: forall (o :: S) pattern (e :: S -> Type) (n :: S) (l :: S) r. (Distinct o, CoSinkable pattern, Sinkable e, InjectName e) => Scope o -> pattern n l -> (forall (o' :: S). DExt o o' => (Substitution e n o -> Substitution e l o') -> pattern o o' -> r) -> r

-- | Safely rename (if necessary) a given name to extend a given scope.
--   This is similar to <a>withFresh</a>, except if the name does not clash
--   with the scope, it can be used immediately, without renaming.
withRefreshed :: forall (o :: S) (i :: S) r. Distinct o => Scope o -> Name i -> (forall (o' :: S). DExt o o' => NameBinder o o' -> r) -> r

-- | Safely rename (if necessary) a given pattern to extend a given scope.
--   This is similar to <a>withFreshPattern</a>, except if a name in the
--   pattern does not clash with the scope, it can be used immediately,
--   without renaming.
--   
--   This is a more general version of <a>withRefreshed</a>.
withRefreshedPattern :: forall (o :: S) pattern (e :: S -> Type) (n :: S) (l :: S) r. (Distinct o, CoSinkable pattern, Sinkable e, InjectName e) => Scope o -> pattern n l -> (forall (o' :: S). DExt o o' => (Substitution e n o -> Substitution e l o') -> pattern o o' -> r) -> r

-- | Refresh (if needed) bound variables introduced in a pattern.
--   
--   This is a version of <a>withRefreshedPattern</a> that uses functional
--   renamings instead of <a>Substitution</a>.
withRefreshedPattern' :: forall pattern (o :: S) e (n :: S) (l :: S) r. (CoSinkable pattern, Distinct o, InjectName e, Sinkable e) => Scope o -> pattern n l -> (forall (o' :: S). DExt o o' => ((Name n -> e o) -> Name l -> e o') -> pattern o o' -> r) -> r

-- | Unsafely declare that a given name (binder) is already fresh in any
--   scope <tt>n'</tt>.
unsafeAssertFresh :: forall (n :: S) (l :: S) (n' :: S) (l' :: S) r. NameBinder n l -> (DExt n' l' => NameBinder n' l' -> r) -> r

-- | Auxiliary structure to accumulate substitution extensions produced
--   when refreshing a pattern. Used in <a>withRefreshedPattern</a> and
--   <a>withFreshPattern</a>.
newtype WithRefreshedPattern (e :: S -> Type) (n :: S) (l :: S) (o :: S) (o' :: S)
WithRefreshedPattern :: (Substitution e n o -> Substitution e l o') -> WithRefreshedPattern (e :: S -> Type) (n :: S) (l :: S) (o :: S) (o' :: S)

-- | Trivial substitution (coercion via <a>sink</a>).
idWithRefreshedPattern :: forall (e :: S -> Type) (o :: S) (o' :: S) (n :: S). (Sinkable e, DExt o o') => WithRefreshedPattern e n n o o'

-- | Composition of substitution extensions.
compWithRefreshedPattern :: forall (o :: S) (o' :: S) (o'' :: S) (e :: S -> Type) (n :: S) (i :: S) (l :: S). (DExt o o', DExt o' o'') => WithRefreshedPattern e n i o o' -> WithRefreshedPattern e i l o' o'' -> WithRefreshedPattern e n l o o''

-- | Auxiliary structure to accumulate substitution extensions produced
--   when refreshing a pattern. Similar to <a>WithRefreshedPattern</a>,
--   except here substitutions are represented as functions. Used in
--   <a>withRefreshedPattern'</a>.
newtype WithRefreshedPattern' (e :: S -> Type) (n :: S) (l :: S) (o :: S) (o' :: S)
WithRefreshedPattern' :: ((Name n -> e o) -> Name l -> e o') -> WithRefreshedPattern' (e :: S -> Type) (n :: S) (l :: S) (o :: S) (o' :: S)

-- | Trivial substitution extension (coercion via <a>sink</a>).
idWithRefreshedPattern' :: forall (e :: S -> Type) (o :: S) (o' :: S) (n :: S). (Sinkable e, DExt o o') => WithRefreshedPattern' e n n o o'

-- | Composition of substitution extensions.
compWithRefreshedPattern' :: forall (o :: S) (o' :: S) (o'' :: S) (e :: S -> Type) (n :: S) (i :: S) (l :: S). (DExt o o', DExt o' o'') => WithRefreshedPattern' e n i o o' -> WithRefreshedPattern' e i l o' o'' -> WithRefreshedPattern' e n l o o''

-- | Evidence that scope <tt>n</tt> contains distinct names.
data DistinctEvidence (n :: S)
[Distinct] :: forall (n :: S). Distinct n => DistinctEvidence n

-- | Evidence that scope <tt>l</tt> extends scope <tt>n</tt>.
data ExtEvidence (n :: S) (l :: S)
[Ext] :: forall (n :: S) (l :: S). Ext n l => ExtEvidence n l

-- | A distinct scope extended with a <a>NameBinder</a> is also distinct.
assertDistinct :: forall (n :: S) pattern (l :: S). (Distinct n, CoSinkable pattern) => pattern n l -> DistinctEvidence l

-- | A distinct scope extended with a <a>NameBinder</a> is also distinct.
assertExt :: forall pattern (n :: S) (l :: S). CoSinkable pattern => pattern n l -> ExtEvidence n l

-- | Unsafely declare that scope <tt>n</tt> is distinct. Used in
--   <a>unsafeAssertFresh</a>.
unsafeDistinct :: forall (n :: S). DistinctEvidence n

-- | Unsafely declare that scope <tt>l</tt> extends scope <tt>n</tt>. Used
--   in <a>unsafeAssertFresh</a>.
unsafeExt :: forall (n :: S) (l :: S). ExtEvidence n l

-- | Try coercing the name back to the (smaller) scope, given a binder that
--   extends that scope.
unsinkName :: forall (n :: S) (l :: S). NameBinder n l -> Name l -> Maybe (Name n)

-- | Check if a name in the extended context is introduced in a pattern or
--   comes from the outer scope <tt>n</tt>.
--   
--   This is a generalization of <a>unsinkName</a>.
unsinkNamePattern :: forall pattern (n :: S) (l :: S). (Distinct n, CoSinkable pattern) => pattern n l -> Name l -> Maybe (Name n)

-- | Auxiliary structure for unsinking names. Used in
--   <a>unsinkNamePattern</a>.
newtype UnsinkName (n :: S) (l :: S) (o :: S) (o' :: S)
UnsinkName :: (Name l -> Maybe (Name n)) -> UnsinkName (n :: S) (l :: S) (o :: S) (o' :: S)

-- | Trivial unsinking. If no scope extension took place, any name is free
--   (since it cannot be bound by anything).
idUnsinkName :: forall (n :: S) (o :: S) (o' :: S). UnsinkName n n o o'

-- | Composition of unsinking for nested binders/patterns.
compUnsinkName :: forall (n :: S) (i :: S) (o :: S) (o' :: S) (l :: S) (o'' :: S). UnsinkName n i o o' -> UnsinkName i l o' o'' -> UnsinkName n l o o''

-- | Unification result for two binders, extending some common scope to
--   scopes <tt>l</tt> and <tt>r</tt> respectively.
--   
--   Due to the implementation of the foil, we can often rename binders
--   efficiently, by renaming binders only in one of the two unified terms.
data UnifyNameBinders (pattern :: S -> S -> Type) (n :: S) (l :: S) (r :: S)

-- | Binders are the same, proving that type parameters <tt>l</tt> and
--   <tt>r</tt> are in fact equivalent.
[SameNameBinders] :: forall (n :: S) (l :: S) (pattern :: S -> S -> Type). NameBinders n l -> UnifyNameBinders pattern n l l

-- | It is possible to safely rename the left binder to match the right
--   one.
[RenameLeftNameBinder] :: forall (n :: S) (r :: S) (l :: S) (pattern :: S -> S -> Type). NameBinders n r -> (NameBinder n l -> NameBinder n r) -> UnifyNameBinders pattern n l r

-- | It is possible to safely rename the right binder to match the left
--   one.
[RenameRightNameBinder] :: forall (n :: S) (l :: S) (r :: S) (pattern :: S -> S -> Type). NameBinders n l -> (NameBinder n r -> NameBinder n l) -> UnifyNameBinders pattern n l r

-- | It is necessary to rename both binders.
[RenameBothBinders] :: forall (n :: S) (lr :: S) (l :: S) (r :: S) (pattern :: S -> S -> Type). NameBinders n lr -> (NameBinder n l -> NameBinder n lr) -> (NameBinder n r -> NameBinder n lr) -> UnifyNameBinders pattern n l r

-- | Cannot unify to (sub)patterns.
[NotUnifiable] :: forall (pattern :: S -> S -> Type) (n :: S) (l :: S) (r :: S). UnifyNameBinders pattern n l r

-- | Unify binders either by asserting that they are the same, or by
--   providing a <i>safe</i> renaming function to convert one binder to
--   another.
unifyNameBinders :: forall (i :: S) (l :: S) (r :: S) (pattern :: S -> S -> Type). Distinct i => NameBinder i l -> NameBinder i r -> UnifyNameBinders pattern i l r

-- | Unsafely merge results of unification for nested binders/patterns.
--   Used in <a>andThenUnifyPatterns</a>.
unsafeMergeUnifyBinders :: forall (pattern :: S -> S -> Type) (a :: S) (a' :: S) (a'' :: S) (a''' :: S) (b' :: S) (b'' :: S). UnifyNameBinders pattern a a' a'' -> UnifyNameBinders pattern a''' b' b'' -> UnifyNameBinders pattern a b' b''

-- | Chain unification of nested patterns.
andThenUnifyPatterns :: forall pattern (l :: S) (l' :: S) (n :: S) (r :: S) (r' :: S). (UnifiablePattern pattern, Distinct l, Distinct l') => UnifyNameBinders pattern n l l' -> (pattern l r, pattern l' r') -> UnifyNameBinders pattern n r r'

-- | Chain unification of nested patterns with <a>NameBinder</a>s.
andThenUnifyNameBinders :: forall (pattern :: S -> S -> Type) (l :: S) (l' :: S) (n :: S) (r :: S) (r' :: S). (UnifiablePattern pattern, Distinct l, Distinct l') => UnifyNameBinders pattern n l l' -> (NameBinder l r, NameBinder l' r') -> UnifyNameBinders pattern n r r'

-- | An <i>unordered</i> collection of <a>NameBinder</a>s, that together
--   extend scope <tt>n</tt> to scope <tt>l</tt>.
--   
--   For an ordered version see <a>NameBinderList</a>.
newtype NameBinders (n :: S) (l :: S)
UnsafeNameBinders :: IntSet -> NameBinders (n :: S) (l :: S)

-- | <i>Unsafely</i> merge sets of binders (via set union).
unsafeMergeNameBinders :: forall (a :: S) (b :: S) (c :: S) (d :: S) (n :: S) (l :: S). NameBinders a b -> NameBinders c d -> NameBinders n l

-- | An empty set of binders keeps the scope as is.
emptyNameBinders :: forall (n :: S). NameBinders n n

-- | Composition of sets of binders.
mergeNameBinders :: forall (n :: S) (i :: S) (l :: S). NameBinders n i -> NameBinders i l -> NameBinders n l

-- | A singleton name binder set.
nameBindersSingleton :: forall (n :: S) (l :: S). NameBinder n l -> NameBinders n l

-- | An <i>ordered</i> collection (list) of <a>NameBinder</a>s, that
--   together extend scope <tt>n</tt> to scope <tt>l</tt>.
--   
--   For an unordered version see <a>NameBinders</a>.
data NameBinderList (n :: S) (l :: S)

-- | An empty list of binders keeps the scope as is.
[NameBinderListEmpty] :: forall (n :: S). NameBinderList n n

-- | A non-empty list of binders.
[NameBinderListCons] :: forall (n :: S) (i :: S) (l :: S). NameBinder n i -> NameBinderList i l -> NameBinderList n l

-- | Convert an unordered set of name binders into an ordered list (with
--   some order).
nameBindersList :: forall (n :: S) (l :: S). NameBinders n l -> NameBinderList n l

-- | Convert an ordered list of name binders into an unordered set.
fromNameBindersList :: forall (n :: S) (l :: S). NameBinderList n l -> NameBinders n l

-- | An empty pattern type specifies zero possibilities for patterns.
--   
--   This type can be used to specify that patterns are not possible.
data V2 (n :: S) (l :: S)

-- | Since <a>V2</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
absurd2 :: forall (n :: S) (l :: S) a. V2 n l -> a

-- | A unit pattern type corresponds to a wildcard pattern.
data U2 (n :: S) (l :: S)
[U2] :: forall (n :: S). U2 n n

-- | A pattern type is unifiable if it is possible to match two patterns
--   and decide how to rename binders.
class CoSinkable pattern => UnifiablePattern (pattern :: S -> S -> Type)

-- | Unify two patterns and decide which binders need to be renamed.
unifyPatterns :: forall (n :: S) (l :: S) (r :: S). (UnifiablePattern pattern, Distinct n) => pattern n l -> pattern n r -> UnifyNameBinders pattern n l r
($dmunifyPatterns) :: forall (n :: S) (l :: S) (r :: S). (UnifiablePattern pattern, CoSinkable pattern, Distinct n) => pattern n l -> pattern n r -> UnifyNameBinders pattern n l r

-- | Unification of values in patterns. By default, <a>Eq</a> instance is
--   used, but it may be useful to ignore some data in pattens (such as
--   location annotations).
class UnifiableInPattern a

-- | Unify non-binding components of a pattern.
unifyInPattern :: UnifiableInPattern a => a -> a -> Bool
($dmunifyInPattern) :: (UnifiableInPattern a, Eq a) => a -> a -> Bool

-- | The easiest way to compare two patterns is to check if they are the
--   same. This function is labelled <i>unsafe</i>, since we generally are
--   interested in proper α-equivalence instead of direct equality.
unsafeEqPattern :: forall pattern (n :: S) (l :: S) (n' :: S) (l' :: S). (UnifiablePattern pattern, Distinct n) => pattern n l -> pattern n' l' -> Bool

-- | Sinking an expression from scope <tt>n</tt> into a (usualy extended)
--   scope <tt>l</tt>, given the renaming (injection from scope <tt>n</tt>
--   to scope <tt>l</tt>).
class Sinkable (e :: S -> Type)

-- | An implementation of this method that typechecks proves to the
--   compiler that the expression is indeed <a>Sinkable</a>. However,
--   instead of this implementation, <a>sink</a> should be used at all call
--   sites for efficiency.
sinkabilityProof :: forall (n :: S) (l :: S). Sinkable e => (Name n -> Name l) -> e n -> e l
($dmsinkabilityProof) :: forall (n :: S) (l :: S). (Sinkable e, GenericK e, GSinkableK (RepK e)) => (Name n -> Name l) -> e n -> e l

-- | Efficient version of <a>sinkabilityProof</a>. In fact, once
--   <a>sinkabilityProof</a> typechecks, it is safe to <a>sink</a> by
--   coercion. See Section 3.5 in <a>«The Foil: Capture-Avoiding
--   Substitution With No Sharp Edges»</a> for the details.
sink :: forall e (n :: S) (l :: S). (Sinkable e, DExt n l) => e n -> e l

-- | Extend renaming when going under a <a>CoSinkable</a> pattern
--   (generalized binder). Note that the scope under pattern is independent
--   of the codomain of the renaming.
--   
--   This function is used to go under binders when implementing
--   <a>sinkabilityProof</a> and is both a generalization of
--   <a>extendRenamingNameBinder</a> and an efficient implementation of
--   <a>coSinkabilityProof</a>.
extendRenaming :: forall pattern (n :: S) (n' :: S) (l :: S) r. CoSinkable pattern => (Name n -> Name n') -> pattern n l -> (forall (l' :: S). () => (Name l -> Name l') -> pattern n' l' -> r) -> r

-- | Extend renaming of binders when going under a <a>CoSinkable</a>
--   pattern (generalized binder). Note that the scope under pattern is
--   independent of the codomain of the renaming.
extendNameBinderRenaming :: forall pattern (i :: S) (n :: S) (n' :: S) (l :: S) r. CoSinkable pattern => (NameBinder i n -> NameBinder i n') -> pattern n l -> (forall (l' :: S). () => (NameBinder n' l -> NameBinder n' l') -> pattern n' l' -> r) -> r

-- | Safely compose renamings of name binders. The underlying
--   implementation is
composeNameBinderRenamings :: forall (n :: S) (i :: S) (i' :: S) (l :: S) (l' :: S). (NameBinder n i -> NameBinder n i') -> (NameBinder i' l -> NameBinder i' l') -> NameBinder n l -> NameBinder n l'

-- | Convert renaming of name binders into renaming of names in the inner
--   scopes.
fromNameBinderRenaming :: forall (n :: S) (l :: S) (l' :: S). (NameBinder n l -> NameBinder n l') -> Name l -> Name l'

-- | Extend renaming when going under a <a>NameBinder</a>. Note that the
--   scope under binder is independent of the codomain of the renaming.
--   
--   Semantically, this function may need to rename the binder (resulting
--   in the new scope <tt>l'</tt>), to make sure it does not clash with
--   scope <tt>n'</tt>. However, as it turns out, the foil makes it safe to
--   implement this function as a coercion. See Appendix A in <a>«The Foil:
--   Capture-Avoiding Substitution With No Sharp Edges»</a> for the
--   details.
--   
--   This function is used to go under binders when implementing
--   <a>sinkabilityProof</a>. A generalization of this function is
--   <a>extendRenaming</a> (which is an efficient version of
--   <a>coSinkabilityProof</a>).
extendRenamingNameBinder :: forall (n :: S) (n' :: S) (l :: S) r. (Name n -> Name n') -> NameBinder n l -> (forall (l' :: S). () => (Name l -> Name l') -> NameBinder n' l' -> r) -> r

-- | <a>CoSinkable</a> is to patterns (generalized binders) what
--   <a>Sinkable</a> is to expressions.
--   
--   See Section 2.3 of <a>«Free Foil: Generating Efficient and Scope-Safe
--   Abstract Syntax»</a> for more details.
class CoSinkable (pattern :: S -> S -> Type)

-- | An implementation of this method that typechecks proves to the
--   compiler that the pattern is indeed <a>CoSinkable</a>. However,
--   instead of this implementation, <a>extendRenaming</a> should be used
--   at all call sites for efficiency.
coSinkabilityProof :: forall (n :: S) (n' :: S) (l :: S) r. CoSinkable pattern => (Name n -> Name n') -> pattern n l -> (forall (l' :: S). () => (Name l -> Name l') -> pattern n' l' -> r) -> r
($dmcoSinkabilityProof) :: forall (n :: S) (n' :: S) (l :: S) r. (CoSinkable pattern, GenericK pattern, GSinkableK (RepK pattern)) => (Name n -> Name n') -> pattern n l -> (forall (l' :: S). () => (Name l -> Name l') -> pattern n' l' -> r) -> r

-- | Generalized processing of a pattern.
--   
--   You can see <a>withPattern</a> as a CPS-style traversal over the
--   binders in a pattern.
withPattern :: forall (o :: S) f (n :: S) (l :: S) r. (CoSinkable pattern, Distinct o) => (forall (x :: S) (y :: S) (z :: S) r'. Distinct z => Scope z -> NameBinder x y -> (forall (z' :: S). DExt z z' => f x y z z' -> NameBinder z z' -> r') -> r') -> (forall (x :: S) (z :: S) (z' :: S). DExt z z' => f x x z z') -> (forall (x :: S) (y :: S) (y' :: S) (z :: S) (z' :: S) (z'' :: S). (DExt z z', DExt z' z'') => f x y z z' -> f y y' z' z'' -> f x y' z z'') -> Scope o -> pattern n l -> (forall (o' :: S). DExt o o' => f n l o o' -> pattern o o' -> r) -> r
($dmwithPattern) :: forall (o :: S) f (n :: S) (l :: S) r. (CoSinkable pattern, Distinct o, GenericK pattern, GValidNameBinders pattern (RepK pattern), GHasNameBinders (RepK pattern)) => (forall (x :: S) (y :: S) (z :: S) r'. Distinct z => Scope z -> NameBinder x y -> (forall (z' :: S). DExt z z' => f x y z z' -> NameBinder z z' -> r') -> r') -> (forall (x :: S) (z :: S) (z' :: S). DExt z z' => f x x z z') -> (forall (x :: S) (y :: S) (y' :: S) (z :: S) (z' :: S) (z'' :: S). (DExt z z', DExt z' z'') => f x y z z' -> f y y' z' z'' -> f x y' z z'') -> Scope o -> pattern n l -> (forall (o' :: S). DExt o o' => f n l o o' -> pattern o o' -> r) -> r

-- | Auxiliary data structure for collecting name binders. Used in
--   <a>nameBinderListOf</a>.
newtype WithNameBinderList (r :: S) (n :: S) (l :: S) (o :: S) (o' :: S)
WithNameBinderList :: (NameBinderList l r -> NameBinderList n r) -> WithNameBinderList (r :: S) (n :: S) (l :: S) (o :: S) (o' :: S)

-- | Empty list of name binders (identity).
idWithNameBinderList :: forall (o :: S) (o' :: S) (r :: S) (n :: S). DExt o o' => WithNameBinderList r n n o o'

-- | Concatenating lists of name binders (compose).
compWithNameBinderList :: forall (o :: S) (o' :: S) (o'' :: S) (r :: S) (n :: S) (i :: S) (l :: S). (DExt o o', DExt o' o'') => WithNameBinderList r n i o o' -> WithNameBinderList r i l o' o'' -> WithNameBinderList r n l o o''

-- | Collect name binders of a generalized pattern into a name binder list,
--   which can be more easily traversed.
nameBinderListOf :: forall binder (n :: S) (l :: S). CoSinkable binder => binder n l -> NameBinderList n l

-- | A substitution is a mapping from names in scope <tt>i</tt> to
--   expressions <tt>e o</tt> in scope <tt>o</tt>.
newtype Substitution (e :: S -> Type) (i :: S) (o :: S)
UnsafeSubstitution :: IntMap (e o) -> Substitution (e :: S -> Type) (i :: S) (o :: S)

-- | Apply substitution to a given name.
lookupSubst :: forall e (i :: S) (o :: S). InjectName e => Substitution e i o -> Name i -> e o

-- | Identity substitution maps all names to expresion-variables.
identitySubst :: forall (e :: S -> Type) (i :: S). InjectName e => Substitution e i i

-- | An empty substitution from an empty scope.
voidSubst :: forall (e :: S -> Type) (n :: S). Substitution e 'VoidS n

-- | Extend substitution with a particular mapping.
addSubst :: forall e (i :: S) (o :: S) (i' :: S). Substitution e i o -> NameBinder i i' -> e o -> Substitution e i' o
addSubstPattern :: forall binder e (i :: S) (o :: S) (i' :: S). CoSinkable binder => Substitution e i o -> binder i i' -> [e o] -> Substitution e i' o
addSubstList :: forall e (i :: S) (o :: S) (i' :: S). Substitution e i o -> NameBinderList i i' -> [e o] -> Substitution e i' o

-- | Add variable renaming to a substitution. This includes the performance
--   optimization of eliding names mapped to themselves.
addRename :: forall (e :: S -> Type) (i :: S) (o :: S) (i' :: S). InjectName e => Substitution e i o -> NameBinder i i' -> Name o -> Substitution e i' o

-- | A <i>total</i> map from names in scope <tt>n</tt> to elements of type
--   <tt>a</tt>.
newtype NameMap (n :: S) a
NameMap :: IntMap a -> NameMap (n :: S) a
[getNameMap] :: NameMap (n :: S) a -> IntMap a

-- | An empty map belongs in the empty scope.
emptyNameMap :: NameMap 'VoidS a

-- | Convert a <a>NameMap</a> of expressions into a <a>Substitution</a>.
nameMapToSubstitution :: forall (i :: S) e (o :: S). NameMap i (e o) -> Substitution e i o

-- | Convert a <a>NameMap</a> of expressions into a <a>Scope</a>.
nameMapToScope :: forall (n :: S) a. NameMap n a -> Scope n

-- | Extend a map with multiple mappings (by repeatedly applying
--   <a>addNameBinder</a>).
--   
--   Note that the input list is expected to have <b>at least</b> the same
--   number of elements as there are binders in the input pattern
--   (generalized binder).
addNameBinders :: forall binder (n :: S) (l :: S) a. CoSinkable binder => binder n l -> [a] -> NameMap n a -> NameMap l a

-- | Extend a map with multiple mappings (by repeatedly applying
--   <a>addNameBinder</a>).
--   
--   Note that the input list is expected to have <b>at least</b> the same
--   number of elements as there are binders in the input name binder list.
--   
--   See also <a>addNameBinders</a> for a generalized version.
addNameBinderList :: forall (n :: S) (l :: S) a. NameBinderList n l -> [a] -> NameMap n a -> NameMap l a

-- | Looking up a name should always succeed.
--   
--   Note that since <a>Name</a> is <a>Sinkable</a>, you can lookup a name
--   from scope <tt>n</tt> in a <a>NameMap</a> for scope <tt>l</tt>
--   whenever <tt>l</tt> extends <tt>n</tt>.
lookupName :: forall (n :: S) a. Name n -> NameMap n a -> a

-- | Extending a map with a single mapping.
--   
--   Note that the scope parameter of the result differs from the initial
--   map.
addNameBinder :: forall (n :: S) (l :: S) a. NameBinder n l -> a -> NameMap n a -> NameMap l a

-- | We will use <a>Int</a> for efficient representation of identifiers.
type Id = Int

-- | Raw name is simply an identifier.
type RawName = Id

-- | A raw scope is a set of raw names.
type RawScope = IntSet

-- | &lt;math&gt;. Generate a fresh raw name that does not appear in a
--   given raw scope.
rawFreshName :: RawScope -> RawName

-- | Check if a raw name is contained in a raw scope.
rawMember :: RawName -> RawScope -> Bool

-- | Every scope is a (trivial) extension of itself.
--   
--   <b>Important</b>: this class exists to assist tracking scope
--   extensions for type variables of kind <a>S</a>. Users of the foil are
--   not supposed to implement any instances of <a>ExtEndo</a>.
class ExtEndo (n :: S)

-- | Some scopes are extensions of other scopes.
--   
--   <b>Important</b>: this class exists to assist tracking scope
--   extensions for type variables of kind <a>S</a>. Users of the foil are
--   not supposed to implement any instances of <a>Ext</a>.
class ExtEndo n => ExtEndo l => Ext (n :: S) (l :: S)

-- | Scopes with distinct names.
--   
--   <b>Important</b>: this class exists to explicitly mark scopes with
--   distinct names. Users of the foil are not supposed to implement any
--   instances of <a>Distinct</a>.
class Distinct (n :: S)

-- | Scope extensions with distinct names.
type DExt (n :: S) (l :: S) = (Distinct l, Ext n l)

-- | Instances of this typeclass possess the ability to inject names.
--   Usually, this is a variable data constructor.
class InjectName (e :: S -> Type)

-- | Inject names into expressions.
injectName :: forall (n :: S). InjectName e => Name n -> e n
data RenamingsK (as :: LoT k) (bs :: LoT k)
[RNil] :: RenamingsK 'LoT0 'LoT0
[RCons] :: forall {k1} (a :: S) (b :: S) (as1 :: LoT k1) (bs1 :: LoT k1). (Name a -> Name b) -> RenamingsK as1 bs1 -> RenamingsK (a ':&&: as1) (b ':&&: bs1)
[RSkip] :: forall {k1} {k2} (as1 :: LoT k1) (bs1 :: LoT k1) (k3 :: k2). RenamingsK as1 bs1 -> RenamingsK (k3 ':&&: as1) (k3 ':&&: bs1)
class SinkableK (f :: S -> k)
sinkabilityProofK :: forall (as :: LoT (S -> k)) (bs :: LoT (S -> k)) r. SinkableK f => RenamingsK as bs -> (f :@@: as) -> (forall (cs :: LoT (S -> k)). () => RenamingsK as cs -> (f :@@: cs) -> r) -> r
($dmsinkabilityProofK) :: forall (as :: LoT (S -> k)) (bs :: LoT (S -> k)) r. (SinkableK f, GenericK f, GSinkableK (RepK f)) => RenamingsK as bs -> (f :@@: as) -> (forall (cs :: LoT (S -> k)). () => RenamingsK as cs -> (f :@@: cs) -> r) -> r
sinkK :: forall {k} (f :: LoT k -> Type) (xs :: LoT (LoT k -> Type)) (as :: LoT (LoT k -> Type)) (bs :: LoT (LoT k -> Type)). GSinkableK f => RenamingsK xs as -> RenamingsK xs bs -> (f :@@: as) -> f :@@: bs
sinkabilityProof1 :: forall f (n :: S) (n' :: S). SinkableK f => (Name n -> Name n') -> f n -> f n'
gsinkabilityProof1 :: forall f (n :: S) (n' :: S). GSinkableK f => (Name n -> Name n') -> f (n ':&&: 'LoT0) -> f (n' ':&&: 'LoT0)
gsinkabilityProof2 :: forall f (n :: S) (n' :: S) (l :: S) r. GSinkableK f => (Name n -> Name n') -> f (n ':&&: (l ':&&: 'LoT0)) -> (forall (l' :: S). () => (Name l -> Name l') -> f (n' ':&&: (l' ':&&: 'LoT0)) -> r) -> r
gsinkabilityProofK' :: forall {k} f (as :: LoT k) (bs :: LoT k). GSinkableK f => RenamingsK as bs -> f as -> f bs
class GSinkableK (p :: LoT k -> Type)
gsinkabilityProofK :: forall (as :: LoT k) (bs :: LoT k) r. GSinkableK p => RenamingsK as bs -> p as -> (forall (cs :: LoT k). () => RenamingsK as cs -> p cs -> r) -> r
gsinkK :: forall {k} f (xs :: LoT k) (as :: LoT k) (bs :: LoT k). GSinkableK f => RenamingsK xs as -> RenamingsK xs bs -> f as -> f bs
class ExtractRenamingK (i :: TyVar k S)
extractRenamingK :: forall (as :: LoT k) (bs :: LoT k). ExtractRenamingK i => RenamingsK as bs -> Name (Interpret ('Var i) as) -> Name (Interpret ('Var i) bs)
putBackRenamingK :: forall (c :: S) (as :: LoT k) (bs :: LoT k). ExtractRenamingK i => (Name (Interpret ('Var i) as) -> Name c) -> RenamingsK as bs -> RenamingsK as (PutBackLoT i c bs)
extractTwoRenamingsK :: forall k (i :: TyVar k S) (j :: TyVar k S) (as :: LoT k) (bs :: LoT k). (ExtractRenamingK i, ExtractRenamingK j) => RenamingsK as bs -> RenamingsK (Interpret ('Var i) as ':&&: (Interpret ('Var j) as ':&&: 'LoT0)) (Interpret ('Var i) bs ':&&: (Interpret ('Var j) bs ':&&: 'LoT0))
putBackTwoRenamingsK :: forall k (i :: TyVar k S) (j :: TyVar k S) (c1 :: S) (c2 :: S) (as :: LoT k) (bs :: LoT k). (ExtractRenamingK i, ExtractRenamingK j) => RenamingsK (Interpret ('Var i) as ':&&: (Interpret ('Var j) as ':&&: 'LoT0)) (c1 ':&&: (c2 ':&&: 'LoT0)) -> RenamingsK as bs -> RenamingsK as (PutBackLoT j c2 (PutBackLoT i c1 bs))

-- | Generic generalized processing of a pattern via
--   <a>GHasNameBinders</a>.
--   
--   This can be used as a default implementation of <a>withPattern</a>.
gunsafeWithPatternViaHasNameBinders :: forall pattern f (o :: S) (n :: S) (l :: S) r. (Distinct o, GenericK pattern, GValidNameBinders pattern (RepK pattern), GHasNameBinders (RepK pattern)) => (forall (x :: S) (y :: S) (z :: S) r'. Distinct z => Scope z -> NameBinder x y -> (forall (z' :: S). DExt z z' => f x y z z' -> NameBinder z z' -> r') -> r') -> (forall (x :: S) (z :: S) (z' :: S). DExt z z' => f x x z z') -> (forall (x :: S) (y :: S) (y' :: S) (z :: S) (z' :: S) (z'' :: S). (DExt z z', DExt z' z'') => f x y z z' -> f y y' z' z'' -> f x y' z z'') -> Scope o -> pattern n l -> (forall (o' :: S). DExt o o' => f n l o o' -> pattern o o' -> r) -> r

-- | If <tt><a>HasNameBinders</a> f</tt>, then <tt>f n l</tt> is expected
--   to act as a binder, introducing into scope <tt>n</tt> some local
--   variables, extending it to scope <tt>l</tt>. This class allows to
--   extract and modify the set of binders.
class HasNameBinders (f :: S -> S -> Type)

-- | Extract a set of binders from a pattern.
getNameBinders :: forall (n :: S) (l :: S). HasNameBinders f => f n l -> NameBinders n l

-- | Replace binders in a pattern.
--   
--   This function is unsafe, because it does not check if the new set of
--   binders has the same size. It can therefore crash at runtime.
--   
--   You should probably not use this. This is only used for
--   <a>gunsafeWithPatternViaHasNameBinders</a>, which is then safe to use.
unsafeSetNameBinders :: forall (n :: S) (l :: S) (l' :: S). HasNameBinders f => f n l -> NameBinders n l' -> f n l'

-- | Extract <a>RawName</a>s of all binders occurring in a pattern.
getNameBindersRaw :: forall (n :: S) (l :: S). HasNameBinders f => f n l -> [RawName]
($dmgetNameBindersRaw) :: forall (n :: S) (l :: S). (HasNameBinders f, GenericK f, GHasNameBinders (RepK f)) => f n l -> [RawName]

-- | This is a version of <a>unsafeSetNameBinders</a> that takes in a list
--   of <a>RawName</a>s.
--   
--   It does not check if the given list has enough elements. It does not
--   check if the raw names are fresh in the scope <tt>n</tt>. It does not
--   check if the raw names given are distinct.
--   
--   You should never use this. This is only used for generic
--   implementation of <a>HasNameBinders</a>.
reallyUnsafeSetNameBindersRaw :: forall (n :: S) (l :: S) (l' :: S). HasNameBinders f => f n l -> [RawName] -> (f n l', [RawName])
($dmreallyUnsafeSetNameBindersRaw) :: forall (n :: S) (l :: S) (l' :: S). (HasNameBinders f, GenericK f, GValidNameBinders f (RepK f), GHasNameBinders (RepK f)) => f n l -> [RawName] -> (f n l', [RawName])
ggetNameBinders :: forall f (n :: S) (l :: S). (GenericK f, GHasNameBinders (RepK f)) => f n l -> NameBinders n l
gunsafeSetNameBinders :: forall f (n :: S) (l :: S) (l' :: S). (GenericK f, GValidNameBinders f (RepK f), GHasNameBinders (RepK f)) => f n l -> NameBinders n l' -> f n l'
class GHasNameBinders (f :: k -> Type)
ggetNameBindersRaw :: forall (as :: k). GHasNameBinders f => f as -> [RawName]
greallyUnsafeSetNameBindersRaw :: forall (as :: k) (bs :: k). GHasNameBinders f => f as -> [RawName] -> (f bs, [RawName])
instance Control.Monad.Foil.Internal.CoSinkable Control.Monad.Foil.Internal.NameBinder
instance Control.Monad.Foil.Internal.CoSinkable Control.Monad.Foil.Internal.NameBinderList
instance Control.Monad.Foil.Internal.CoSinkable Control.Monad.Foil.Internal.NameBinders
instance Control.Monad.Foil.Internal.CoSinkable Control.Monad.Foil.Internal.U2
instance Control.Monad.Foil.Internal.CoSinkable Control.Monad.Foil.Internal.V2
instance Control.Monad.Foil.Internal.Distinct 'Control.Monad.Foil.Internal.VoidS
instance GHC.Classes.Eq (Control.Monad.Foil.Internal.Name n)
instance GHC.Classes.Eq (Control.Monad.Foil.Internal.NameBinder n l)
instance (Control.Monad.Foil.Internal.ExtEndo n => Control.Monad.Foil.Internal.ExtEndo l) => Control.Monad.Foil.Internal.Ext n l
instance forall xs x1 (x2 :: Data.PolyKinded.Atom.TyVar xs Control.Monad.Foil.Internal.S). Control.Monad.Foil.Internal.ExtractRenamingK x2 => Control.Monad.Foil.Internal.ExtractRenamingK ('Data.PolyKinded.Atom.VS x2)
instance Control.Monad.Foil.Internal.ExtractRenamingK 'Data.PolyKinded.Atom.VZ
instance Data.Foldable.Foldable (Control.Monad.Foil.Internal.NameMap n)
instance GHC.Base.Functor (Control.Monad.Foil.Internal.NameMap n)
instance forall d k1 k2 (f :: Data.PolyKinded.LoT d -> *) (i :: Data.PolyKinded.Atom.TyVar d k1) (j :: Data.PolyKinded.Atom.TyVar d k2). Control.Monad.Foil.Internal.GHasNameBinders f => Control.Monad.Foil.Internal.GHasNameBinders (('Data.PolyKinded.Atom.Var i Data.PolyKinded.Atom.:~~: 'Data.PolyKinded.Atom.Var j) Generics.Kind.:=>: f)
instance forall d k (f :: Data.PolyKinded.LoT (k -> d) -> *). Control.Monad.Foil.Internal.GHasNameBinders f => Control.Monad.Foil.Internal.GHasNameBinders (Generics.Kind.Exists k f)
instance forall d (f :: Control.Monad.Foil.Internal.S -> Control.Monad.Foil.Internal.S -> *) (i :: Data.PolyKinded.Atom.TyVar d Control.Monad.Foil.Internal.S) (j :: Data.PolyKinded.Atom.TyVar d Control.Monad.Foil.Internal.S). Control.Monad.Foil.Internal.HasNameBinders f => Control.Monad.Foil.Internal.GHasNameBinders (Generics.Kind.Field (('Data.PolyKinded.Atom.Kon f 'Data.PolyKinded.Atom.:@: 'Data.PolyKinded.Atom.Var i) 'Data.PolyKinded.Atom.:@: 'Data.PolyKinded.Atom.Var j))
instance Control.Monad.Foil.Internal.GHasNameBinders (Generics.Kind.Field ('Data.PolyKinded.Atom.Kon a))
instance forall d (x :: Data.PolyKinded.Atom.TyVar d (*)). Control.Monad.Foil.Internal.GHasNameBinders (Generics.Kind.Field ('Data.PolyKinded.Atom.Var x))
instance forall k1 d (f :: k1 -> *) (i :: Data.PolyKinded.Atom.TyVar d k1). Control.Monad.Foil.Internal.GHasNameBinders (Generics.Kind.Field ('Data.PolyKinded.Atom.Kon f 'Data.PolyKinded.Atom.:@: 'Data.PolyKinded.Atom.Var i))
instance forall k (f :: k -> *) (g :: k -> *). (Control.Monad.Foil.Internal.GHasNameBinders f, Control.Monad.Foil.Internal.GHasNameBinders g) => Control.Monad.Foil.Internal.GHasNameBinders (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *). (Control.Monad.Foil.Internal.GHasNameBinders f, Control.Monad.Foil.Internal.GHasNameBinders g) => Control.Monad.Foil.Internal.GHasNameBinders (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) i (c :: GHC.Generics.Meta). Control.Monad.Foil.Internal.GHasNameBinders f => Control.Monad.Foil.Internal.GHasNameBinders (GHC.Generics.M1 i c f)
instance Control.Monad.Foil.Internal.GHasNameBinders GHC.Generics.U1
instance Control.Monad.Foil.Internal.GHasNameBinders GHC.Generics.V1
instance forall k1 xs (f :: k1 -> Control.Monad.Foil.Internal.S -> *) (a :: k1). Control.Monad.Foil.Internal.SinkableK (f a) => Control.Monad.Foil.Internal.GSinkableK (Generics.Kind.Field (('Data.PolyKinded.Atom.Kon f 'Data.PolyKinded.Atom.:@: 'Data.PolyKinded.Atom.Kon a) 'Data.PolyKinded.Atom.:@: Data.PolyKinded.Atom.Var0))
instance forall k2 k3 xs (f :: k2 -> k3 -> Control.Monad.Foil.Internal.S -> *) (a :: k2) (b :: k3). Control.Monad.Foil.Internal.SinkableK (f a b) => Control.Monad.Foil.Internal.GSinkableK (Generics.Kind.Field ((('Data.PolyKinded.Atom.Kon f 'Data.PolyKinded.Atom.:@: 'Data.PolyKinded.Atom.Kon a) 'Data.PolyKinded.Atom.:@: 'Data.PolyKinded.Atom.Kon b) 'Data.PolyKinded.Atom.:@: Data.PolyKinded.Atom.Var0))
instance forall k (f :: Data.PolyKinded.LoT k -> *) (g :: Data.PolyKinded.LoT k -> *). (Control.Monad.Foil.Internal.GSinkableK f, Control.Monad.Foil.Internal.GSinkableK g) => Control.Monad.Foil.Internal.GSinkableK (f GHC.Generics.:*: g)
instance forall k (f :: Data.PolyKinded.LoT k -> *) (g :: Data.PolyKinded.LoT k -> *). (Control.Monad.Foil.Internal.GSinkableK f, Control.Monad.Foil.Internal.GSinkableK g) => Control.Monad.Foil.Internal.GSinkableK (f GHC.Generics.:+: g)
instance forall k k1 k2 (f :: Data.PolyKinded.LoT k -> *) (a :: Data.PolyKinded.Atom.Atom k k1) (b :: Data.PolyKinded.Atom.Atom k k2). Control.Monad.Foil.Internal.GSinkableK f => Control.Monad.Foil.Internal.GSinkableK ((a Data.PolyKinded.Atom.:~~: b) Generics.Kind.:=>: f)
instance forall k (f :: Data.PolyKinded.LoT (Control.Monad.Foil.Internal.S -> k) -> *). Control.Monad.Foil.Internal.GSinkableK f => Control.Monad.Foil.Internal.GSinkableK (Generics.Kind.Exists Control.Monad.Foil.Internal.S f)
instance forall k1 k2 (f :: Data.PolyKinded.LoT (k2 -> k1) -> *). Control.Monad.Foil.Internal.GSinkableK f => Control.Monad.Foil.Internal.GSinkableK (Generics.Kind.Exists k2 f)
instance forall k (f :: Control.Monad.Foil.Internal.S -> *) (i :: Data.PolyKinded.Atom.TyVar k Control.Monad.Foil.Internal.S). (Control.Monad.Foil.Internal.SinkableK f, Control.Monad.Foil.Internal.ExtractRenamingK i) => Control.Monad.Foil.Internal.GSinkableK (Generics.Kind.Field ('Data.PolyKinded.Atom.Kon f 'Data.PolyKinded.Atom.:@: 'Data.PolyKinded.Atom.Var i))
instance forall (f :: Control.Monad.Foil.Internal.S -> Control.Monad.Foil.Internal.S -> *) k (i :: Data.PolyKinded.Atom.TyVar k Control.Monad.Foil.Internal.S) (j :: Data.PolyKinded.Atom.TyVar k Control.Monad.Foil.Internal.S). (Control.Monad.Foil.Internal.SinkableK f, Control.Monad.Foil.Internal.ExtractRenamingK i, Control.Monad.Foil.Internal.ExtractRenamingK j) => Control.Monad.Foil.Internal.GSinkableK (Generics.Kind.Field (('Data.PolyKinded.Atom.Kon f 'Data.PolyKinded.Atom.:@: 'Data.PolyKinded.Atom.Var i) 'Data.PolyKinded.Atom.:@: 'Data.PolyKinded.Atom.Var j))
instance Control.Monad.Foil.Internal.GSinkableK (Generics.Kind.Field ('Data.PolyKinded.Atom.Kon a))
instance forall k (a :: Data.PolyKinded.Atom.TyVar k (*)). Control.Monad.Foil.Internal.GSinkableK (Generics.Kind.Field ('Data.PolyKinded.Atom.Var a))
instance forall k (f :: * -> *) (x :: Data.PolyKinded.Atom.Atom k (*)). (GHC.Base.Functor f, Control.Monad.Foil.Internal.GSinkableK (Generics.Kind.Field x)) => Control.Monad.Foil.Internal.GSinkableK (Generics.Kind.Field ('Data.PolyKinded.Atom.Kon f 'Data.PolyKinded.Atom.:@: x))
instance forall k (f :: * -> * -> *) (x :: Data.PolyKinded.Atom.Atom k (*)) (y :: Data.PolyKinded.Atom.Atom k (*)). (Data.Bifunctor.Bifunctor f, Control.Monad.Foil.Internal.GSinkableK (Generics.Kind.Field x), Control.Monad.Foil.Internal.GSinkableK (Generics.Kind.Field y)) => Control.Monad.Foil.Internal.GSinkableK (Generics.Kind.Field (('Data.PolyKinded.Atom.Kon f 'Data.PolyKinded.Atom.:@: x) 'Data.PolyKinded.Atom.:@: y))
instance forall k (f :: Data.PolyKinded.LoT k -> *) i (c :: GHC.Generics.Meta). Control.Monad.Foil.Internal.GSinkableK f => Control.Monad.Foil.Internal.GSinkableK (GHC.Generics.M1 i c f)
instance Control.Monad.Foil.Internal.GSinkableK GHC.Generics.U1
instance Control.Monad.Foil.Internal.GSinkableK GHC.Generics.V1
instance Generics.Kind.GenericK Control.Monad.Foil.Internal.NameBinderList
instance Generics.Kind.GenericK Control.Monad.Foil.Internal.U2
instance Generics.Kind.GenericK Control.Monad.Foil.Internal.V2
instance Control.Monad.Foil.Internal.HasNameBinders Control.Monad.Foil.Internal.NameBinder
instance Control.Monad.Foil.Internal.HasNameBinders Control.Monad.Foil.Internal.NameBinderList
instance Control.DeepSeq.NFData (Control.Monad.Foil.Internal.Name n)
instance Control.DeepSeq.NFData (Control.Monad.Foil.Internal.NameBinder n l)
instance Control.DeepSeq.NFData (Control.Monad.Foil.Internal.Scope n)
instance GHC.Classes.Ord (Control.Monad.Foil.Internal.Name n)
instance GHC.Classes.Ord (Control.Monad.Foil.Internal.NameBinder n l)
instance GHC.Show.Show (Control.Monad.Foil.Internal.Name n)
instance GHC.Show.Show (Control.Monad.Foil.Internal.NameBinder n l)
instance Control.Monad.Foil.Internal.SinkableK Control.Monad.Foil.Internal.NameBinder
instance Control.Monad.Foil.Internal.SinkableK Control.Monad.Foil.Internal.NameBinderList
instance Control.Monad.Foil.Internal.SinkableK Control.Monad.Foil.Internal.NameBinders
instance Control.Monad.Foil.Internal.SinkableK Control.Monad.Foil.Internal.U2
instance Control.Monad.Foil.Internal.SinkableK Control.Monad.Foil.Internal.V2
instance Control.Monad.Foil.Internal.SinkableK Control.Monad.Foil.Internal.Name
instance Control.Monad.Foil.Internal.Sinkable Control.Monad.Foil.Internal.Name
instance Control.Monad.Foil.Internal.Sinkable e => Control.Monad.Foil.Internal.Sinkable (Control.Monad.Foil.Internal.Substitution e i)
instance Data.Traversable.Traversable (Control.Monad.Foil.Internal.NameMap n)
instance Control.Monad.Foil.Internal.UnifiablePattern Control.Monad.Foil.Internal.NameBinder
instance Control.Monad.Foil.Internal.UnifiablePattern Control.Monad.Foil.Internal.NameBinderList
instance Control.Monad.Foil.Internal.UnifiablePattern Control.Monad.Foil.Internal.U2
instance Control.Monad.Foil.Internal.UnifiablePattern Control.Monad.Foil.Internal.V2


-- | Main definitions of the foil that can be reused for specific
--   implementations.
--   
--   The original description of this approach is described in the IFL 2022
--   paper by Maclaurin, Radul, and Paszke <a>«The Foil: Capture-Avoiding
--   Substitution With No Sharp Edges»</a>. This module also introduces
--   <a>CoSinkable</a> class, generalizing handling of patterns, as
--   described in <a>«Free Foil: Generating Efficient and Scope-Safe
--   Abstract Syntax»</a>.
--   
--   Since the representation of scopes and substitutions is either
--   <tt>IntMap</tt> or <tt>IntSet</tt>, many of the operations have a
--   worst-case complexity of &lt;math&gt;. This means that the operation
--   can become linear in the size of the scope &lt;math&gt; with a maximum
--   of &lt;math&gt; — the number of bits in an <a>Int</a> (32 or 64).
module Control.Monad.Foil

-- | <a>S</a> is a data kind of scope indices.
data S

-- | <a>VoidS</a> is the only explicit scope available to the users,
--   representing an empty scope. All other scopes are represented with
--   type variables, bound in rank-2 polymophic functions like
--   <a>withFreshBinder</a>.
VoidS :: S

-- | A safe scope, indexed by a type-level scope index <tt>n</tt>.
data Scope (n :: S)

-- | A name in a safe scope, indexed by a type-level scope index
--   <tt>n</tt>.
data Name (n :: S)

-- | A name binder is a name that extends scope <tt>n</tt> to a (larger)
--   scope <tt>l</tt>.
data NameBinder (n :: S) (l :: S)

-- | An empty scope (without any names).
emptyScope :: Scope 'VoidS

-- | &lt;math&gt;. Extend a scope with one name (safely). Note that as long
--   as the foil is used as intended, the name binder is guaranteed to
--   introduce a name that does not appear in the initial scope.
extendScope :: forall (n :: S) (l :: S). NameBinder n l -> Scope n -> Scope l

-- | Extend scope with variables inside a pattern. This is a more flexible
--   version of <a>extendScope</a>.
extendScopePattern :: forall (n :: S) pattern (l :: S). (Distinct n, CoSinkable pattern) => pattern n l -> Scope n -> Scope l

-- | A runtime check for potential name capture.
member :: forall (l :: S) (n :: S). Name l -> Scope n -> Bool

-- | Extract name from a name binder.
nameOf :: forall (n :: S) (l :: S). NameBinder n l -> Name l

-- | Extract names from a pattern. This is a more flexible version of
--   <tt>namesOf</tt>.
namesOfPattern :: forall pattern (n :: S) (l :: S). (Distinct n, CoSinkable pattern) => pattern n l -> [Name l]

-- | Convert <a>Name</a> into an identifier. This may be useful for
--   printing and debugging.
nameId :: forall (l :: S). Name l -> Id

-- | Allocate a fresh binder for a given scope.
withFreshBinder :: forall (n :: S) r. Scope n -> (forall (l :: S). () => NameBinder n l -> r) -> r

-- | Safely produce a fresh name binder with respect to a given scope.
withFresh :: forall (n :: S) r. Distinct n => Scope n -> (forall (l :: S). DExt n l => NameBinder n l -> r) -> r

-- | Rename a given pattern into a fresh version of it to extend a given
--   scope.
--   
--   This is similar to <tt>withRefreshPattern</tt>, except here renaming
--   always takes place.
withFreshPattern :: forall (o :: S) pattern (e :: S -> Type) (n :: S) (l :: S) r. (Distinct o, CoSinkable pattern, Sinkable e, InjectName e) => Scope o -> pattern n l -> (forall (o' :: S). DExt o o' => (Substitution e n o -> Substitution e l o') -> pattern o o' -> r) -> r

-- | Safely rename (if necessary) a given name to extend a given scope.
--   This is similar to <a>withFresh</a>, except if the name does not clash
--   with the scope, it can be used immediately, without renaming.
withRefreshed :: forall (o :: S) (i :: S) r. Distinct o => Scope o -> Name i -> (forall (o' :: S). DExt o o' => NameBinder o o' -> r) -> r

-- | Safely rename (if necessary) a given pattern to extend a given scope.
--   This is similar to <a>withFreshPattern</a>, except if a name in the
--   pattern does not clash with the scope, it can be used immediately,
--   without renaming.
--   
--   This is a more general version of <a>withRefreshed</a>.
withRefreshedPattern :: forall (o :: S) pattern (e :: S -> Type) (n :: S) (l :: S) r. (Distinct o, CoSinkable pattern, Sinkable e, InjectName e) => Scope o -> pattern n l -> (forall (o' :: S). DExt o o' => (Substitution e n o -> Substitution e l o') -> pattern o o' -> r) -> r

-- | Refresh (if needed) bound variables introduced in a pattern.
--   
--   This is a version of <a>withRefreshedPattern</a> that uses functional
--   renamings instead of <a>Substitution</a>.
withRefreshedPattern' :: forall pattern (o :: S) e (n :: S) (l :: S) r. (CoSinkable pattern, Distinct o, InjectName e, Sinkable e) => Scope o -> pattern n l -> (forall (o' :: S). DExt o o' => ((Name n -> e o) -> Name l -> e o') -> pattern o o' -> r) -> r

-- | Try coercing the name back to the (smaller) scope, given a binder that
--   extends that scope.
unsinkName :: forall (n :: S) (l :: S). NameBinder n l -> Name l -> Maybe (Name n)

-- | Check if a name in the extended context is introduced in a pattern or
--   comes from the outer scope <tt>n</tt>.
--   
--   This is a generalization of <a>unsinkName</a>.
unsinkNamePattern :: forall pattern (n :: S) (l :: S). (Distinct n, CoSinkable pattern) => pattern n l -> Name l -> Maybe (Name n)
class SinkableK (f :: S -> k)
sinkabilityProofK :: forall (as :: LoT (S -> k)) (bs :: LoT (S -> k)) r. SinkableK f => RenamingsK as bs -> (f :@@: as) -> (forall (cs :: LoT (S -> k)). () => RenamingsK as cs -> (f :@@: cs) -> r) -> r
($dmsinkabilityProofK) :: forall (as :: LoT (S -> k)) (bs :: LoT (S -> k)) r. (SinkableK f, GenericK f, GSinkableK (RepK f)) => RenamingsK as bs -> (f :@@: as) -> (forall (cs :: LoT (S -> k)). () => RenamingsK as cs -> (f :@@: cs) -> r) -> r

-- | Sinking an expression from scope <tt>n</tt> into a (usualy extended)
--   scope <tt>l</tt>, given the renaming (injection from scope <tt>n</tt>
--   to scope <tt>l</tt>).
class Sinkable (e :: S -> Type)

-- | An implementation of this method that typechecks proves to the
--   compiler that the expression is indeed <a>Sinkable</a>. However,
--   instead of this implementation, <a>sink</a> should be used at all call
--   sites for efficiency.
sinkabilityProof :: forall (n :: S) (l :: S). Sinkable e => (Name n -> Name l) -> e n -> e l
($dmsinkabilityProof) :: forall (n :: S) (l :: S). (Sinkable e, GenericK e, GSinkableK (RepK e)) => (Name n -> Name l) -> e n -> e l

-- | <a>CoSinkable</a> is to patterns (generalized binders) what
--   <a>Sinkable</a> is to expressions.
--   
--   See Section 2.3 of <a>«Free Foil: Generating Efficient and Scope-Safe
--   Abstract Syntax»</a> for more details.
class CoSinkable (pattern :: S -> S -> Type)

-- | An implementation of this method that typechecks proves to the
--   compiler that the pattern is indeed <a>CoSinkable</a>. However,
--   instead of this implementation, <a>extendRenaming</a> should be used
--   at all call sites for efficiency.
coSinkabilityProof :: forall (n :: S) (n' :: S) (l :: S) r. CoSinkable pattern => (Name n -> Name n') -> pattern n l -> (forall (l' :: S). () => (Name l -> Name l') -> pattern n' l' -> r) -> r
($dmcoSinkabilityProof) :: forall (n :: S) (n' :: S) (l :: S) r. (CoSinkable pattern, GenericK pattern, GSinkableK (RepK pattern)) => (Name n -> Name n') -> pattern n l -> (forall (l' :: S). () => (Name l -> Name l') -> pattern n' l' -> r) -> r

-- | Generalized processing of a pattern.
--   
--   You can see <a>withPattern</a> as a CPS-style traversal over the
--   binders in a pattern.
withPattern :: forall (o :: S) f (n :: S) (l :: S) r. (CoSinkable pattern, Distinct o) => (forall (x :: S) (y :: S) (z :: S) r'. Distinct z => Scope z -> NameBinder x y -> (forall (z' :: S). DExt z z' => f x y z z' -> NameBinder z z' -> r') -> r') -> (forall (x :: S) (z :: S) (z' :: S). DExt z z' => f x x z z') -> (forall (x :: S) (y :: S) (y' :: S) (z :: S) (z' :: S) (z'' :: S). (DExt z z', DExt z' z'') => f x y z z' -> f y y' z' z'' -> f x y' z z'') -> Scope o -> pattern n l -> (forall (o' :: S). DExt o o' => f n l o o' -> pattern o o' -> r) -> r
($dmwithPattern) :: forall (o :: S) f (n :: S) (l :: S) r. (CoSinkable pattern, Distinct o, GenericK pattern, GValidNameBinders pattern (RepK pattern), GHasNameBinders (RepK pattern)) => (forall (x :: S) (y :: S) (z :: S) r'. Distinct z => Scope z -> NameBinder x y -> (forall (z' :: S). DExt z z' => f x y z z' -> NameBinder z z' -> r') -> r') -> (forall (x :: S) (z :: S) (z' :: S). DExt z z' => f x x z z') -> (forall (x :: S) (y :: S) (y' :: S) (z :: S) (z' :: S) (z'' :: S). (DExt z z', DExt z' z'') => f x y z z' -> f y y' z' z'' -> f x y' z z'') -> Scope o -> pattern n l -> (forall (o' :: S). DExt o o' => f n l o o' -> pattern o o' -> r) -> r

-- | If <tt><a>HasNameBinders</a> f</tt>, then <tt>f n l</tt> is expected
--   to act as a binder, introducing into scope <tt>n</tt> some local
--   variables, extending it to scope <tt>l</tt>. This class allows to
--   extract and modify the set of binders.
class HasNameBinders (f :: S -> S -> Type)

-- | Extract a set of binders from a pattern.
getNameBinders :: forall (n :: S) (l :: S). HasNameBinders f => f n l -> NameBinders n l

-- | Efficient version of <a>sinkabilityProof</a>. In fact, once
--   <a>sinkabilityProof</a> typechecks, it is safe to <a>sink</a> by
--   coercion. See Section 3.5 in <a>«The Foil: Capture-Avoiding
--   Substitution With No Sharp Edges»</a> for the details.
sink :: forall e (n :: S) (l :: S). (Sinkable e, DExt n l) => e n -> e l

-- | Extend renaming when going under a <a>CoSinkable</a> pattern
--   (generalized binder). Note that the scope under pattern is independent
--   of the codomain of the renaming.
--   
--   This function is used to go under binders when implementing
--   <a>sinkabilityProof</a> and is both a generalization of
--   <a>extendRenamingNameBinder</a> and an efficient implementation of
--   <a>coSinkabilityProof</a>.
extendRenaming :: forall pattern (n :: S) (n' :: S) (l :: S) r. CoSinkable pattern => (Name n -> Name n') -> pattern n l -> (forall (l' :: S). () => (Name l -> Name l') -> pattern n' l' -> r) -> r

-- | Extend renaming of binders when going under a <a>CoSinkable</a>
--   pattern (generalized binder). Note that the scope under pattern is
--   independent of the codomain of the renaming.
extendNameBinderRenaming :: forall pattern (i :: S) (n :: S) (n' :: S) (l :: S) r. CoSinkable pattern => (NameBinder i n -> NameBinder i n') -> pattern n l -> (forall (l' :: S). () => (NameBinder n' l -> NameBinder n' l') -> pattern n' l' -> r) -> r

-- | Safely compose renamings of name binders. The underlying
--   implementation is
composeNameBinderRenamings :: forall (n :: S) (i :: S) (i' :: S) (l :: S) (l' :: S). (NameBinder n i -> NameBinder n i') -> (NameBinder i' l -> NameBinder i' l') -> NameBinder n l -> NameBinder n l'

-- | Convert renaming of name binders into renaming of names in the inner
--   scopes.
fromNameBinderRenaming :: forall (n :: S) (l :: S) (l' :: S). (NameBinder n l -> NameBinder n l') -> Name l -> Name l'

-- | Extend renaming when going under a <a>NameBinder</a>. Note that the
--   scope under binder is independent of the codomain of the renaming.
--   
--   Semantically, this function may need to rename the binder (resulting
--   in the new scope <tt>l'</tt>), to make sure it does not clash with
--   scope <tt>n'</tt>. However, as it turns out, the foil makes it safe to
--   implement this function as a coercion. See Appendix A in <a>«The Foil:
--   Capture-Avoiding Substitution With No Sharp Edges»</a> for the
--   details.
--   
--   This function is used to go under binders when implementing
--   <a>sinkabilityProof</a>. A generalization of this function is
--   <a>extendRenaming</a> (which is an efficient version of
--   <a>coSinkabilityProof</a>).
extendRenamingNameBinder :: forall (n :: S) (n' :: S) (l :: S) r. (Name n -> Name n') -> NameBinder n l -> (forall (l' :: S). () => (Name l -> Name l') -> NameBinder n' l' -> r) -> r

-- | A substitution is a mapping from names in scope <tt>i</tt> to
--   expressions <tt>e o</tt> in scope <tt>o</tt>.
data Substitution (e :: S -> Type) (i :: S) (o :: S)

-- | Apply substitution to a given name.
lookupSubst :: forall e (i :: S) (o :: S). InjectName e => Substitution e i o -> Name i -> e o

-- | Identity substitution maps all names to expresion-variables.
identitySubst :: forall (e :: S -> Type) (i :: S). InjectName e => Substitution e i i

-- | An empty substitution from an empty scope.
voidSubst :: forall (e :: S -> Type) (n :: S). Substitution e 'VoidS n

-- | Extend substitution with a particular mapping.
addSubst :: forall e (i :: S) (o :: S) (i' :: S). Substitution e i o -> NameBinder i i' -> e o -> Substitution e i' o
addSubstPattern :: forall binder e (i :: S) (o :: S) (i' :: S). CoSinkable binder => Substitution e i o -> binder i i' -> [e o] -> Substitution e i' o
addSubstList :: forall e (i :: S) (o :: S) (i' :: S). Substitution e i o -> NameBinderList i i' -> [e o] -> Substitution e i' o

-- | Add variable renaming to a substitution. This includes the performance
--   optimization of eliding names mapped to themselves.
addRename :: forall (e :: S -> Type) (i :: S) (o :: S) (i' :: S). InjectName e => Substitution e i o -> NameBinder i i' -> Name o -> Substitution e i' o

-- | Unification result for two binders, extending some common scope to
--   scopes <tt>l</tt> and <tt>r</tt> respectively.
--   
--   Due to the implementation of the foil, we can often rename binders
--   efficiently, by renaming binders only in one of the two unified terms.
data UnifyNameBinders (pattern :: S -> S -> Type) (n :: S) (l :: S) (r :: S)

-- | Binders are the same, proving that type parameters <tt>l</tt> and
--   <tt>r</tt> are in fact equivalent.
[SameNameBinders] :: forall (n :: S) (l :: S) (pattern :: S -> S -> Type). NameBinders n l -> UnifyNameBinders pattern n l l

-- | It is possible to safely rename the left binder to match the right
--   one.
[RenameLeftNameBinder] :: forall (n :: S) (r :: S) (l :: S) (pattern :: S -> S -> Type). NameBinders n r -> (NameBinder n l -> NameBinder n r) -> UnifyNameBinders pattern n l r

-- | It is possible to safely rename the right binder to match the left
--   one.
[RenameRightNameBinder] :: forall (n :: S) (l :: S) (r :: S) (pattern :: S -> S -> Type). NameBinders n l -> (NameBinder n r -> NameBinder n l) -> UnifyNameBinders pattern n l r

-- | It is necessary to rename both binders.
[RenameBothBinders] :: forall (n :: S) (lr :: S) (l :: S) (r :: S) (pattern :: S -> S -> Type). NameBinders n lr -> (NameBinder n l -> NameBinder n lr) -> (NameBinder n r -> NameBinder n lr) -> UnifyNameBinders pattern n l r

-- | Cannot unify to (sub)patterns.
[NotUnifiable] :: forall (pattern :: S -> S -> Type) (n :: S) (l :: S) (r :: S). UnifyNameBinders pattern n l r

-- | Unify binders either by asserting that they are the same, or by
--   providing a <i>safe</i> renaming function to convert one binder to
--   another.
unifyNameBinders :: forall (i :: S) (l :: S) (r :: S) (pattern :: S -> S -> Type). Distinct i => NameBinder i l -> NameBinder i r -> UnifyNameBinders pattern i l r

-- | Chain unification of nested patterns.
andThenUnifyPatterns :: forall pattern (l :: S) (l' :: S) (n :: S) (r :: S) (r' :: S). (UnifiablePattern pattern, Distinct l, Distinct l') => UnifyNameBinders pattern n l l' -> (pattern l r, pattern l' r') -> UnifyNameBinders pattern n r r'

-- | Chain unification of nested patterns with <a>NameBinder</a>s.
andThenUnifyNameBinders :: forall (pattern :: S -> S -> Type) (l :: S) (l' :: S) (n :: S) (r :: S) (r' :: S). (UnifiablePattern pattern, Distinct l, Distinct l') => UnifyNameBinders pattern n l l' -> (NameBinder l r, NameBinder l' r') -> UnifyNameBinders pattern n r r'

-- | A pattern type is unifiable if it is possible to match two patterns
--   and decide how to rename binders.
class CoSinkable pattern => UnifiablePattern (pattern :: S -> S -> Type)

-- | Unify two patterns and decide which binders need to be renamed.
unifyPatterns :: forall (n :: S) (l :: S) (r :: S). (UnifiablePattern pattern, Distinct n) => pattern n l -> pattern n r -> UnifyNameBinders pattern n l r
($dmunifyPatterns) :: forall (n :: S) (l :: S) (r :: S). (UnifiablePattern pattern, CoSinkable pattern, Distinct n) => pattern n l -> pattern n r -> UnifyNameBinders pattern n l r

-- | Unification of values in patterns. By default, <a>Eq</a> instance is
--   used, but it may be useful to ignore some data in pattens (such as
--   location annotations).
class UnifiableInPattern a

-- | Unify non-binding components of a pattern.
unifyInPattern :: UnifiableInPattern a => a -> a -> Bool
($dmunifyInPattern) :: (UnifiableInPattern a, Eq a) => a -> a -> Bool

-- | An <i>unordered</i> collection of <a>NameBinder</a>s, that together
--   extend scope <tt>n</tt> to scope <tt>l</tt>.
--   
--   For an ordered version see <a>NameBinderList</a>.
data NameBinders (n :: S) (l :: S)

-- | An empty set of binders keeps the scope as is.
emptyNameBinders :: forall (n :: S). NameBinders n n

-- | Composition of sets of binders.
mergeNameBinders :: forall (n :: S) (i :: S) (l :: S). NameBinders n i -> NameBinders i l -> NameBinders n l

-- | An empty pattern type specifies zero possibilities for patterns.
--   
--   This type can be used to specify that patterns are not possible.
data V2 (n :: S) (l :: S)

-- | Since <a>V2</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
absurd2 :: forall (n :: S) (l :: S) a. V2 n l -> a

-- | A <i>total</i> map from names in scope <tt>n</tt> to elements of type
--   <tt>a</tt>.
data NameMap (n :: S) a

-- | An empty map belongs in the empty scope.
emptyNameMap :: NameMap 'VoidS a

-- | Looking up a name should always succeed.
--   
--   Note that since <a>Name</a> is <a>Sinkable</a>, you can lookup a name
--   from scope <tt>n</tt> in a <a>NameMap</a> for scope <tt>l</tt>
--   whenever <tt>l</tt> extends <tt>n</tt>.
lookupName :: forall (n :: S) a. Name n -> NameMap n a -> a

-- | Extending a map with a single mapping.
--   
--   Note that the scope parameter of the result differs from the initial
--   map.
addNameBinder :: forall (n :: S) (l :: S) a. NameBinder n l -> a -> NameMap n a -> NameMap l a

-- | Convert a <a>NameMap</a> of expressions into a <a>Substitution</a>.
nameMapToSubstitution :: forall (i :: S) e (o :: S). NameMap i (e o) -> Substitution e i o

-- | Extend a map with multiple mappings (by repeatedly applying
--   <a>addNameBinder</a>).
--   
--   Note that the input list is expected to have <b>at least</b> the same
--   number of elements as there are binders in the input pattern
--   (generalized binder).
addNameBinders :: forall binder (n :: S) (l :: S) a. CoSinkable binder => binder n l -> [a] -> NameMap n a -> NameMap l a

-- | Extend a map with multiple mappings (by repeatedly applying
--   <a>addNameBinder</a>).
--   
--   Note that the input list is expected to have <b>at least</b> the same
--   number of elements as there are binders in the input name binder list.
--   
--   See also <a>addNameBinders</a> for a generalized version.
addNameBinderList :: forall (n :: S) (l :: S) a. NameBinderList n l -> [a] -> NameMap n a -> NameMap l a

-- | An <i>ordered</i> collection (list) of <a>NameBinder</a>s, that
--   together extend scope <tt>n</tt> to scope <tt>l</tt>.
--   
--   For an unordered version see <a>NameBinders</a>.
data NameBinderList (n :: S) (l :: S)

-- | An empty list of binders keeps the scope as is.
[NameBinderListEmpty] :: forall (n :: S). NameBinderList n n

-- | A non-empty list of binders.
[NameBinderListCons] :: forall (n :: S) (i :: S) (l :: S). NameBinder n i -> NameBinderList i l -> NameBinderList n l

-- | Some scopes are extensions of other scopes.
--   
--   <b>Important</b>: this class exists to assist tracking scope
--   extensions for type variables of kind <a>S</a>. Users of the foil are
--   not supposed to implement any instances of <a>Ext</a>.
class ExtEndo n => ExtEndo l => Ext (n :: S) (l :: S)

-- | Evidence that scope <tt>l</tt> extends scope <tt>n</tt>.
data ExtEvidence (n :: S) (l :: S)
[Ext] :: forall (n :: S) (l :: S). Ext n l => ExtEvidence n l

-- | Scopes with distinct names.
--   
--   <b>Important</b>: this class exists to explicitly mark scopes with
--   distinct names. Users of the foil are not supposed to implement any
--   instances of <a>Distinct</a>.
class Distinct (n :: S)

-- | Evidence that scope <tt>n</tt> contains distinct names.
data DistinctEvidence (n :: S)
[Distinct] :: forall (n :: S). Distinct n => DistinctEvidence n

-- | A distinct scope extended with a <a>NameBinder</a> is also distinct.
assertDistinct :: forall (n :: S) pattern (l :: S). (Distinct n, CoSinkable pattern) => pattern n l -> DistinctEvidence l

-- | A distinct scope extended with a <a>NameBinder</a> is also distinct.
assertExt :: forall pattern (n :: S) (l :: S). CoSinkable pattern => pattern n l -> ExtEvidence n l

-- | Scope extensions with distinct names.
type DExt (n :: S) (l :: S) = (Distinct l, Ext n l)

-- | Instances of this typeclass possess the ability to inject names.
--   Usually, this is a variable data constructor.
class InjectName (e :: S -> Type)

-- | Inject names into expressions.
injectName :: forall (n :: S). InjectName e => Name n -> e n

module Control.Monad.Foil.Relative

-- | Relative monads, restricted to types indexed by scopes in kind
--   <a>S</a>.
class RelMonad (f :: S -> Type) (m :: S -> Type)

-- | Relative version of <a>return</a>.
rreturn :: forall (a :: S). RelMonad f m => f a -> m a

-- | Relative version of <a>&gt;&gt;=</a>.
--   
--   Note the two special additions to the usual definition of a relative
--   binding operation:
--   
--   <ol>
--   <li><tt><a>Scope</a> b</tt> is added since is corresponds to the
--   runtime counterpart of the type parameter <tt>b</tt>.</li>
--   <li><tt><a>Distinct</a> b</tt> constraint helps to ensure we only work
--   with scopes that are distinct.</li>
--   </ol>
--   
--   Technically, it is also possible add similar components for <tt>a</tt>
--   parameter. Also, we could probably treat types in <a>S</a> as
--   singletons and extract distinct scopes that way, preserving the more
--   general type signature for <a>rbind</a>.
rbind :: forall (b :: S) (a :: S). (RelMonad f m, Distinct b) => Scope b -> m a -> (f a -> m b) -> m b

-- | Relative version of <tt>liftM</tt> (an <a>fmap</a> restricted to
--   <a>Monad</a>).
liftRM :: forall f m (b :: S) (a :: S). (RelMonad f m, Distinct b) => Scope b -> (f a -> f b) -> m a -> m b


-- | Example implementation of untyped &lt;math&gt;-calculus with the foil.
module Control.Monad.Foil.Example

-- | Untyped &lt;math&gt;-terms in scope <tt>n</tt>.
data Expr (n :: S)

-- | Variables are names in scope <tt>n</tt>: &lt;math&gt;
[VarE] :: forall (n :: S). Name n -> Expr n

-- | Application of one term to another: &lt;math&gt;
[AppE] :: forall (n :: S). Expr n -> Expr n -> Expr n

-- | &lt;math&gt;-abstraction introduces a binder and a term in an extended
--   scope: &lt;math&gt;
[LamE] :: forall (n :: S) (l :: S). NameBinder n l -> Expr l -> Expr n

-- | Substitution for untyped &lt;math&gt;-terms. The foil helps implement
--   this function without forgetting scope extensions and renaming.
substitute :: forall (o :: S) (i :: S). Distinct o => Scope o -> Substitution Expr i o -> Expr i -> Expr o

-- | Compute weak head normal form (WHNF) of a &lt;math&gt;-term.
--   
--   <pre>
--   &gt;&gt;&gt; whnf emptyScope (AppE (churchN 2) (churchN 2))
--   λx1. (λx0. λx1. (x0 (x0 x1)) (λx0. λx1. (x0 (x0 x1)) x1))
--   </pre>
whnf :: forall (n :: S). Distinct n => Scope n -> Expr n -> Expr n

-- | Compute weak head normal form (WHNF) of a <b>closed</b>
--   &lt;math&gt;-term.
--   
--   <pre>
--   &gt;&gt;&gt; whnf' (AppE (churchN 2) (churchN 2))
--   λx1. (λx0. λx1. (x0 (x0 x1)) (λx0. λx1. (x0 (x0 x1)) x1))
--   </pre>
whnf' :: Expr 'VoidS -> Expr 'VoidS

-- | Compute normal form (NF) of a &lt;math&gt;-term.
--   
--   <pre>
--   &gt;&gt;&gt; nf emptyScope (AppE (churchN 2) (churchN 2))
--   λx1. λx2. (x1 (x1 (x1 (x1 x2))))
--   </pre>
nf :: forall (n :: S). Distinct n => Scope n -> Expr n -> Expr n

-- | Compute normal form (NF) of a <b>closed</b> &lt;math&gt;-term.
--   
--   <pre>
--   &gt;&gt;&gt; nf' (AppE (churchN 2) (churchN 2))
--   λx1. λx2. (x1 (x1 (x1 (x1 x2))))
--   </pre>
nf' :: Expr 'VoidS -> Expr 'VoidS

-- | Pretty print a name.
ppName :: forall (n :: S). Name n -> String

-- | Pretty-print a &lt;math&gt;-term.
--   
--   <pre>
--   &gt;&gt;&gt; ppExpr (churchN 3)
--   "\955x0. \955x1. (x0 (x0 (x0 x1)))"
--   </pre>
ppExpr :: forall (n :: S). Expr n -> String

-- | A helper for constructing &lt;math&gt;-abstractions.
lam :: forall (n :: S). Distinct n => Scope n -> (forall (l :: S). DExt n l => Scope l -> NameBinder n l -> Expr l) -> Expr n

-- | Church-encoding of a natural number &lt;math&gt;.
--   
--   <pre>
--   &gt;&gt;&gt; churchN 0
--   λx0. λx1. x1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; churchN 3
--   λx0. λx1. (x0 (x0 (x0 x1)))
--   </pre>
churchN :: Int -> Expr 'VoidS
instance Control.Monad.Foil.Internal.InjectName Control.Monad.Foil.Example.Expr
instance Control.DeepSeq.NFData (Control.Monad.Foil.Example.Expr l)
instance Control.Monad.Foil.Relative.RelMonad Control.Monad.Foil.Internal.Name Control.Monad.Foil.Example.Expr
instance GHC.Show.Show (Control.Monad.Foil.Example.Expr n)
instance Control.Monad.Foil.Internal.Sinkable Control.Monad.Foil.Example.Expr

module Control.Monad.Foil.TH.Util
peelConT :: Type -> Maybe (Name, [Type])
unpeelConT :: Name -> [Type] -> Type
pattern PeelConT :: Name -> [Type] -> Type
tvarName :: TyVarBndr a -> Name
removeName :: VarBangType -> BangType

module Control.Monad.Foil.TH.MkToFoil

-- | Generate conversion functions from raw to scope-safe representation.
mkToFoil :: Name -> Name -> Name -> Name -> Q [Dec]

-- | Generate a function to extend scope with variables from a given
--   pattern.
mkExtendScopeFoilPattern :: Name -> Name -> Q [Dec]

-- | Generate a function to extend scope with variables from a given
--   pattern.
mkWithRefreshedFoilPattern :: Name -> Name -> Q [Dec]

-- | Generate a conversion function from raw terms to scope-safe terms.
mkToFoilTerm :: Name -> Name -> Name -> Name -> Q [Dec]

-- | Generate a conversion function from raw terms to scope-safe terms.
mkToFoilPattern :: Name -> Name -> Q [Dec]

module Control.Monad.Foil.TH.MkInstancesFoil

-- | Generate <a>Sinkable</a> and <a>CoSinkable</a> instances.
mkInstancesFoil :: Name -> Name -> Name -> Name -> Q [Dec]

-- | Generate <a>Sinkable</a> and <a>CoSinkable</a> instances.
deriveCoSinkable :: Name -> Name -> Q [Dec]

-- | Generate <a>Sinkable</a> and <a>CoSinkable</a> instances.
deriveUnifiablePattern :: Name -> Name -> Q [Dec]

module Control.Monad.Foil.TH.MkFromFoil

-- | Generate conversion functions from raw to scope-safe representation.
mkFromFoil :: Name -> Name -> Name -> Name -> Q [Dec]

-- | Generate conversion function from raw to scope-safe pattern.
mkFromFoilPattern :: Name -> Name -> Q [Dec]

module Control.Monad.Foil.TH.MkFoilData

-- | Generate scope-safe variants given names of types for the raw
--   representation.
mkFoilData :: Name -> Name -> Name -> Name -> Q [Dec]

-- | Generate just the scope-safe patterns.
mkFoilPattern :: Name -> Name -> Q [Dec]

module Control.Monad.Foil.TH

module Control.Monad.Free.Foil.TH.Convert

-- | Generate helpers for conversion to scope-safe representation. Includes
--   <a>mkConvertToSig</a>, <a>mkGetPatternBinder</a>, and
--   <a>mkGetScopedTerm</a>.
mkConvertToFreeFoil :: Name -> Name -> Name -> Name -> Q [Dec]

-- | Generate helpers for conversion from scope-safe representation.
--   Includes <a>mkConvertFromSig</a>.
mkConvertFromFreeFoil :: Name -> Name -> Name -> Name -> Q [Dec]

-- | Generate conversion helper that goes unpeels one node from a raw term.
mkConvertToSig :: Name -> Name -> Name -> Name -> Q [Dec]

-- | Generate conversion helper that peels back one node to a raw term.
mkConvertFromSig :: Name -> Name -> Name -> Name -> Q [Dec]

-- | Generate a helper that extracts at most one binder from a pattern.
mkGetPatternBinder :: Name -> Name -> Q [Dec]

-- | Generate a helper that extracts a term from a scoped term.
mkGetScopedTerm :: Name -> Name -> Q [Dec]

module Control.Monad.Free.Foil.TH.Signature

-- | Generate a signature for the free foil (or free scoped monads) based
--   on a naïve recursive abstract syntax representation, with clearly
--   separated types for terms, variable identifiers, scoped terms, and
--   patterns (binders).
mkSignature :: Name -> Name -> Name -> Name -> Q [Dec]

module Data.ZipMatchK.Mappings

-- | Zip to lists of types into a single list of pair types.
type family ZipLoT (as :: LoT k) (bs :: LoT k) :: LoT k

-- | A collection of zipping functions for <a>zipMatchWithK</a>.
data Mappings (as :: LoT k) (bs :: LoT k) (cs :: LoT k)

-- | An empty collection (when there no (more) type parameters).
[M0] :: Mappings 'LoT0 'LoT0 'LoT0

-- | A non-empty collection (when there is at least one type parameter).
[:^:] :: forall {k1} a b c (as1 :: LoT k1) (bs1 :: LoT k1) (cs1 :: LoT k1). (a -> b -> Maybe c) -> Mappings as1 bs1 cs1 -> Mappings (a ':&&: as1) (b ':&&: bs1) (c ':&&: cs1)
infixr 5 :^:
class PairMappings (as :: LoT k) (bs :: LoT k)

-- | A collection of pairing functions <tt>(\x y -&gt; Just (x, y))</tt>
--   for <a>zipMatchK</a>.
pairMappings :: PairMappings as bs => Mappings as bs (ZipLoT as bs)
class ApplyMappings (v :: TyVar d Type)

-- | Apply a collection of zipping functions to collections of values.
applyMappings :: forall (as :: LoT d) (bs :: LoT d) (cs :: LoT d). ApplyMappings v => Mappings as bs cs -> Interpret ('Var v) as -> Interpret ('Var v) bs -> Maybe (Interpret ('Var v) cs)

-- | Pair two values in a context.
pairA :: Applicative f => a -> b -> f (a, b)
instance forall tys (v :: Data.PolyKinded.Atom.TyVar tys (*)) ty. Data.ZipMatchK.Mappings.ApplyMappings v => Data.ZipMatchK.Mappings.ApplyMappings ('Data.PolyKinded.Atom.VS v)
instance Data.ZipMatchK.Mappings.ApplyMappings 'Data.PolyKinded.Atom.VZ
instance forall ks (as :: Data.PolyKinded.LoT ks) (bs :: Data.PolyKinded.LoT ks) a b. Data.ZipMatchK.Mappings.PairMappings as bs => Data.ZipMatchK.Mappings.PairMappings (a 'Data.PolyKinded.:&&: as) (b 'Data.PolyKinded.:&&: bs)
instance Data.ZipMatchK.Mappings.PairMappings 'Data.PolyKinded.LoT0 'Data.PolyKinded.LoT0

module Data.ZipMatchK.Generic

-- | Kind-polymorphic syntactic (first-order) unification of two values.
--   
--   Note: <tt>f</tt> is expected to be a traversable n-functor, but at the
--   moment we lack a <tt>TraversableK</tt> constraint.
class ZipMatchK (f :: k)

-- | Perform one level of equality testing:
--   
--   <ul>
--   <li>when <tt>k = <a>Type</a></tt>, values are compared directly (e.g.
--   via <a>Eq</a>);</li>
--   <li>when <tt>k = <a>Type</a> -&gt; <a>Type</a></tt>, we compare term
--   constructors; if term constructors are unequal, we return
--   <a>Nothing</a>; otherwise, we pair up all components with a given
--   function.</li>
--   </ul>
zipMatchWithK :: forall (as :: LoT k) (bs :: LoT k) (cs :: LoT k). ZipMatchK f => Mappings as bs cs -> (f :@@: as) -> (f :@@: bs) -> Maybe (f :@@: cs)
($dmzipMatchWithK) :: forall (as :: LoT k) (bs :: LoT k) (cs :: LoT k). (ZipMatchK f, GenericK f, GZipMatch (RepK f), ReqsZipMatchWith (RepK f) as bs cs) => Mappings as bs cs -> (f :@@: as) -> (f :@@: bs) -> Maybe (f :@@: cs)

-- | Generic implementation of <a>zipMatchK</a>.
genericZipMatchK :: forall {k} (f :: k) (as :: LoT k) (bs :: LoT k). (GenericK f, GZipMatch (RepK f), ReqsZipMatch (RepK f) as bs, PairMappings as bs) => (f :@@: as) -> (f :@@: bs) -> Maybe (f :@@: ZipLoT as bs)

-- | Generic implementation of <a>zipMatchWithK</a>.
genericZipMatchWithK :: forall {k} (f :: k) (as :: LoT k) (bs :: LoT k) (cs :: LoT k). (GenericK f, GZipMatch (RepK f), ReqsZipMatchWith (RepK f) as bs cs) => Mappings as bs cs -> (f :@@: as) -> (f :@@: bs) -> Maybe (f :@@: cs)
type ReqsZipMatch (f :: LoT k -> Type) (as :: LoT k) (bs :: LoT k) = ReqsZipMatchWith f as bs ZipLoT as bs
class GZipMatch (f :: LoT k -> Type) where {
    type ReqsZipMatchWith (f :: LoT k -> Type) (as :: LoT k) (bs :: LoT k) (cs :: LoT k);
}
gzipMatchWith :: forall (as :: LoT k) (bs :: LoT k) (cs :: LoT k). (GZipMatch f, ReqsZipMatchWith f as bs cs) => Mappings as bs cs -> f as -> f bs -> Maybe (f cs)
class ZipMatchFields (t :: Atom d Type) where {
    type ReqsZipMatchFieldsWith (t :: Atom d Type) (as :: LoT d) (bs :: LoT d) (cs :: LoT d);
}
zipMatchFieldsWith :: forall (as :: LoT d) (bs :: LoT d) (cs :: LoT d). (ZipMatchFields t, ReqsZipMatchFieldsWith t as bs cs) => Mappings as bs cs -> Field t as -> Field t bs -> Maybe (Field t cs)
instance forall k (f :: Data.PolyKinded.LoT k -> *) (g :: Data.PolyKinded.LoT k -> *). (Data.ZipMatchK.Generic.GZipMatch f, Data.ZipMatchK.Generic.GZipMatch g) => Data.ZipMatchK.Generic.GZipMatch (f GHC.Generics.:*: g)
instance forall k (f :: Data.PolyKinded.LoT k -> *) (g :: Data.PolyKinded.LoT k -> *). (Data.ZipMatchK.Generic.GZipMatch f, Data.ZipMatchK.Generic.GZipMatch g) => Data.ZipMatchK.Generic.GZipMatch (f GHC.Generics.:+: g)
instance forall k (f :: Data.PolyKinded.LoT k -> *) (c :: Data.PolyKinded.Atom.Atom k GHC.Types.Constraint). Data.ZipMatchK.Generic.GZipMatch f => Data.ZipMatchK.Generic.GZipMatch (c Generics.Kind.:=>: f)
instance forall k1 k2 (f :: Data.PolyKinded.LoT (k2 -> k1) -> *). (TypeError ...) => Data.ZipMatchK.Generic.GZipMatch (Generics.Kind.Exists k2 f)
instance forall k (t :: Data.PolyKinded.Atom.Atom k (*)). Data.ZipMatchK.Generic.ZipMatchFields t => Data.ZipMatchK.Generic.GZipMatch (Generics.Kind.Field t)
instance forall k (f :: Data.PolyKinded.LoT k -> *) i (c :: GHC.Generics.Meta). Data.ZipMatchK.Generic.GZipMatch f => Data.ZipMatchK.Generic.GZipMatch (GHC.Generics.M1 i c f)
instance Data.ZipMatchK.Generic.GZipMatch GHC.Generics.U1
instance Data.ZipMatchK.Generic.GZipMatch GHC.Generics.V1
instance Generics.Kind.GenericK GHC.Base.NonEmpty
instance Generics.Kind.GenericK (,)
instance Generics.Kind.GenericK ((,) a)
instance forall d (c :: Data.PolyKinded.Atom.Atom d GHC.Types.Constraint) (a :: Data.PolyKinded.Atom.Atom d (*)). (TypeError ...) => Data.ZipMatchK.Generic.ZipMatchFields (c 'Data.PolyKinded.Atom.:=>>: a)
instance forall d (t :: Data.PolyKinded.Atom.Atom d (*)) (k :: * -> *). (Data.ZipMatchK.Generic.ZipMatchFields t, Data.ZipMatchK.Generic.ZipMatchK k) => Data.ZipMatchK.Generic.ZipMatchFields ('Data.PolyKinded.Atom.Kon k 'Data.PolyKinded.Atom.:@: t)
instance forall d (t1 :: Data.PolyKinded.Atom.Atom d (*)) (t2 :: Data.PolyKinded.Atom.Atom d (*)) (k :: * -> * -> *). (Data.ZipMatchK.Generic.ZipMatchFields t1, Data.ZipMatchK.Generic.ZipMatchFields t2, Data.ZipMatchK.Generic.ZipMatchK k) => Data.ZipMatchK.Generic.ZipMatchFields (('Data.PolyKinded.Atom.Kon k 'Data.PolyKinded.Atom.:@: t1) 'Data.PolyKinded.Atom.:@: t2)
instance forall d kk (k :: kk -> *) (t :: Data.PolyKinded.Atom.Atom d kk). (TypeError ...) => Data.ZipMatchK.Generic.ZipMatchFields ('Data.PolyKinded.Atom.Kon k 'Data.PolyKinded.Atom.:@: t)
instance forall d kk1 kk2 (k :: kk1 -> kk2 -> *) (t1 :: Data.PolyKinded.Atom.Atom d kk1) (t2 :: Data.PolyKinded.Atom.Atom d kk2). (TypeError ...) => Data.ZipMatchK.Generic.ZipMatchFields (('Data.PolyKinded.Atom.Kon k 'Data.PolyKinded.Atom.:@: t1) 'Data.PolyKinded.Atom.:@: t2)
instance forall d k1 (f :: Data.PolyKinded.Atom.Atom d (k1 -> *)) (t :: Data.PolyKinded.Atom.Atom d k1). (TypeError ...) => Data.ZipMatchK.Generic.ZipMatchFields (f 'Data.PolyKinded.Atom.:@: t)
instance forall d (a :: Data.PolyKinded.Atom.Atom d (Fcf.Core.Exp (*))). (TypeError ...) => Data.ZipMatchK.Generic.ZipMatchFields ('Data.PolyKinded.Atom.Eval a)
instance forall d1 d (a :: Data.PolyKinded.Atom.Atom (d1 -> d) (*)). (TypeError ...) => Data.ZipMatchK.Generic.ZipMatchFields ('Data.PolyKinded.Atom.ForAll a)
instance Data.ZipMatchK.Generic.ZipMatchK k => Data.ZipMatchK.Generic.ZipMatchFields ('Data.PolyKinded.Atom.Kon k)
instance forall d (v :: Data.PolyKinded.Atom.TyVar d (*)). Data.ZipMatchK.Mappings.ApplyMappings v => Data.ZipMatchK.Generic.ZipMatchFields ('Data.PolyKinded.Atom.Var v)
instance Data.ZipMatchK.Generic.ZipMatchK Data.Either.Either
instance Data.ZipMatchK.Generic.ZipMatchK a => Data.ZipMatchK.Generic.ZipMatchK (Data.Either.Either a)
instance Data.ZipMatchK.Generic.ZipMatchK []
instance Data.ZipMatchK.Generic.ZipMatchK GHC.Maybe.Maybe
instance Data.ZipMatchK.Generic.ZipMatchK GHC.Base.NonEmpty
instance Data.ZipMatchK.Generic.ZipMatchK (,)
instance Data.ZipMatchK.Generic.ZipMatchK a => Data.ZipMatchK.Generic.ZipMatchK ((,) a)


-- | Kind-polymorphic syntactic (first-order) unification.
module Data.ZipMatchK

-- | Kind-polymorphic syntactic (first-order) unification of two values.
--   
--   Note: <tt>f</tt> is expected to be a traversable n-functor, but at the
--   moment we lack a <tt>TraversableK</tt> constraint.
class ZipMatchK (f :: k)

-- | Perform one level of equality testing:
--   
--   <ul>
--   <li>when <tt>k = <a>Type</a></tt>, values are compared directly (e.g.
--   via <a>Eq</a>);</li>
--   <li>when <tt>k = <a>Type</a> -&gt; <a>Type</a></tt>, we compare term
--   constructors; if term constructors are unequal, we return
--   <a>Nothing</a>; otherwise, we pair up all components with a given
--   function.</li>
--   </ul>
zipMatchWithK :: forall (as :: LoT k) (bs :: LoT k) (cs :: LoT k). ZipMatchK f => Mappings as bs cs -> (f :@@: as) -> (f :@@: bs) -> Maybe (f :@@: cs)
($dmzipMatchWithK) :: forall (as :: LoT k) (bs :: LoT k) (cs :: LoT k). (ZipMatchK f, GenericK f, GZipMatch (RepK f), ReqsZipMatchWith (RepK f) as bs cs) => Mappings as bs cs -> (f :@@: as) -> (f :@@: bs) -> Maybe (f :@@: cs)

-- | Perform one level of equality testing for two values and pair up
--   components using <tt>(,)</tt>:
--   
--   <pre>
--   zipMatchK = zipMatchWithK (\x y -&gt; Just (,) :^: M0)
--   </pre>
zipMatchK :: forall {k} (f :: k) (as :: LoT k) (bs :: LoT k). (ZipMatchK f, PairMappings as bs) => (f :@@: as) -> (f :@@: bs) -> Maybe (f :@@: ZipLoT as bs)

-- | Unify values via <a>Eq</a>. Can be used as an implementation of
--   <a>zipMatchWithK</a> when <tt>k = <a>Type</a></tt>.
zipMatchViaEq :: forall {k} a (as :: LoT k) (bs :: LoT k) (cs :: LoT k). Eq a => Mappings as bs cs -> a -> a -> Maybe a

-- | Always successfully unify any two values of type <tt>a</tt> by
--   preferring the left value. Can be used as an implementation of
--   <a>zipMatchWithK</a> when <tt>k = <a>Type</a></tt>.
zipMatchViaChooseLeft :: forall {k} (as :: LoT k) (bs :: LoT k) (cs :: LoT k) a. Mappings as bs cs -> a -> a -> Maybe a

-- | <a>zipMatchWithK</a> specialised to functors.
--   
--   Note: <a>Traversable</a> is a morally correct constraint here.
zipMatchWith1 :: (Traversable f, ZipMatchK f) => (a -> a' -> Maybe a'') -> f a -> f a' -> Maybe (f a'')

-- | <a>zipMatchK</a> specialised to functors.
--   
--   Note: <a>Traversable</a> is a morally correct constraint here.
zipMatch1 :: (Traversable f, ZipMatchK f) => f a -> f a' -> Maybe (f (a, a'))

-- | <a>zipMatchWithK</a> specialised to bifunctors.
--   
--   Note: <a>Bitraversable</a> is a morally correct constraint here.
zipMatchWith2 :: (Bitraversable f, ZipMatchK f) => (a -> a' -> Maybe a'') -> (b -> b' -> Maybe b'') -> f a b -> f a' b' -> Maybe (f a'' b'')

-- | <a>zipMatchK</a> specialised to bifunctors.
--   
--   Note: <a>Bitraversable</a> is a morally correct constraint here.
zipMatch2 :: (Bitraversable f, ZipMatchK f) => f a b -> f a' b' -> Maybe (f (a, a') (b, b'))


-- | This module provides <a>GenericK</a> and <a>ZipMatchK</a> instances
--   for <a>Sum</a> and <a>Product</a>, to enable the use of
--   <a>ZipMatchK</a> with the data types à la carte approach.
module Data.ZipMatchK.Functor
instance forall k (f :: k -> *) (g :: k -> *). Generics.Kind.GenericK (Data.Functor.Product.Product f g)
instance forall k (f :: k -> *) (g :: k -> *). Generics.Kind.GenericK (Data.Functor.Sum.Sum f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g, Data.ZipMatchK.Generic.ZipMatchK f, Data.ZipMatchK.Generic.ZipMatchK g) => Data.ZipMatchK.Generic.ZipMatchK (Data.Functor.Product.Product f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g, Data.ZipMatchK.Generic.ZipMatchK f, Data.ZipMatchK.Generic.ZipMatchK g) => Data.ZipMatchK.Generic.ZipMatchK (Data.Functor.Sum.Sum f g)


-- | This module provides <a>GenericK</a> and <a>ZipMatchK</a> instances
--   for <a>Sum</a> and <a>Product</a>, to enable the use of
--   <a>ZipMatchK</a> with the data types à la carte approach.
module Data.ZipMatchK.Bifunctor
instance forall k k1 (f :: k -> k1 -> *) (g :: k -> k1 -> *). Generics.Kind.GenericK (Data.Bifunctor.Product.Product f g)
instance forall k k1 (f :: k -> k1 -> *) (g :: k -> k1 -> *). Generics.Kind.GenericK (Data.Bifunctor.Sum.Sum f g)
instance (Data.Bitraversable.Bitraversable f, Data.Bitraversable.Bitraversable g, Data.ZipMatchK.Generic.ZipMatchK f, Data.ZipMatchK.Generic.ZipMatchK g) => Data.ZipMatchK.Generic.ZipMatchK (Data.Bifunctor.Product.Product f g)
instance (Data.Bitraversable.Bitraversable f, Data.Bitraversable.Bitraversable g, Data.ZipMatchK.Generic.ZipMatchK f, Data.ZipMatchK.Generic.ZipMatchK g) => Data.ZipMatchK.Generic.ZipMatchK (Data.Bifunctor.Sum.Sum f g)


-- | This module defines a variation of free scoped (relative) monads
--   relying on the foil for the scope-safe efficient handling of the
--   binders.
--   
--   See description of the approach in <a>«Free Foil: Generating Efficient
--   and Scope-Safe Abstract Syntax»</a>.
module Control.Monad.Free.Foil

-- | Scoped term under a (single) name binder.
data ScopedAST (binder :: S -> S -> Type) (sig :: Type -> Type -> Type) (n :: S)
[ScopedAST] :: forall (binder :: S -> S -> Type) (n :: S) (l :: S) (sig :: Type -> Type -> Type). binder n l -> AST binder sig l -> ScopedAST binder sig n

-- | A term, generated by a signature <a>Bifunctor</a> <tt>sig</tt>, with
--   (free) variables in scope <tt>n</tt>.
data AST (binder :: S -> S -> Type) (sig :: Type -> Type -> Type) (n :: S)

-- | A (free) variable in scope <tt>n</tt>.
[Var] :: forall (n :: S) (binder :: S -> S -> Type) (sig :: Type -> Type -> Type). Name n -> AST binder sig n

-- | A non-variable syntactic construction specified by the signature
--   <a>Bifunctor</a> <tt>sig</tt>.
[Node] :: forall (sig :: Type -> Type -> Type) (binder :: S -> S -> Type) (n :: S). sig (ScopedAST binder sig n) (AST binder sig n) -> AST binder sig n

-- | Substitution for free (scoped monads).
substitute :: forall (sig :: Type -> Type -> Type) (o :: S) (binder :: S -> S -> Type) (i :: S). (Bifunctor sig, Distinct o, CoSinkable binder, SinkableK binder) => Scope o -> Substitution (AST binder sig) i o -> AST binder sig i -> AST binder sig o

-- | Substitution for free (scoped monads).
--   
--   This is a version of <a>substitute</a> that forces refreshing of all
--   name binders, resulting in a term with normalized binders:
--   
--   <pre>
--   substituteRefreshed scope subst = refreshAST scope . subtitute scope subst
--   </pre>
--   
--   In general, <a>substitute</a> is more efficient since it does not
--   always refresh binders.
substituteRefreshed :: forall (sig :: Type -> Type -> Type) (o :: S) (binder :: S -> S -> Type) (i :: S). (Bifunctor sig, Distinct o, CoSinkable binder, SinkableK binder) => Scope o -> Substitution (AST binder sig) i o -> AST binder sig i -> AST binder sig o

-- | Substitution for a single generalized pattern.
substitutePattern :: forall (sig :: Type -> Type -> Type) (o :: S) binder' (binder :: S -> S -> Type) (n :: S) (i :: S). (Bifunctor sig, Distinct o, CoSinkable binder', CoSinkable binder, SinkableK binder) => Scope o -> Substitution (AST binder sig) n o -> binder' n i -> [AST binder sig o] -> AST binder sig i -> AST binder sig o

-- | Refresh (force) all binders in a term, minimizing the used indices.
refreshAST :: forall (sig :: Type -> Type -> Type) (n :: S) (binder :: S -> S -> Type). (Bifunctor sig, Distinct n, CoSinkable binder, SinkableK binder) => Scope n -> AST binder sig n -> AST binder sig n

-- | Similar to <a>refreshAST</a>, but for scoped terms.
refreshScopedAST :: forall (sig :: Type -> Type -> Type) (n :: S) (binder :: S -> S -> Type). (Bifunctor sig, Distinct n, CoSinkable binder, SinkableK binder) => Scope n -> ScopedAST binder sig n -> ScopedAST binder sig n

-- | &lt;math&gt;-equivalence check for two terms in one scope via
--   normalization of bound identifiers (via <a>refreshAST</a>).
--   
--   Compared to <a>alphaEquiv</a>, this function may perform some
--   unnecessary changes of bound variables when the binders are the same
--   on both sides.
alphaEquivRefreshed :: forall (sig :: Type -> Type -> Type) (n :: S) (binder :: S -> S -> Type). (Bitraversable sig, ZipMatchK sig, Distinct n, UnifiablePattern binder, SinkableK binder) => Scope n -> AST binder sig n -> AST binder sig n -> Bool

-- | &lt;math&gt;-equivalence check for two terms in one scope via
--   unification of bound variables (via <tt>unifyNameBinders</tt>).
--   
--   Compared to <a>alphaEquivRefreshed</a>, this function might skip
--   unnecessary changes of bound variables when both binders in two
--   matching scoped terms coincide.
alphaEquiv :: forall (sig :: Type -> Type -> Type) (n :: S) (binder :: S -> S -> Type). (Bitraversable sig, ZipMatchK sig, Distinct n, UnifiablePattern binder, SinkableK binder) => Scope n -> AST binder sig n -> AST binder sig n -> Bool

-- | Same as <a>alphaEquiv</a> but for scoped terms.
alphaEquivScoped :: forall (sig :: Type -> Type -> Type) (n :: S) (binder :: S -> S -> Type). (Bitraversable sig, ZipMatchK sig, Distinct n, UnifiablePattern binder, SinkableK binder) => Scope n -> ScopedAST binder sig n -> ScopedAST binder sig n -> Bool

-- | <i>Unsafe</i> equality check for two terms. This check ignores the
--   possibility that two terms might have different scope extensions under
--   binders (which might happen due to substitution under a binder in
--   absence of name conflicts).
unsafeEqAST :: forall (sig :: Type -> Type -> Type) (binder :: S -> S -> Type) (n :: S) (l :: S). (Bitraversable sig, ZipMatchK sig, UnifiablePattern binder, Distinct n, Distinct l) => AST binder sig n -> AST binder sig l -> Bool

-- | A version of <a>unsafeEqAST</a> for scoped terms.
unsafeEqScopedAST :: forall (sig :: Type -> Type -> Type) (binder :: S -> S -> Type) (n :: S) (l :: S). (Bitraversable sig, ZipMatchK sig, UnifiablePattern binder, Distinct n, Distinct l) => ScopedAST binder sig n -> ScopedAST binder sig l -> Bool

-- | Convert a raw term into a scope-safe term.
convertToAST :: forall (n :: S) sig rawIdent binder rawTerm rawPattern rawScopedTerm. (Distinct n, Bifunctor sig, Ord rawIdent, CoSinkable binder) => (rawTerm -> Either rawIdent (sig (rawPattern, rawScopedTerm) rawTerm)) -> (forall (x :: S) z. Distinct x => Scope x -> Map rawIdent (Name x) -> rawPattern -> (forall (y :: S). DExt x y => binder x y -> Map rawIdent (Name y) -> z) -> z) -> (rawScopedTerm -> rawTerm) -> Scope n -> Map rawIdent (Name n) -> rawTerm -> AST binder sig n

-- | Same as <a>convertToAST</a> but for scoped terms.
convertToScopedAST :: forall (n :: S) sig rawIdent binder rawTerm rawPattern rawScopedTerm. (Distinct n, Bifunctor sig, Ord rawIdent, CoSinkable binder) => (rawTerm -> Either rawIdent (sig (rawPattern, rawScopedTerm) rawTerm)) -> (forall (x :: S) z. Distinct x => Scope x -> Map rawIdent (Name x) -> rawPattern -> (forall (y :: S). DExt x y => binder x y -> Map rawIdent (Name y) -> z) -> z) -> (rawScopedTerm -> rawTerm) -> Scope n -> Map rawIdent (Name n) -> (rawPattern, rawScopedTerm) -> ScopedAST binder sig n

-- | Convert a scope-safe term back into a raw term.
convertFromAST :: forall sig rawPattern rawScopedTerm rawTerm rawIdent binder (n :: S). Bifunctor sig => (sig (rawPattern, rawScopedTerm) rawTerm -> rawTerm) -> (rawIdent -> rawTerm) -> (forall (x :: S) (y :: S). () => binder x y -> rawPattern) -> (rawTerm -> rawScopedTerm) -> (Int -> rawIdent) -> AST binder sig n -> rawTerm

-- | Same as <a>convertFromAST</a> but for scoped terms.
convertFromScopedAST :: forall sig rawPattern rawScopedTerm rawTerm rawIdent binder (n :: S). Bifunctor sig => (sig (rawPattern, rawScopedTerm) rawTerm -> rawTerm) -> (rawIdent -> rawTerm) -> (forall (x :: S) (y :: S). () => binder x y -> rawPattern) -> (rawTerm -> rawScopedTerm) -> (Int -> rawIdent) -> ScopedAST binder sig n -> (rawPattern, rawScopedTerm)

-- | Unsink an AST from a larger scope to a smaller scope.
unsinkAST :: forall (l :: S) (binder :: S -> S -> Type) (sig :: Type -> Type -> Type) (n :: S). (Distinct l, CoSinkable binder, Bifoldable sig) => Scope n -> AST binder sig l -> Maybe (AST binder sig n)

-- | Get the free variables of an AST.
freeVarsOf :: forall (n :: S) (binder :: S -> S -> Type) (sig :: Type -> Type -> Type). (Distinct n, CoSinkable binder, Bifoldable sig) => AST binder sig n -> [Name n]

-- | Get the free variables of a scoped AST.
freeVarsOfScopedAST :: forall (n :: S) (binder :: S -> S -> Type) (sig :: Type -> Type -> Type). (Distinct n, CoSinkable binder, Bifoldable sig) => ScopedAST binder sig n -> [Name n]
instance GHC.Generics.Generic (Control.Monad.Free.Foil.AST binder sig n)
instance Generics.Kind.GenericK (Control.Monad.Free.Foil.AST binder sig)
instance Generics.Kind.GenericK (Control.Monad.Free.Foil.ScopedAST binder sig)
instance Control.Monad.Foil.Internal.InjectName (Control.Monad.Free.Foil.AST binder sig)
instance (forall (x :: Control.Monad.Foil.Internal.S) (y :: Control.Monad.Foil.Internal.S). Control.DeepSeq.NFData (binder x y), forall scope term. (Control.DeepSeq.NFData scope, Control.DeepSeq.NFData term) => Control.DeepSeq.NFData (sig scope term)) => Control.DeepSeq.NFData (Control.Monad.Free.Foil.AST binder sig n)
instance (forall (x :: Control.Monad.Foil.Internal.S) (y :: Control.Monad.Foil.Internal.S). Control.DeepSeq.NFData (binder x y), forall (l :: Control.Monad.Foil.Internal.S). Control.DeepSeq.NFData (Control.Monad.Free.Foil.AST binder sig l)) => Control.DeepSeq.NFData (Control.Monad.Free.Foil.ScopedAST binder sig n)
instance (Data.Bifunctor.Bifunctor sig, Control.Monad.Foil.Internal.CoSinkable binder, Control.Monad.Foil.Internal.SinkableK binder) => Control.Monad.Foil.Relative.RelMonad Control.Monad.Foil.Internal.Name (Control.Monad.Free.Foil.AST binder sig)
instance (Data.Bifunctor.Bifunctor sig, Control.Monad.Foil.Internal.CoSinkable binder, Control.Monad.Foil.Internal.SinkableK binder) => Control.Monad.Foil.Internal.SinkableK (Control.Monad.Free.Foil.AST binder sig)
instance (Data.Bifunctor.Bifunctor sig, Control.Monad.Foil.Internal.CoSinkable binder, Control.Monad.Foil.Internal.SinkableK binder) => Control.Monad.Foil.Internal.SinkableK (Control.Monad.Free.Foil.ScopedAST binder sig)
instance (Data.Bifunctor.Bifunctor sig, Control.Monad.Foil.Internal.CoSinkable binder, Control.Monad.Foil.Internal.SinkableK binder) => Control.Monad.Foil.Internal.Sinkable (Control.Monad.Free.Foil.AST binder sig)
instance (Data.Bifunctor.Bifunctor sig, Control.Monad.Foil.Internal.CoSinkable binder, Control.Monad.Foil.Internal.SinkableK binder) => Control.Monad.Foil.Internal.Sinkable (Control.Monad.Free.Foil.ScopedAST binder sig)

module Control.Monad.Free.Foil.TH.PatternSynonyms

-- | Generate helpful pattern synonyms given a signature bifunctor.
mkPatternSynonyms :: Name -> Q [Dec]
mkPatternSynonym :: Type -> Name -> Name -> Con -> Q [(Name, Dec)]

module Control.Monad.Free.Foil.TH


-- | Template Haskell generation for Free Foil (generic scope-safe
--   representation of syntax).
module Control.Monad.Free.Foil.TH.MkFreeFoil

-- | Config for the Template Haskell generation of data types, pattern
--   synonyms, and conversion functions for the Free Foil representation,
--   based on a raw recursive representation.
data FreeFoilConfig
FreeFoilConfig :: [Name] -> [FreeFoilTermConfig] -> (String -> String) -> (String -> String) -> (String -> String) -> (String -> String) -> (String -> String) -> (String -> String) -> FreeFoilConfig

-- | Names of raw types that may include other binders and terms as
--   components. Some examples of syntax that might be suitable here:
--   
--   <ol>
--   <li>a type scheme in HM-style type system (to explicitly disallow
--   nested forall)</li>
--   <li>defining equation of a function (which itself is not a term)</li>
--   <li>data or type synonym declaration (which itself is not a type)</li>
--   <li>unification constraints (quantified or not)</li>
--   </ol>
[rawQuantifiedNames] :: FreeFoilConfig -> [Name]

-- | Configurations for each term (e.g. expressions, types) group.
[freeFoilTermConfigs] :: FreeFoilConfig -> [FreeFoilTermConfig]

-- | Name modifier for the Free Foil conterpart of a raw type name.
--   Normally, this is just <a>id</a>.
[freeFoilNameModifier] :: FreeFoilConfig -> String -> String

-- | Name modifier for the scoped Free Foil conterpart of a raw type name.
--   Normally, this is something like <tt>(<a>Scoped</a> ++)</tt>.
[freeFoilScopeNameModifier] :: FreeFoilConfig -> String -> String

-- | Name modifier for the signature conterpart of a raw type name or raw
--   constructor name. Normally, this is something like <tt>(++
--   <a>Sig</a>)</tt>.
[signatureNameModifier] :: FreeFoilConfig -> String -> String

-- | Name modifier for the Free Foil conterpart (pattern synonym) of a raw
--   constructor name. Normally, this is just <a>id</a>.
[freeFoilConNameModifier] :: FreeFoilConfig -> String -> String

-- | Name of a conversion function (from raw to scope-safe) for a raw type
--   name. Normally, this is something like <tt>("to" ++)</tt>.
[freeFoilConvertToName] :: FreeFoilConfig -> String -> String

-- | Name of a conversion function (from scope-safe to raw) for a raw type
--   name. Normally, this is something like <tt>("from" ++)</tt>.
[freeFoilConvertFromName] :: FreeFoilConfig -> String -> String

-- | Config for a single term group, for the Template Haskell generation of
--   data types, pattern synonyms, and conversion functions for the Free
--   Foil representation, based on a raw recursive representation.
data FreeFoilTermConfig
FreeFoilTermConfig :: Name -> Name -> Name -> Name -> Name -> [Name] -> [Name] -> Name -> Name -> Name -> Name -> FreeFoilTermConfig

-- | The type name for the identifiers. When identifiers occur in a term,
--   they are converted to <a>Name</a> (with an appropriate type-level
--   scope parameter). When identifiers occur in a pattern, they are
--   converted to <a>NameBinder</a> (with appropriate type-level scope
--   parameters).
[rawIdentName] :: FreeFoilTermConfig -> Name

-- | The type name for the term. This will be the main recursive type to be
--   converted into an <a>AST</a>.
[rawTermName] :: FreeFoilTermConfig -> Name

-- | The type name for the binders (patterns). This will be the main binder
--   type to used in <a>AST</a>-representation of the terms.
[rawBindingName] :: FreeFoilTermConfig -> Name

-- | The type name for the scoped term. This will be replaced with either
--   <a>ScopedAST</a> (with outer scope) or <a>AST</a> (with inner scope)
--   depending on its occurrence in a regular (sub)term or some quantified
--   syntax.
[rawScopeName] :: FreeFoilTermConfig -> Name

-- | The constructor name for the variables in a term. This constructor
--   will be replaced with the standard <a>Var</a>. It is expected to have
--   exactly one field of type <a>rawIdentName</a>.
[rawVarConName] :: FreeFoilTermConfig -> Name

-- | Type names for subterm syntax. This will rely on the main term type
--   (<a>rawTermName</a>) for recursive occurrences. Template Haskell will
--   also generate signatures for these.
[rawSubTermNames] :: FreeFoilTermConfig -> [Name]

-- | Type names for scoped subterm syntax. This will rely on the main term
--   type (<a>rawTermName</a>) for recursive occurrences. Template Haskell
--   will also generate signatures for these.
[rawSubScopeNames] :: FreeFoilTermConfig -> [Name]

-- | Name of a function that converts <a>Int</a> to a raw identifier.
--   Normally, this is something like <tt>(i -&gt; VarIdent ("x" ++ show
--   i))</tt>. This is required to generate standard conversions from
--   scope-safe to raw representation.
[intToRawIdentName] :: FreeFoilTermConfig -> Name

-- | Name of a function that converts a raw identifier into a raw term.
--   Normally, this is some kind of <tt>Var</tt> or <tt>TypeVar</tt> data
--   constructor. This is required to generate standard conversions from
--   scope-safe to raw representation.
[rawVarIdentToTermName] :: FreeFoilTermConfig -> Name

-- | Name of a function that converts a raw term into a raw scoped term.
--   Normally, this is some kind of <tt>ScopedTerm</tt> or
--   <tt>ScopedType</tt> data constructor.
[rawTermToScopeName] :: FreeFoilTermConfig -> Name

-- | Name of a function that extracts a raw term from a raw scoped term.
--   Normally, this is something like <tt>((ScopedTerm term) -&gt;
--   term)</tt>.
[rawScopeToTermName] :: FreeFoilTermConfig -> Name

-- | Generate scope-safe types and pattern synonyms for a given raw set of
--   types:
--   
--   <ol>
--   <li>Scope-safe quantified types (e.g. type schemas, defining equations
--   of functions, unification constraints, data/type declarations)</li>
--   <li>Scope-safe terms, scoped terms, subterms, scoped subterms.</li>
--   <li>Scope-safe patterns.</li>
--   <li>Signatures for terms, subterms, and scoped subterms.</li>
--   <li>Pattern synonyms for terms, subterms, and scoped subterms.</li>
--   </ol>
mkFreeFoil :: FreeFoilConfig -> Q [Dec]

-- | Generate conversions to and from scope-safe representation:
--   
--   <ol>
--   <li>Conversions for scope-safe quantified types (e.g. type schemas,
--   defining equations of functions, unification constraints, data/type
--   declarations)</li>
--   <li>Conversions for scope-safe terms, scoped terms, subterms, scoped
--   subterms.</li>
--   <li>CPS-style conversions for scope-safe patterns.</li>
--   <li>Helpers for signatures of terms, subterms, and scoped
--   subterms.</li>
--   </ol>
mkFreeFoilConversions :: FreeFoilConfig -> Q [Dec]


-- | Example implementation of untyped &lt;math&gt;-calculus with the foil.
module Control.Monad.Free.Foil.Example

-- | Untyped &lt;math&gt;-terms in scope <tt>n</tt>.
data ExprF scope term

-- | Application of one term to another: &lt;math&gt;
AppF :: term -> term -> ExprF scope term

-- | &lt;math&gt;-abstraction introduces a binder and a term in an extended
--   scope: &lt;math&gt;
LamF :: scope -> ExprF scope term
pattern AppE :: AST binder ExprF n -> AST binder ExprF n -> AST binder ExprF n
pattern LamE :: () => binder n l -> AST binder ExprF l -> AST binder ExprF n
type Expr = AST NameBinder ExprF

-- | Compute weak head normal form (WHNF) of a &lt;math&gt;-term.
--   
--   <pre>
--   &gt;&gt;&gt; whnf emptyScope (AppE (churchN 2) (churchN 2))
--   λx1. (λx0. λx1. (x0 (x0 x1)) (λx0. λx1. (x0 (x0 x1)) x1))
--   </pre>
whnf :: forall (n :: S). Distinct n => Scope n -> Expr n -> Expr n

-- | Compute weak head normal form (WHNF) of a <b>closed</b>
--   &lt;math&gt;-term.
--   
--   <pre>
--   &gt;&gt;&gt; whnf' (AppE (churchN 2) (churchN 2))
--   λx1. (λx0. λx1. (x0 (x0 x1)) (λx0. λx1. (x0 (x0 x1)) x1))
--   </pre>
whnf' :: Expr 'VoidS -> Expr 'VoidS

-- | Compute normal form (NF) of a &lt;math&gt;-term.
--   
--   <pre>
--   &gt;&gt;&gt; nf emptyScope (AppE (churchN 2) (churchN 2))
--   λx1. λx2. (x1 (x1 (x1 (x1 x2))))
--   </pre>
nf :: forall (n :: S). Distinct n => Scope n -> Expr n -> Expr n

-- | Compute normal form (NF) of a <b>closed</b> &lt;math&gt;-term.
--   
--   <pre>
--   &gt;&gt;&gt; nf' (AppE (churchN 2) (churchN 2))
--   λx1. λx2. (x1 (x1 (x1 (x1 x2))))
--   </pre>
nf' :: Expr 'VoidS -> Expr 'VoidS

-- | Pretty print a name.
ppName :: forall (n :: S). Name n -> String

-- | Pretty-print a &lt;math&gt;-term.
--   
--   <pre>
--   &gt;&gt;&gt; ppExpr (churchN 3)
--   "\955x0. \955x1. (x0 (x0 (x0 x1)))"
--   </pre>
ppExpr :: forall (n :: S). Expr n -> String

-- | A helper for constructing &lt;math&gt;-abstractions.
lam :: forall (n :: S). Distinct n => Scope n -> (forall (l :: S). DExt n l => Scope l -> NameBinder n l -> Expr l) -> Expr n

-- | Church-encoding of a natural number &lt;math&gt;.
--   
--   <pre>
--   &gt;&gt;&gt; churchN 0
--   λx0. λx1. x1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; churchN 3
--   λx0. λx1. (x0 (x0 (x0 x1)))
--   </pre>
churchN :: Int -> Expr 'VoidS
instance Data.Bifunctor.Bifunctor Control.Monad.Free.Foil.Example.ExprF
instance GHC.Base.Functor (Control.Monad.Free.Foil.Example.ExprF scope)
instance GHC.Show.Show (Control.Monad.Free.Foil.Example.Expr n)
