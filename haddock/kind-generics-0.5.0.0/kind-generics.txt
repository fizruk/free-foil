-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic programming in GHC style for arbitrary kinds and GADTs.
--   
--   This package provides functionality to extend the data type generic
--   programming functionality in GHC to classes of arbitrary kind, and
--   constructors featuring constraints and existentials, as usually found
--   in GADTs.
@package kind-generics
@version 0.5.0.0


-- | Main module of <tt>kind-generics</tt>. Please refer to the
--   <tt>README</tt> file for documentation on how to use this package.
module Generics.Kind

-- | Sums: encode choice between constructors
data ( (f :: k -> Type) :+: (g :: k -> Type) ) (p :: k)
L1 :: f p -> (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k)
R1 :: g p -> (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k)
infixr 5 :+:

-- | Products: encode multiple arguments to constructors
data ( (f :: k -> Type) :*: (g :: k -> Type) ) (p :: k)
(:*:) :: f p -> g p -> (:*:) (f :: k -> Type) (g :: k -> Type) (p :: k)
infixr 6 :*:
infixr 6 :*:

-- | Void: used for datatypes without constructors
data V1 (p :: k)

-- | Unit: used for constructors without arguments
data U1 (p :: k)
U1 :: U1 (p :: k)

-- | Meta-information (constructor names, etc.)
newtype M1 i (c :: Meta) (f :: k -> Type) (p :: k)
M1 :: f p -> M1 i (c :: Meta) (f :: k -> Type) (p :: k)
[unM1] :: M1 i (c :: Meta) (f :: k -> Type) (p :: k) -> f p

-- | Fields: used to represent each of the (visible) arguments to a
--   constructor. Replaces the <a>K1</a> type from <a>Generics</a>. The
--   type of the field is represented by an <a>Atom</a> from <a>Atom</a>.
--   
--   <pre>
--   instance GenericK [] (a :&amp;&amp;: LoT0) where
--     type RepK [] = Field Var0 :*: Field ([] :$: Var0)
--   </pre>
newtype Field (t :: Atom d Type) (x :: LoT d)
[Field] :: forall {d} (t :: Atom d Type) (x :: LoT d). Interpret t x -> Field t x

-- | Constraints: used to represent constraints in a constructor. Replaces
--   the <a>(:=&gt;:)</a> type from <a>GHC.Generics.Extra</a>.
--   
--   <pre>
--   data Showable a = Show a =&gt; a -&gt; X a
--   
--   instance GenericK Showable (a :&amp;&amp;: LoT0) where
--     type RepK Showable = (Show :$: a) :=&gt;: (Field Var0)
--   </pre>
data ( (c :: Atom d Constraint) :=>: (f :: LoT d -> Type) ) (x :: LoT d)
[SuchThat] :: forall {d} (c :: Atom d Constraint) (x :: LoT d) (f :: LoT d -> Type). Interpret c x => f x -> (c :=>: f) x

-- | Existentials: a representation of the form <tt>E f</tt> describes a
--   constructor whose inner type is represented by <tt>f</tt>, and where
--   the type variable at index 0, <a>Var0</a>, is existentially
--   quantified.
--   
--   <pre>
--   data E where
--    E :: t -&gt; Exists
--   
--   instance GenericK E LoT0 where
--     type RepK E = Exists Type (Field Var0)
--   </pre>
data Exists k (f :: LoT k -> d -> Type) (x :: LoT d)
[Exists] :: forall k (t :: k) d (f :: LoT (k -> d) -> Type) (x :: LoT d). f (t ':&&: x) -> Exists k f x

-- | Shape of a type, possibly with type variables.
--   
--   <pre>
--   &gt;&gt;&gt; :kind Kon [] :@: Var0 -- the type [a] for unknown a
--   Kon [] :@: Var0 :: Atom (* -&gt; xs) *
--   </pre>
--   
--   <h3><b>Representation of type families</b></h3>
--   
--   Type families are represented using <a>first-class-families</a>.
--   
--   For example, the type-level <tt>n + m :: <a>Nat</a></tt>-- may expand
--   to the following--
--   
--   <pre>
--   n + m         -- using <tt>(<a>+</a>)</tt> from <a>GHC.TypeNats</a>
--   ~
--   <a>Eval</a> (n <a>+</a> m)  -- using <a>Eval</a> from <a>Fcf.Core</a> and <tt>(<a>+</a>)</tt> from <a>Fcf.Data.Nat</a>
--   </pre>
--   
--   which may be encoded as the following <a>Atom</a> (using <a>Var0</a>
--   for <tt>n</tt> and <a>Var1</a> for <tt>m</tt>):
--   
--   <pre>
--   <a>Eval</a> ((<a>Kon</a> (<a>+</a>) <a>:@:</a> <a>Var0</a>) <a>:@:</a> <a>Var1</a>)  -- <a>Eval</a> as <a>Atom</a>'s constructor
--     :: <a>Atom</a> (Nat -&gt; Nat -&gt; Type) Nat
--   </pre>
--   
--   <a>kind-generics</a> uses a different, more systematic encoding of
--   type families for <tt>GenericK</tt> instances; see <a>fcf-family</a>
--   for more details. For example, <tt>n + m</tt> is instead expanded to
--   the following:
--   
--   <pre>
--   n + m
--   ~
--   <a>Eval</a> (<a>NDFamily</a> (<a>MkName</a> "base" "GHC.TypeNats" "+") <a>P0</a> '(n, '(m, '())))
--   </pre>
--   
--   which gets encoded as the following <a>Atom</a>:
--   
--   <pre>
--   <a>Eval</a> (<a>Kon</a> (<a>NDFamily</a> (<a>MkName</a> "base" "GHC.TypeNats" "+") <a>P0</a>)
--           <a>:@:</a> ((<a>Kon</a> '(,) <a>:@:</a> <a>Var0</a>) <a>:@:</a> ((<a>Kon</a> '(,) <a>:@:</a> <a>Var1</a>) <a>:@:</a> <a>Kon</a> '())))
--     :: <a>Atom</a> (Nat -&gt; Nat -&gt; Type) Nat
--   </pre>
data Atom d (k :: TYPE r)

-- | Represents a type variable.
[Var] :: forall d k1. TyVar d k1 -> Atom d k1

-- | Represents a constant type, like <a>Int</a>.
[Kon] :: forall k1 d. k1 -> Atom d k1

-- | Represents type application.
[:@:] :: forall d k1 k2. Atom d (k1 -> k2) -> Atom d k1 -> Atom d k2

-- | Represents the conjunction of two constraints.
[:&:] :: forall d. Atom d Constraint -> Atom d Constraint -> Atom d Constraint

-- | Represents universal quantification.
[ForAll] :: forall d1 d. Atom (d1 -> d) Type -> Atom d Type

-- | Represents constraint requirement, the "thick arrow" <tt>=&gt;</tt>.
[:=>>:] :: forall d. Atom d Constraint -> Atom d Type -> Atom d Type

-- | Represents a type family application.
[Eval] :: forall d k1. Atom d (Exp k1) -> Atom d k1
infixr 5 :&:
infixr 5 :=>>:

-- | Well-scoped de Bruijn representation of type variables. <tt>TyVar
--   d</tt> represents all the possible type variables which can refer to
--   the holes in kind <tt>d</tt>.
--   
--   We recommend using the aliases <a>Var0</a>, <a>Var1</a>, ... instead
--   of the constructors, for further clarity.
data TyVar d (k :: TYPE r)

-- | First hole in <tt>d</tt>.
[VZ] :: forall x xs. TyVar (x -> xs) x

-- | Successor hole, increases the hole reference by 1.
[VS] :: forall xs k1 x. TyVar xs k1 -> TyVar (x -> xs) k1

-- | Represents an applied constructor. Instead of <tt>Kon [] :</tt>: Var0$
--   you can write @[] :$: Var0$.
type (f :: k1 -> k2) :$: (x :: Atom d k1) = 'Kon f :: Atom d k1 -> k2 ':@: x

-- | Represents (homogeneous) type equality.
type (a :: Atom d k1) :~: (b :: Atom d k1) = 'Kon (~) :: k1 -> k1 -> Constraint :: Atom d k1 -> k1 -> Constraint ':@: a ':@: b

-- | Represents heterogeneous type equality.
type (a :: Atom d k1) :~~: (b :: Atom d k2) = 'Kon (~~) :: k1 -> k2 -> Constraint :: Atom d k1 -> k2 -> Constraint ':@: a ':@: b
type Var0 = 'Var 'VZ :: TyVar k -> xs k
type Var1 = 'Var 'VS 'VZ :: TyVar k -> xs k :: TyVar x -> k -> xs k
type Var2 = 'Var 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x1 -> k -> xs k :: TyVar x -> x1 -> k -> xs k
type Var3 = 'Var 'VS 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x2 -> k -> xs k :: TyVar x1 -> x2 -> k -> xs k :: TyVar x -> x1 -> x2 -> k -> xs k
type Var4 = 'Var 'VS 'VS 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x3 -> k -> xs k :: TyVar x2 -> x3 -> k -> xs k :: TyVar x1 -> x2 -> x3 -> k -> xs k :: TyVar x -> x1 -> x2 -> x3 -> k -> xs k
type Var5 = 'Var 'VS 'VS 'VS 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x4 -> k -> xs k :: TyVar x3 -> x4 -> k -> xs k :: TyVar x2 -> x3 -> x4 -> k -> xs k :: TyVar x1 -> x2 -> x3 -> x4 -> k -> xs k :: TyVar x -> x1 -> x2 -> x3 -> x4 -> k -> xs k
type Var6 = 'Var 'VS 'VS 'VS 'VS 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x5 -> k -> xs k :: TyVar x4 -> x5 -> k -> xs k :: TyVar x3 -> x4 -> x5 -> k -> xs k :: TyVar x2 -> x3 -> x4 -> x5 -> k -> xs k :: TyVar x1 -> x2 -> x3 -> x4 -> x5 -> k -> xs k :: TyVar x -> x1 -> x2 -> x3 -> x4 -> x5 -> k -> xs k
type Var7 = 'Var 'VS 'VS 'VS 'VS 'VS 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x6 -> k -> xs k :: TyVar x5 -> x6 -> k -> xs k :: TyVar x4 -> x5 -> x6 -> k -> xs k :: TyVar x3 -> x4 -> x5 -> x6 -> k -> xs k :: TyVar x2 -> x3 -> x4 -> x5 -> x6 -> k -> xs k :: TyVar x1 -> x2 -> x3 -> x4 -> x5 -> x6 -> k -> xs k :: TyVar x -> x1 -> x2 -> x3 -> x4 -> x5 -> x6 -> k -> xs k
type Var8 = 'Var 'VS 'VS 'VS 'VS 'VS 'VS 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x7 -> k -> xs k :: TyVar x6 -> x7 -> k -> xs k :: TyVar x5 -> x6 -> x7 -> k -> xs k :: TyVar x4 -> x5 -> x6 -> x7 -> k -> xs k :: TyVar x3 -> x4 -> x5 -> x6 -> x7 -> k -> xs k :: TyVar x2 -> x3 -> x4 -> x5 -> x6 -> x7 -> k -> xs k :: TyVar x1 -> x2 -> x3 -> x4 -> x5 -> x6 -> x7 -> k -> xs k :: TyVar x -> x1 -> x2 -> x3 -> x4 -> x5 -> x6 -> x7 -> k -> xs k
type Var9 = 'Var 'VS 'VS 'VS 'VS 'VS 'VS 'VS 'VS 'VS 'VZ :: TyVar k -> xs k :: TyVar x8 -> k -> xs k :: TyVar x7 -> x8 -> k -> xs k :: TyVar x6 -> x7 -> x8 -> k -> xs k :: TyVar x5 -> x6 -> x7 -> x8 -> k -> xs k :: TyVar x4 -> x5 -> x6 -> x7 -> x8 -> k -> xs k :: TyVar x3 -> x4 -> x5 -> x6 -> x7 -> x8 -> k -> xs k :: TyVar x2 -> x3 -> x4 -> x5 -> x6 -> x7 -> x8 -> k -> xs k :: TyVar x1 -> x2 -> x3 -> x4 -> x5 -> x6 -> x7 -> x8 -> k -> xs k :: TyVar x -> x1 -> x2 -> x3 -> x4 -> x5 -> x6 -> x7 -> x8 -> k -> xs k

-- | <tt>LoT k</tt> represents a list of types which can be applied to a
--   data type of kind <tt>k</tt>.
data LoT k

-- | Empty list of types.
[LoT0] :: LoT Type

-- | Cons a type with a list of types.
[:&&:] :: forall k1 ks. k1 -> LoT ks -> LoT (k1 -> ks)
infixr 5 :&&:

-- | Apply a list of types to a type constructor.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Either :@@: (Int :&amp;&amp;: Bool :&amp;&amp;: LoT0)
--   Either Int Bool :: Type
--   </pre>
type family (f :: k) :@@: (tys :: LoT k)

-- | List of types with a single element.
type LoT1 (a :: k) = a ':&&: 'LoT0

-- | List of types with two elements.
type LoT2 (a :: k) (b :: k1) = a ':&&: b ':&&: 'LoT0

-- | A type constructor and a list of types that can be applied to it.
data TyEnv
[TyEnv] :: forall k. k -> LoT k -> TyEnv

-- | Representable types of any kind. Examples:
--   
--   <pre>
--   instance GenericK Int
--   instance GenericK []
--   instance GenericK Either
--   instance GenericK (Either a)
--   instance GenericK (Either a b)
--   </pre>
class GenericK (f :: k) where {
    type RepK (f :: k) :: LoT k -> Type;
}

-- | Convert the data type to its representation.
fromK :: forall (x :: LoT k). GenericK f => (f :@@: x) -> RepK f x
($dmfromK) :: forall (x :: LoT k). (GenericK f, Generic (f :@@: x), Conv (Rep (f :@@: x)) (RepK f) x) => (f :@@: x) -> RepK f x

-- | Convert from a representation to its corresponding data type.
toK :: forall (x :: LoT k). GenericK f => RepK f x -> f :@@: x
($dmtoK) :: forall (x :: LoT k). (GenericK f, Generic (f :@@: x), Conv (Rep (f :@@: x)) (RepK f) x) => RepK f x -> f :@@: x
type GenericF t (f :: k) (x :: LoT k) = (GenericK f, x ~ SplitF t f, t ~ f :@@: x)
fromF :: forall {k} (f :: k) t (x :: LoT k). GenericF t f x => t -> RepK f x
toF :: forall {k} (f :: k) t (x :: LoT k). GenericF t f x => RepK f x -> t
type GenericN (n :: Nat) t (f :: k) (x :: LoT k) = (GenericK f, 'TyEnv f x ~ SplitN n t, t ~ f :@@: x)
fromN :: forall {k} (n :: Nat) t (f :: k) (x :: LoT k). GenericN n t f x => t -> RepK f x
toN :: forall {k} (n :: Nat) t (f :: k) (x :: LoT k). GenericN n t f x => RepK f x -> t
fromRepK :: forall {t} {k} (f :: t -> k) (x :: t) (xs :: LoT k). (GenericK f, SubstRep' (RepK f) x xs) => (f x :@@: xs) -> SubstRep (RepK f) x xs
toRepK :: forall {t} {k} (f :: t -> k) (x :: t) (xs :: LoT k). (GenericK f, SubstRep' (RepK f) x xs) => SubstRep (RepK f) x xs -> f x :@@: xs
type family SubstRep (f :: LoT t -> k -> Type) (x :: t) :: LoT k -> Type
class SubstRep' (f :: LoT t -> k -> Type) (x :: t) (xs :: LoT k)
type family SubstAtom (f :: Atom t -> k d) (x :: t) :: Atom k d

-- | Bridges a representation of a data type using the combinators in
--   <a>GHC.Generics</a> with a representation using this module. You are
--   never expected to manipulate this type class directly, it is part of
--   the deriving mechanism for <a>GenericK</a>.
class Conv (gg :: Type -> Type) (kg :: LoT d -> Type) (tys :: LoT d)
toGhcGenerics :: Conv gg kg tys => kg tys -> gg a
toKindGenerics :: Conv gg kg tys => gg a -> kg tys

-- | Replaces the holes in the <a>Atom</a> <tt>t</tt> by the elements of
--   the list of types <tt>tys</tt>. The amount and kind of types in
--   <tt>tys</tt> must match statically those required by the <a>Atom</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Interpret ([] :$: Var0) (LoT1 Int)
--   Interpret ([] :$: Var0) (LoT1 Int) :: *
--   = [Int]
--   </pre>
type family Interpret (t :: Atom d k) (tys :: LoT d) :: k

-- | Obtains the type in the list <tt>tys</tt> referenced by the type
--   variable <tt>t</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Interpret Var0 (LoT2 Int Bool)
--   Interpret Var0 (LoT2 Int Bool) :: *
--   = Int
--   
--   &gt;&gt;&gt; :kind! Interpret Var1 (LoT2 Int Bool)
--   Interpret Var1 (LoT2 Int Bool) :: *
--   = Bool
--   </pre>
type family InterpretVar (t :: TyVar d k) (tys :: LoT d) :: k

-- | Interprets a list of <a>Atom</a> representing constraints into the
--   actual constraints. This is a specialization of <a>Interpret</a> for
--   the case of constraints.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Satisfies '[Eq :$: Var0, Show :$: Var0] (LoT1 Int)
--   Satisfies '[Eq :$: Var0, Show :$: Var0] (LoT1 Int) :: Constraint
--   = (Eq Int, (Show Int, () :: Constraint))
--   </pre>
type family Satisfies (cs :: [Atom d Constraint]) (tys :: LoT d)

-- | Determines whether a given type variable <tt>v</tt> is used within an
--   <a>Atom</a> <tt>t</tt>. If not, we know that the atom is constant with
--   respect to that variable.
type family ContainsTyVar (v :: TyVar d k) (t :: Atom d p) :: Bool

-- | Auxiliary type for interpretation of the <a>ForAll</a> atom. Required
--   because a type family like <a>Interpret</a> cannot return a
--   polymorphic type.
newtype ForAllI (f :: Atom d1 -> d Type) (tys :: LoT d)
[ForAllI] :: forall {d1} {d} (f :: Atom (d1 -> d) Type) (tys :: LoT d). (forall (t :: d1). () => Interpret f (t ':&&: tys)) -> ForAllI f tys

-- | Auxiliary type for interpretation of the <a>(:=&gt;&gt;:)</a> atom.
--   Required because a type family like <a>Interpret</a> cannot return a
--   type with constraints.
newtype SuchThatI (c :: Atom d Constraint) (f :: Atom d Type) (tys :: LoT d)
[SuchThatI] :: forall {d} (c :: Atom d Constraint) (tys :: LoT d) (f :: Atom d Type). (Interpret c tys => Interpret f tys) -> SuchThatI c f tys

-- | Records a value of type <tt>f</tt> applied to the list <tt>tys</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; :t WrapI [1] :: WrappedI ([] :$: Var0) (LoT1 Int)
--   WrapI [1] :: WrappedI ([] :$: Var0) (LoT1 Int)
--   </pre>
newtype WrappedI (f :: Atom d Type) (tys :: LoT d)
WrapI :: Interpret f tys -> WrappedI (f :: Atom d Type) (tys :: LoT d)
[unwrapI] :: WrappedI (f :: Atom d Type) (tys :: LoT d) -> Interpret f tys
toWrappedI :: forall {d1} {ks} (f :: Atom (d1 -> ks) Type) (tys :: LoT ks) (t :: d1). ForAllI f tys -> WrappedI f (t ':&&: tys)
fromWrappedI :: forall {d1} {d} (f :: Atom (d1 -> d) Type) (tys :: LoT d). (forall (t :: d1). () => WrappedI f (t ':&&: tys)) -> ForAllI f tys
instance forall d (f :: * -> *) (f' :: Data.PolyKinded.LoT d -> *) (tys :: Data.PolyKinded.LoT d) (g :: * -> *) (g' :: Data.PolyKinded.LoT d -> *). (Generics.Kind.Conv f f' tys, Generics.Kind.Conv g g' tys) => Generics.Kind.Conv (f GHC.Generics.:*: g) (f' GHC.Generics.:*: g') tys
instance forall d (f :: * -> *) (f' :: Data.PolyKinded.LoT d -> *) (tys :: Data.PolyKinded.LoT d) (g :: * -> *) (g' :: Data.PolyKinded.LoT d -> *). (Generics.Kind.Conv f f' tys, Generics.Kind.Conv g g' tys) => Generics.Kind.Conv (f GHC.Generics.:+: g) (f' GHC.Generics.:+: g') tys
instance forall d (k :: GHC.Types.Constraint) (t :: Data.PolyKinded.Atom.Atom d GHC.Types.Constraint) (tys :: Data.PolyKinded.LoT d) (f :: * -> *) (f' :: Data.PolyKinded.LoT d -> *). (k GHC.Types.~ Data.PolyKinded.Atom.Interpret t tys, Generics.Kind.Conv f f' tys) => Generics.Kind.Conv (k GHC.Generics.Extra.:=>: f) (t Generics.Kind.:=>: f') tys
instance forall d k (t :: Data.PolyKinded.Atom.Atom d (*)) (tys :: Data.PolyKinded.LoT d) p. (k GHC.Types.~ Data.PolyKinded.Atom.Interpret t tys) => Generics.Kind.Conv (GHC.Generics.K1 p k) (Generics.Kind.Field t) tys
instance forall d (f :: * -> *) (f' :: Data.PolyKinded.LoT d -> *) (tys :: Data.PolyKinded.LoT d) i (c :: GHC.Generics.Meta). Generics.Kind.Conv f f' tys => Generics.Kind.Conv (GHC.Generics.M1 i c f) (GHC.Generics.M1 i c f') tys
instance forall d (f :: * -> *) (f' :: Data.PolyKinded.LoT d -> *) (tys :: Data.PolyKinded.LoT d) i (c :: GHC.Generics.Meta). Generics.Kind.Conv f f' tys => Generics.Kind.Conv (GHC.Generics.M1 i c f) f' tys
instance forall d (tys :: Data.PolyKinded.LoT d). Generics.Kind.Conv GHC.Generics.U1 GHC.Generics.U1 tys
instance forall d (c :: Data.PolyKinded.Atom.Atom d GHC.Types.Constraint) (x :: Data.PolyKinded.LoT d) (f :: Data.PolyKinded.LoT d -> *). (Data.PolyKinded.Atom.Interpret c x => GHC.Classes.Eq (f x)) => GHC.Classes.Eq ((Generics.Kind.:=>:) c f x)
instance forall d (t :: Data.PolyKinded.Atom.Atom d (*)) (x :: Data.PolyKinded.LoT d). GHC.Classes.Eq (Data.PolyKinded.Atom.Interpret t x) => GHC.Classes.Eq (Generics.Kind.Field t x)
instance forall k1 ks (c :: Data.PolyKinded.Atom.Atom (k1 -> ks) GHC.Types.Constraint) (x :: k1) (xs :: Data.PolyKinded.LoT ks). Data.PolyKinded.Atom.Interpret c (x 'Data.PolyKinded.:&&: xs) => Generics.Kind.InterpretCons c x xs
instance forall t d (c :: Data.PolyKinded.Atom.Atom (t -> d) GHC.Types.Constraint) (x :: t) (xs :: Data.PolyKinded.LoT d). Data.PolyKinded.Atom.Interpret (Generics.Kind.SubstAtom c x) xs => Generics.Kind.InterpretSubst c x xs
instance forall d (t :: Data.PolyKinded.Atom.Atom d (*)) (x :: Data.PolyKinded.LoT d). GHC.Base.Monoid (Data.PolyKinded.Atom.Interpret t x) => GHC.Base.Monoid (Generics.Kind.Field t x)
instance forall d (c :: Data.PolyKinded.Atom.Atom d GHC.Types.Constraint) (x :: Data.PolyKinded.LoT d) (f :: Data.PolyKinded.LoT d -> *). (Data.PolyKinded.Atom.Interpret c x => GHC.Classes.Ord (f x)) => GHC.Classes.Ord ((Generics.Kind.:=>:) c f x)
instance forall d (t :: Data.PolyKinded.Atom.Atom d (*)) (x :: Data.PolyKinded.LoT d). GHC.Classes.Ord (Data.PolyKinded.Atom.Interpret t x) => GHC.Classes.Ord (Generics.Kind.Field t x)
instance forall d (t :: Data.PolyKinded.Atom.Atom d (*)) (x :: Data.PolyKinded.LoT d). GHC.Base.Semigroup (Data.PolyKinded.Atom.Interpret t x) => GHC.Base.Semigroup (Generics.Kind.Field t x)
instance forall d (c :: Data.PolyKinded.Atom.Atom d GHC.Types.Constraint) (x :: Data.PolyKinded.LoT d) (f :: Data.PolyKinded.LoT d -> *). (Data.PolyKinded.Atom.Interpret c x => GHC.Show.Show (f x)) => GHC.Show.Show ((Generics.Kind.:=>:) c f x)
instance forall d k (f :: Data.PolyKinded.LoT (k -> d) -> *) (x :: Data.PolyKinded.LoT d). (forall (t :: k). GHC.Show.Show (f (t 'Data.PolyKinded.:&&: x))) => GHC.Show.Show (Generics.Kind.Exists k f x)
instance forall d (t :: Data.PolyKinded.Atom.Atom d (*)) (x :: Data.PolyKinded.LoT d). GHC.Show.Show (Data.PolyKinded.Atom.Interpret t x) => GHC.Show.Show (Generics.Kind.Field t x)
instance forall t k (f :: Data.PolyKinded.LoT (t -> k) -> *) (x :: t) (xs :: Data.PolyKinded.LoT k) (g :: Data.PolyKinded.LoT (t -> k) -> *). (Generics.Kind.SubstRep' f x xs, Generics.Kind.SubstRep' g x xs) => Generics.Kind.SubstRep' (f GHC.Generics.:*: g) x xs
instance forall t k (f :: Data.PolyKinded.LoT (t -> k) -> *) (x :: t) (xs :: Data.PolyKinded.LoT k) (g :: Data.PolyKinded.LoT (t -> k) -> *). (Generics.Kind.SubstRep' f x xs, Generics.Kind.SubstRep' g x xs) => Generics.Kind.SubstRep' (f GHC.Generics.:+: g) x xs
instance forall t k (c :: Data.PolyKinded.Atom.Atom (t -> k) GHC.Types.Constraint) (x :: t) (xs :: Data.PolyKinded.LoT k) (f :: Data.PolyKinded.LoT (t -> k) -> *). (Data.PolyKinded.Atom.Interpret (Generics.Kind.SubstAtom c x) xs => Generics.Kind.InterpretCons c x xs, Data.PolyKinded.Atom.Interpret c (x 'Data.PolyKinded.:&&: xs) => Generics.Kind.InterpretSubst c x xs, Generics.Kind.SubstRep' f x xs) => Generics.Kind.SubstRep' (c Generics.Kind.:=>: f) x xs
instance forall t1 k (t2 :: Data.PolyKinded.Atom.Atom (t1 -> k) (*)) (x :: t1) (xs :: Data.PolyKinded.LoT k). (Data.PolyKinded.Atom.Interpret (Generics.Kind.SubstAtom t2 x) xs GHC.Types.~ Data.PolyKinded.Atom.Interpret t2 (x 'Data.PolyKinded.:&&: xs)) => Generics.Kind.SubstRep' (Generics.Kind.Field t2) x xs
instance forall t k (f :: Data.PolyKinded.LoT (t -> k) -> *) (x :: t) (xs :: Data.PolyKinded.LoT k) i (c :: GHC.Generics.Meta). Generics.Kind.SubstRep' f x xs => Generics.Kind.SubstRep' (GHC.Generics.M1 i c f) x xs
instance forall t k (x :: t) (xs :: Data.PolyKinded.LoT k). Generics.Kind.SubstRep' GHC.Generics.U1 x xs

module Generics.Kind.Examples
data Tree a
Branch :: Tree a -> Tree a -> Tree a
Leaf :: a -> Tree a
data family HappyFamily t
data SimpleIndex a b
[MkSimpleIndex] :: forall a1 b. [a1] -> SimpleIndex [a1] b
data WeirdTree a
[WeirdBranch] :: forall a. WeirdTree a -> WeirdTree a -> WeirdTree a
[WeirdLeaf] :: forall a t. Show a => t -> a -> WeirdTree a
data WeirdTreeR a
[WeirdBranchR] :: forall a. WeirdTreeR a -> WeirdTreeR a -> WeirdTreeR a
[WeirdLeafR] :: forall a t. (Show a, Eq t, Typeable t) => t -> a -> WeirdTreeR a
data TTY (m :: k) a
[WriteTTY] :: forall {k} (m :: k). String -> TTY m ()
[ReadTTY] :: forall {k} (m :: k). TTY m [Char]
data T (a :: k)
[MkT] :: forall a1. Maybe a1 -> T a1
data P k (a :: k)
[P] :: forall k (a :: k). P k a
data P' j (a :: k)
[P'] :: forall k (a :: k). P' k a
newtype Ranky
MkRanky :: (forall a. () => a -> a) -> Ranky
newtype Ranky2 b
MkRanky2 :: ((forall a. () => a -> a) -> b) -> Ranky2 b
data Shower a
[MkShower] :: forall a. (Show a => a -> String) -> Shower a
data Unboxed1
MkUnboxed1 :: (# Int, Int #) -> Unboxed1
newtype Hkd (f :: k -> Exp Type) (a :: k)
Hkd :: Eval (f a) -> Hkd (f :: k -> Exp Type) (a :: k)
instance Generics.Kind.GenericK Data.Either.Either
instance Generics.Kind.GenericK (Data.Either.Either a)
instance Generics.Kind.GenericK Generics.Kind.Examples.HappyFamily
instance Generics.Kind.GenericK Generics.Kind.Examples.Hkd
instance forall k (f :: k -> Fcf.Core.Exp (*)). Generics.Kind.GenericK (Generics.Kind.Examples.Hkd f)
instance Generics.Kind.GenericK []
instance Generics.Kind.GenericK GHC.Maybe.Maybe
instance Generics.Kind.GenericK (Generics.Kind.Examples.P k)
instance Generics.Kind.GenericK (Generics.Kind.Examples.P' j)
instance Generics.Kind.GenericK Generics.Kind.Examples.P'
instance Generics.Kind.GenericK Generics.Kind.Examples.Ranky2
instance Generics.Kind.GenericK Generics.Kind.Examples.Shower
instance Generics.Kind.GenericK Generics.Kind.Examples.SimpleIndex
instance Generics.Kind.GenericK (Generics.Kind.Examples.SimpleIndex a)
instance Generics.Kind.GenericK Generics.Kind.Examples.T
instance Generics.Kind.GenericK Generics.Kind.Examples.Tree
instance Generics.Kind.GenericK Generics.Kind.Examples.WeirdTree
instance Generics.Kind.GenericK Generics.Kind.Examples.WeirdTreeR
instance Generics.Kind.GenericK (Data.Either.Either a b)
instance Generics.Kind.GenericK (Generics.Kind.Examples.HappyFamily (GHC.Maybe.Maybe a))
instance Generics.Kind.GenericK (Generics.Kind.Examples.HappyFamily [a])
instance forall k (f :: k -> Fcf.Core.Exp (*)) (a :: k). Generics.Kind.GenericK (Generics.Kind.Examples.Hkd f a)
instance Generics.Kind.GenericK [a]
instance Generics.Kind.GenericK (GHC.Maybe.Maybe a)
instance Generics.Kind.GenericK Generics.Kind.Examples.Ranky
instance Generics.Kind.GenericK (Generics.Kind.Examples.SimpleIndex a b)
instance forall k (m :: k) a. Generics.Kind.GenericK (Generics.Kind.Examples.TTY m a)
instance Generics.Kind.GenericK (Generics.Kind.Examples.Tree a)
instance Generics.Kind.GenericK (Generics.Kind.Examples.WeirdTreeR a)
instance GHC.Generics.Generic (Generics.Kind.Examples.Tree a)
