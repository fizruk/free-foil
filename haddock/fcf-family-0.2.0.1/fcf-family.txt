-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Family of families: featherweight defunctionalization
--   
--   Promote regular type families to first-class, without polluting the
--   type namespace.
--   
--   See README.
@package fcf-family
@version 0.2.0.1


-- | <h1>The family of type families</h1>
--   
--   <i>fcf-family</i> promotes regular type families to first-class
--   families without requiring new symbols that pollute the type namespace
--   nor a centralized organization to decide where the symbol for each
--   family should be defined.
--   
--   All we need is a single symbol <a>Family</a> indexed by a qualified
--   name that uniquely identifies an existing type family: package,
--   module, and base name.
--   
--   Example names:
--   
--   <pre>
--   -- GHC.TypeNats.+
--   <a>MkName</a> "base" "GHC.TypeNats" "+"
--   
--   -- Data.Type.Bool.If
--   <a>MkName</a> "base" "Data.Type.Bool" "If"
--   </pre>
--   
--   <h2>Promoting a type family to first-class</h2>
--   
--   For example, the type family <tt>(<a>+</a>)</tt> is promoted using the
--   following <a>Eval</a> instance for <a>Family</a>:
--   
--   <pre>
--   type (::+) = <a>MkName</a> "base" "GHC.TypeNats" "+" -- <a>Name</a> of (+)
--   type instance <a>Eval</a> (<a>Family_</a> (::+) _ '(x, '(y, '())))) = x <a>+</a> y
--   </pre>
--   
--   The necessary instances can be generated using <a>fcfify</a> from the
--   module <a>Fcf.Family.TH</a>.
--   
--   <pre>
--   <a>fcfify</a> ''+
--   </pre>
--   
--   The name of the family can be quoted using <a>familyName</a>.
--   
--   <pre>
--   type (::+) = $(pure (<a>familyName</a> ''+))
--   </pre>
--   
--   Two modules may invoke <a>fcfify</a> on the same name without
--   conflict. Identical type family instances will be generated, which is
--   allowed.
--   
--   Examples:
--   
--   <pre>
--   2 <a>+</a> 3
--   ~
--   <a>Eval</a> (<a>Family</a> (<a>MkName</a> "base" "GHC.TypeNats" "+") <a>P0</a> '(2, '(3, '())))
--   </pre>
--   
--   <pre>
--   <a>If</a> a b c
--   ~
--   <a>Eval</a> (<a>Family</a> (<a>MkName</a> "base" "Data.Type.Bool" "If") <a>P1</a> '(a, '(b, '(c, ()))))
--   </pre>
--   
--   <h2>Details</h2>
--   
--   The type of <a>Family</a> is an uncurried version of the original type
--   family:
--   
--   <pre>
--   <a>Family</a> (::+) _ :: (Nat, (Nat, ())) -&gt; Exp Nat
--   (<a>+</a>) :: Nat -&gt; Nat -&gt; Nat
--   </pre>
--   
--   Tuples <tt>(,)</tt> and <tt>()</tt> are used as the cons and nil of
--   heterogeneous lists of arguments.
--   
--   The signature of the relevant family is encoded by implementing the
--   following type instances:
--   
--   <pre>
--   -- Auxiliary instances.
--   type instance <a>Params</a> (::+) = ()
--   type instance <a>Args_</a> (::+) _ = (Nat, (Nat, ()))
--   type instance <a>Res_</a> (::+) _ _ = Nat
--   </pre>
--   
--   <a>Args_</a> and <a>Res_</a> denote the types of arguments and result
--   of the given type family. <a>Params</a> denotes the type of implicit
--   parameters (there are none here since <tt>(<a>+</a>)</tt> is
--   monomorphic). The type of explicit arguments (<a>Args_</a>) may depend
--   on the implicit parameters (<a>Params</a>). The result type
--   (<a>Res_</a>) may depend on both <a>Params</a> and <a>Args_</a>.
--   
--   <h3>Untyped inside, typed outside </h3>
--   
--   These families are intended to be very dependent (the type of
--   <a>Family</a> depends on <a>Res</a> depends on <a>Args</a> depends on
--   <a>Params</a>). However, the implementation of this library must work
--   around some technical limitations of GHC. <a>Args_</a> and <a>Res_</a>
--   are actually "untyped" to make GHC more lenient in type checking their
--   instances. "Typed" wrappers, <a>Family</a>, <a>Res</a>, <a>Args</a>
--   are then provided to invoke those families with their intended types,
--   which allows type inference to work.
--   
--   To recap: define instances of <a>Params</a>, <a>Args_</a>,
--   <a>Res_</a>, <a>Family_</a>, but to invoke the latter three, use
--   <a>Args</a>, <a>Res</a>, and <a>Family</a> instead.
--   
--   <h2>Implicit parameters</h2>
--   
--   An example using implicit parameters is <tt><a>If</a> :: forall k.
--   Bool -&gt; k -&gt; k -&gt; k</tt>.
--   
--   <pre>
--   type If_ = <a>MkName</a> "base" "Data.Type.Bool" "If"
--   type instance <a>Eval</a> (<a>Family_</a> If_ _ '(b, '(x, '(y, '())))) = <a>If</a> b x y
--   
--   type instance <a>Params</a> If_ = (<a>Type</a>, ())  -- Type of the implicit parameter
--   type instance <a>Args_</a> If_ k = (Bool, (k, (k, ())      -- Types of the explicit arguments
--   type instance <a>Res_</a> If_ k _ = k                      -- Type of the result
--   </pre>
--   
--   The second argument of <a>Family_</a> is a proxy that carries the
--   implicit parameters in its type. For example, the type of
--   <tt><a>Family</a> If_</tt> is really:
--   
--   <pre>
--   <a>Family</a> If_ (_ :: Proxy k) :: (Bool, (k, (k, ()))) -&gt; k
--   </pre>
--   
--   When using <a>Family</a>, apply it to a proxy encoding the number of
--   implicit parameters in unary using <a>P0</a> and <a>PS</a>.
--   
--   For example, use <a>P0</a> for the monomorphic <tt>(<a>+</a>)</tt> and
--   <a>P1</a> (equal to <tt><a>PS</a> <a>P0</a></tt>) for <a>If</a>.
module Fcf.Family

-- | Kind of type-level expressions indexed by their result type.
type Exp a = a -> Type

-- | Expression evaluator.
type family Eval (e :: Exp a) :: a

-- | Qualified name of a type family or type synonym.
data Name
MkName :: Symbol -> Symbol -> Symbol -> Name

-- | A general defunctionalization symbol for promoted type families. It
--   encodes saturated applications of type families.
--   
--   The second argument (<tt>proxy :: <a>ParamsProxy</a> name ks</tt>) is
--   a gadget carrying implicit parameters (if any). When invoking
--   <a>Family</a>, it must be applied to a <tt>proxy</tt> that corresponds
--   to its number of implicit parameters: <a>P0</a>, <a>P1</a>, <a>P2</a>,
--   ..., <a>P7</a>, or a unary encoding using <a>P0</a> and <a>PS</a> for
--   larger implicit arities. (This really matters for arity 2 and more.)
--   
--   <h3><b>Implementation note</b></h3>
--   
--   This module makes heavy use of dependently typed type families. There
--   is <a>a longstanding issue</a> which severely limits the usability of
--   such families when done naively.
--   
--   The workaround used here is to make the type families themselves
--   "untyped", and wrap them within "typed" synonyms.
--   
--   Making the families untyped makes GHC more lenient so that it accepts
--   them. Making the wrappers typed recovers the type inference behavior
--   of the original family. For instance, when using <a>If</a>, one would
--   expect to unify the types of its two branches. That is the case when
--   constructing its defunctionalization symbol using <a>Family</a> and
--   not with <a>Family_</a>.
type Family (name :: Name) (proxy :: ParamsProxy name ks) (args :: Args name ks) = Family_ name proxy args :: Res_ name ks args -> Type

-- | Untyped internals of <a>Family</a>
data Family_ (a :: Name) (b :: Proxy ks) (c :: args) (d :: res)

-- | Non-dependently typed family.
type NDFamily (name :: Name) (proxy :: ParamsProxy name ks) = NDFamily_ name proxy 'Refl :: Res_ name ks Any :: Args_ name ks :~: Res_ name ks Any :: Args_ name ks

-- | Untyped internals of <a>NDFamily</a>.
data NDFamily_ (name :: Name) (a :: ParamsProxy name ks) (b :: Res name ks Any :: Args_ name ks :~: r) (c :: Args name ks) (d :: r)

-- | Type of implicit parameters of the named family.
type family Params (name :: Name)

-- | Type of explicit parameters of the named family.
type Args (name :: Name) (ks :: Params name) = Args_ name ks

-- | Untyped internals of <a>Args</a>
type family Args_ (name :: Name) (ks :: ksT)

-- | Type of result of the named family.
type Res (name :: Name) (ks :: Params name) (args :: Args name ks) = Res_ name ks args

-- | Untyped internals of <a>Res</a>
type family Res_ (name :: Name) (ks :: ksT) (args :: argsT)

-- | Synonym to make explicit the dependency of the type of the implicit
--   parameters <tt>ks</tt> on the <tt>name</tt> of the family.
type ParamsProxy (name :: Name) (ks :: Params name) = Proxy ks
type P0 = 'Proxy :: Proxy '()
type P1 = PS P0 :: Proxy '(k1, '())
type P2 = PS P1 :: Proxy '(k3, '()) :: Proxy '(k2, '(k3, '()))
type P3 = PS P2 :: Proxy '(k4, '(k5, '())) :: Proxy '(k3, '(k4, '(k5, '())))
type P4 = PS P3 :: Proxy '(k5, '(k6, '(k7, '()))) :: Proxy '(k4, '(k5, '(k6, '(k7, '()))))
type P5 = PS P4 :: Proxy '(k6, '(k7, '(k8, '(k9, '())))) :: Proxy '(k5, '(k6, '(k7, '(k8, '(k9, '())))))
type P6 = PS P5 :: Proxy '(k7, '(k8, '(k9, '(k10, '(k11, '()))))) :: Proxy '(k6, '(k7, '(k8, '(k9, '(k10, '(k11, '()))))))
type P7 = PS P6 :: Proxy '(k8, '(k9, '(k10, '(k11, '(k12, '(k13, '())))))) :: Proxy '(k7, '(k8, '(k9, '(k10, '(k11, '(k12, '(k13, '())))))))
type PS (p :: Proxy ks) = 'Proxy :: Proxy '(k2, ks)

-- | Sometimes GHC doesn't see that two type-level values are equal when
--   they ought to be equal. <a>Coerce</a> lets us postpone the check to
--   another day.
type family Coerce (a :: k) :: l

-- | <a>Coerce</a> with explicit codomain.
type CoerceTo l (a :: k) = Coerce a :: l

-- | <a>Coerce</a> with explicit domain.
type CoerceFrom k1 (a :: k1) = Coerce a :: k

-- | Transport: coercion along an equality.
type family Transp (e :: k :~: l) (x :: k) :: l


-- | Template Haskell script to promote a type family to first class.
module Fcf.Family.TH

-- | Generate the boilerplate needed to promote a type family to first
--   class.
--   
--   Required extensions:
--   
--   <ul>
--   <li><pre>DataKinds</pre></li>
--   <li><pre>PolyKinds</pre></li>
--   <li><pre>TypeFamilies</pre></li>
--   </ul>
--   
--   If <a>fcfify</a> is called more than once with the same <a>Name</a> in
--   the same module, only the first invocation generates declarations;
--   subsequent declarations return the empty list, avoiding duplicate
--   declarations in the current module.
--   
--   For a stateless variant, use <a>fcfify'</a>.
--   
--   See <a>Fcf.Family</a> for details on the encoding.
fcfify :: Name -> Q [Dec]

-- | Mark a type family as already fcifified.
fcfifySkip :: Name -> Q [Dec]

-- | Generate the boilerplate needed to promote a type family to first
--   class.
--   
--   Unlike <a>fcfify</a>, this always returns the same declarations for
--   the same named type.
fcfify' :: Name -> Q [Dec]

-- | Promote a fcfified family, returning its partially applied
--   <a>Family</a> and its arity. The result can be applied to a
--   <a>consTuple</a> of the appropriate size,
promoteFamily :: Name -> Q (Type, Int)

-- | Promote a fcfified family, returning its partially applied
--   <a>Family</a> and its arity. The result can be applied to a
--   <a>consTuple</a> of the appropriate size,
promoteNDFamily :: Name -> Q (Type, Int)

-- | Get the quoted fcf <a>Name</a> of an existing type family.
familyName :: Name -> Type

-- | Apply a promoted family.
--   
--   If there are more arguments than the arity of the family (as returned
--   by <a>promoteFamily</a>), they are split and applied properly: the
--   family's main arguments are collected in a <a>consTuple</a> and the
--   rest are applied with <a>AppT</a>.
--   
--   If there are fewer arguments than the arity, the result is nonsense.
applyFamily :: Name -> [Q Type] -> Q Type

-- | Construct a tuple suitable for a <a>Family</a> argument.
consTuple :: [Type] -> Type
paramsProxy :: Name -> Q Type

-- | <a>True</a> if it is a type family (open or closed).
isTypeFamily :: Name -> Q Bool

-- | <a>True</a> if it is a type synonym.
isTypeSynonym :: Name -> Q Bool

-- | <a>True</a> if it is a type family or synonym.
isTypeFamilyOrSynonym :: Name -> Q Bool


-- | <a>Eval</a> and friends as part of the family of families.
module Fcf.Family.Meta
