-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Second-Order Abstract Syntax implemented via Free Foil (a version of SOAS).
--   
--   Please see the README on GitHub at
--   <a>https://github.com/fizruk/free-foil#readme</a>
@package soas
@version 0.2.0


-- | The abstract syntax of language Syntax.
module Language.SOAS.Syntax.Abs
type TermTyping = TermTyping' BNFC'Position
data TermTyping' a
TermTyping :: a -> TypeBinders' a -> Context' a -> ScopedTerm' a -> ScopedType' a -> TermTyping' a
type Context = Context' BNFC'Position
data Context' a
Context :: a -> [MetaVarTyping' a] -> [VarTyping' a] -> Context' a
type VarTyping = VarTyping' BNFC'Position
data VarTyping' a
VarTyping :: a -> VarIdent -> Type' a -> VarTyping' a
type MetaVarTyping = MetaVarTyping' BNFC'Position
data MetaVarTyping' a
MetaVarTyping :: a -> MetaVarIdent -> [Type' a] -> Type' a -> MetaVarTyping' a
type OpTyping = OpTyping' BNFC'Position
data OpTyping' a
OpTyping :: a -> OpIdent -> TypeBinders' a -> [ScopedOpArgTyping' a] -> ScopedType' a -> OpTyping' a
type Constraint = Constraint' BNFC'Position
data Constraint' a
ConstraintEq :: a -> Binders' a -> ScopedTerm' a -> ScopedTerm' a -> Constraint' a
type Unifier = Unifier' BNFC'Position
data Unifier' a
Unifier :: a -> [Subst' a] -> Unifier' a
type Subst = Subst' BNFC'Position
data Subst' a
Subst :: a -> MetaVarIdent -> Binders' a -> ScopedTerm' a -> Subst' a
type Term = Term' BNFC'Position
data Term' a
Var :: a -> VarIdent -> Term' a
Op :: a -> OpIdent -> [OpArg' a] -> Term' a
MetaVar :: a -> MetaVarIdent -> [Term' a] -> Term' a
type OpArg = OpArg' BNFC'Position
data OpArg' a
OpArg :: a -> Binders' a -> ScopedTerm' a -> OpArg' a
PlainOpArg :: a -> Term' a -> OpArg' a
type Binders = Binders' BNFC'Position
data Binders' a
NoBinders :: a -> Binders' a
SomeBinders :: a -> VarIdent -> Binders' a -> Binders' a
type ScopedTerm = ScopedTerm' BNFC'Position
data ScopedTerm' a
ScopedTerm :: a -> Term' a -> ScopedTerm' a
type Type = Type' BNFC'Position
data Type' a
TypeFun :: a -> Type' a -> Type' a -> Type' a
TypeProduct :: a -> Type' a -> Type' a -> Type' a
TypeVar :: a -> VarIdent -> Type' a
type TypeBinders = TypeBinders' BNFC'Position
data TypeBinders' a
NoTypeBinders :: a -> TypeBinders' a
SomeTypeBinders :: a -> VarIdent -> TypeBinders' a -> TypeBinders' a
type ScopedOpArgTyping = ScopedOpArgTyping' BNFC'Position
data ScopedOpArgTyping' a
ScopedOpArgTyping :: a -> OpArgTyping' a -> ScopedOpArgTyping' a
type OpArgTyping = OpArgTyping' BNFC'Position
data OpArgTyping' a
OpArgTyping :: a -> [Type' a] -> Type' a -> OpArgTyping' a
type ScopedType = ScopedType' BNFC'Position
data ScopedType' a
ScopedType :: a -> Type' a -> ScopedType' a
newtype VarIdent
VarIdent :: String -> VarIdent
newtype OpIdent
OpIdent :: String -> OpIdent
newtype MetaVarIdent
MetaVarIdent :: String -> MetaVarIdent

-- | Start position (line, column) of something.
type BNFC'Position = Maybe (Int, Int)
pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'Position :: Int -> Int -> BNFC'Position

-- | Get the start position of something.
class HasPosition a
hasPosition :: HasPosition a => a -> BNFC'Position
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.Binders' a)
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.Constraint' a)
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.Context' a)
instance Data.Data.Data Language.SOAS.Syntax.Abs.MetaVarIdent
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.MetaVarTyping' a)
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.OpArg' a)
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.OpArgTyping' a)
instance Data.Data.Data Language.SOAS.Syntax.Abs.OpIdent
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.OpTyping' a)
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.ScopedOpArgTyping' a)
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.ScopedTerm' a)
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.ScopedType' a)
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.Subst' a)
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.Term' a)
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.TermTyping' a)
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.Type' a)
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.TypeBinders' a)
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.Unifier' a)
instance Data.Data.Data Language.SOAS.Syntax.Abs.VarIdent
instance Data.Data.Data a => Data.Data.Data (Language.SOAS.Syntax.Abs.VarTyping' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.Binders' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.Constraint' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.Context' a)
instance GHC.Classes.Eq Language.SOAS.Syntax.Abs.MetaVarIdent
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.MetaVarTyping' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.OpArg' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.OpArgTyping' a)
instance GHC.Classes.Eq Language.SOAS.Syntax.Abs.OpIdent
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.OpTyping' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.ScopedOpArgTyping' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.ScopedTerm' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.ScopedType' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.Subst' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.Term' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.TermTyping' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.Type' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.TypeBinders' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.Unifier' a)
instance GHC.Classes.Eq Language.SOAS.Syntax.Abs.VarIdent
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.SOAS.Syntax.Abs.VarTyping' a)
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.Binders'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.Constraint'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.Context'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.MetaVarTyping'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.OpArg'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.OpArgTyping'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.OpTyping'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.ScopedOpArgTyping'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.ScopedTerm'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.ScopedType'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.Subst'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.Term'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.TermTyping'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.Type'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.TypeBinders'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.Unifier'
instance Data.Foldable.Foldable Language.SOAS.Syntax.Abs.VarTyping'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.Binders'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.Constraint'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.Context'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.MetaVarTyping'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.OpArg'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.OpArgTyping'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.OpTyping'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.ScopedOpArgTyping'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.ScopedTerm'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.ScopedType'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.Subst'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.Term'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.TermTyping'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.Type'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.TypeBinders'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.Unifier'
instance GHC.Base.Functor Language.SOAS.Syntax.Abs.VarTyping'
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.Binders' a)
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.Constraint' a)
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.Context' a)
instance GHC.Generics.Generic Language.SOAS.Syntax.Abs.MetaVarIdent
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.MetaVarTyping' a)
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.OpArg' a)
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.OpArgTyping' a)
instance GHC.Generics.Generic Language.SOAS.Syntax.Abs.OpIdent
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.OpTyping' a)
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.ScopedOpArgTyping' a)
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.ScopedTerm' a)
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.ScopedType' a)
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.Subst' a)
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.Term' a)
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.TermTyping' a)
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.Type' a)
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.TypeBinders' a)
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.Unifier' a)
instance GHC.Generics.Generic Language.SOAS.Syntax.Abs.VarIdent
instance GHC.Generics.Generic (Language.SOAS.Syntax.Abs.VarTyping' a)
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.Binders
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.Constraint
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.Context
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.MetaVarTyping
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.OpArg
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.OpArgTyping
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.OpTyping
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.ScopedOpArgTyping
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.ScopedTerm
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.ScopedType
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.Subst
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.Term
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.TermTyping
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.Type
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.TypeBinders
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.Unifier
instance Language.SOAS.Syntax.Abs.HasPosition Language.SOAS.Syntax.Abs.VarTyping
instance Data.String.IsString Language.SOAS.Syntax.Abs.MetaVarIdent
instance Data.String.IsString Language.SOAS.Syntax.Abs.OpIdent
instance Data.String.IsString Language.SOAS.Syntax.Abs.VarIdent
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.Binders' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.Constraint' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.Context' a)
instance GHC.Classes.Ord Language.SOAS.Syntax.Abs.MetaVarIdent
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.MetaVarTyping' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.OpArg' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.OpArgTyping' a)
instance GHC.Classes.Ord Language.SOAS.Syntax.Abs.OpIdent
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.OpTyping' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.ScopedOpArgTyping' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.ScopedTerm' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.ScopedType' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.Subst' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.Term' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.TermTyping' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.Type' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.TypeBinders' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.Unifier' a)
instance GHC.Classes.Ord Language.SOAS.Syntax.Abs.VarIdent
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.SOAS.Syntax.Abs.VarTyping' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.Binders' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.Constraint' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.Context' a)
instance GHC.Read.Read Language.SOAS.Syntax.Abs.MetaVarIdent
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.MetaVarTyping' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.OpArg' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.OpArgTyping' a)
instance GHC.Read.Read Language.SOAS.Syntax.Abs.OpIdent
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.OpTyping' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.ScopedOpArgTyping' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.ScopedTerm' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.ScopedType' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.Subst' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.Term' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.TermTyping' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.Type' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.TypeBinders' a)
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.Unifier' a)
instance GHC.Read.Read Language.SOAS.Syntax.Abs.VarIdent
instance GHC.Read.Read a => GHC.Read.Read (Language.SOAS.Syntax.Abs.VarTyping' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.Binders' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.Constraint' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.Context' a)
instance GHC.Show.Show Language.SOAS.Syntax.Abs.MetaVarIdent
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.MetaVarTyping' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.OpArg' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.OpArgTyping' a)
instance GHC.Show.Show Language.SOAS.Syntax.Abs.OpIdent
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.OpTyping' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.ScopedOpArgTyping' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.ScopedTerm' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.ScopedType' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.Subst' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.Term' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.TermTyping' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.Type' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.TypeBinders' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.Unifier' a)
instance GHC.Show.Show Language.SOAS.Syntax.Abs.VarIdent
instance GHC.Show.Show a => GHC.Show.Show (Language.SOAS.Syntax.Abs.VarTyping' a)
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.Binders'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.Constraint'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.Context'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.MetaVarTyping'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.OpArg'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.OpArgTyping'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.OpTyping'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.ScopedOpArgTyping'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.ScopedTerm'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.ScopedType'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.Subst'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.Term'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.TermTyping'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.Type'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.TypeBinders'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.Unifier'
instance Data.Traversable.Traversable Language.SOAS.Syntax.Abs.VarTyping'

module Language.SOAS.FreeFoilConfig
intToVarIdent :: Int -> VarIdent
rawVar :: VarIdent -> Term' a
rawTypeVar :: VarIdent -> Type' a
rawScopedTerm :: Term' a -> ScopedTerm' a
rawScopedType :: Type' a -> ScopedType' a
rawScopeToTerm :: ScopedTerm' a -> Term' a
rawScopeToType :: ScopedType' a -> Type' a
soasConfig :: FreeFoilConfig

module Language.SOAS.Syntax.Lex
alex_tab_size :: Int
alex_base :: AlexAddr
alex_table :: AlexAddr
alex_check :: AlexAddr
alex_deflt :: AlexAddr
alex_accept :: Array Int (AlexAcc user)
alex_actions :: Array Int (Posn -> String -> Token)
alex_action_3 :: Posn -> String -> Token
alex_action_4 :: Posn -> String -> Token
alex_action_5 :: Posn -> String -> Token
alex_action_6 :: Posn -> String -> Token
alex_action_7 :: Posn -> String -> Token
data AlexAddr
AlexA# :: Addr# -> AlexAddr
alexIndexInt16OffAddr :: AlexAddr -> Int# -> Int#
alexIndexInt32OffAddr :: AlexAddr -> Int# -> Int#
quickIndex :: Array Int (AlexAcc (Any :: Type)) -> Int -> AlexAcc (Any :: Type)
data AlexReturn a
AlexEOF :: AlexReturn a
AlexError :: !AlexInput -> AlexReturn a
AlexSkip :: !AlexInput -> !Int -> AlexReturn a
AlexToken :: !AlexInput -> !Int -> a -> AlexReturn a
alexScan :: (Posn, Char, [Byte], String) -> Int -> AlexReturn (Posn -> String -> Token)
alexScanUser :: t -> (Posn, Char, [Byte], String) -> Int -> AlexReturn (Posn -> String -> Token)
alex_scan_tkn :: t1 -> t2 -> Int# -> AlexInput -> Int# -> AlexLastAcc -> (AlexLastAcc, AlexInput)
data AlexLastAcc
AlexNone :: AlexLastAcc
AlexLastAcc :: !Int -> !AlexInput -> !Int -> AlexLastAcc
AlexLastSkip :: !AlexInput -> !Int -> AlexLastAcc
data AlexAcc user
AlexAccNone :: AlexAcc user
AlexAcc :: Int -> AlexAcc user
AlexAccSkip :: AlexAcc user

-- | Create a token with position.
tok :: (String -> Tok) -> Posn -> String -> Token

-- | Token without position.
data Tok

-- | Reserved word or symbol.
TK :: {-# UNPACK #-} !TokSymbol -> Tok

-- | String literal.
TL :: !String -> Tok

-- | Integer literal.
TI :: !String -> Tok

-- | Identifier.
TV :: !String -> Tok

-- | Float literal.
TD :: !String -> Tok

-- | Character literal.
TC :: !String -> Tok
T_VarIdent :: !String -> Tok
T_OpIdent :: !String -> Tok
T_MetaVarIdent :: !String -> Tok

-- | Smart constructor for <a>Tok</a> for the sake of backwards
--   compatibility.
pattern TS :: String -> Int -> Tok

-- | Keyword or symbol tokens have a unique ID.
data TokSymbol
TokSymbol :: String -> !Int -> TokSymbol

-- | Keyword or symbol text.
[tsText] :: TokSymbol -> String

-- | Unique ID.
[tsID] :: TokSymbol -> !Int

-- | Token with position.
data Token
PT :: Posn -> Tok -> Token
Err :: Posn -> Token

-- | Pretty print a position.
printPosn :: Posn -> String

-- | Pretty print the position of the first token in the list.
tokenPos :: [Token] -> String

-- | Get the position of a token.
tokenPosn :: Token -> Posn

-- | Get line and column of a token.
tokenLineCol :: Token -> (Int, Int)

-- | Get line and column of a position.
posLineCol :: Posn -> (Int, Int)

-- | Convert a token into "position token" form.
mkPosToken :: Token -> ((Int, Int), String)

-- | Convert a token to its text.
tokenText :: Token -> String

-- | Convert a token to a string.
prToken :: Token -> String

-- | Finite map from text to token organized as binary search tree.
data BTree

-- | Nil (leaf).
N :: BTree

-- | Binary node.
B :: String -> Tok -> BTree -> BTree -> BTree

-- | Convert potential keyword into token or use fallback conversion.
eitherResIdent :: (String -> Tok) -> String -> Tok

-- | The keywords and symbols of the language organized as binary search
--   tree.
resWords :: BTree

-- | Unquote string literal.
unescapeInitTail :: String -> String
data Posn
Pn :: !Int -> !Int -> !Int -> Posn
alexStartPos :: Posn
alexMove :: Posn -> Char -> Posn
type Byte = Word8
type AlexInput = (Posn, Char, [Byte], String)
tokens :: String -> [Token]
alexGetByte :: AlexInput -> Maybe (Byte, AlexInput)
alexInputPrevChar :: AlexInput -> Char

-- | Encode a Haskell String to a list of Word8 values, in UTF8 format.
utf8Encode :: Char -> [Word8]
instance GHC.Classes.Eq Language.SOAS.Syntax.Lex.Posn
instance GHC.Classes.Eq Language.SOAS.Syntax.Lex.Tok
instance GHC.Classes.Eq Language.SOAS.Syntax.Lex.TokSymbol
instance GHC.Classes.Eq Language.SOAS.Syntax.Lex.Token
instance GHC.Classes.Ord Language.SOAS.Syntax.Lex.Posn
instance GHC.Classes.Ord Language.SOAS.Syntax.Lex.Tok
instance GHC.Classes.Ord Language.SOAS.Syntax.Lex.TokSymbol
instance GHC.Classes.Ord Language.SOAS.Syntax.Lex.Token
instance GHC.Show.Show Language.SOAS.Syntax.Lex.BTree
instance GHC.Show.Show Language.SOAS.Syntax.Lex.Posn
instance GHC.Show.Show Language.SOAS.Syntax.Lex.Tok
instance GHC.Show.Show Language.SOAS.Syntax.Lex.TokSymbol
instance GHC.Show.Show Language.SOAS.Syntax.Lex.Token

module Language.SOAS.Syntax.Par
happyError :: [Token] -> Err a
myLexer :: String -> [Token]
pTermTyping :: [Token] -> Err TermTyping
pContext :: [Token] -> Err Context
pVarTyping :: [Token] -> Err VarTyping
pListVarTyping :: [Token] -> Err [VarTyping]
pMetaVarTyping :: [Token] -> Err MetaVarTyping
pListMetaVarTyping :: [Token] -> Err [MetaVarTyping]
pOpTyping :: [Token] -> Err OpTyping
pConstraint :: [Token] -> Err Constraint
pUnifier :: [Token] -> Err Unifier
pSubst :: [Token] -> Err Subst
pListSubst :: [Token] -> Err [Subst]
pTerm :: [Token] -> Err Term
pListTerm :: [Token] -> Err [Term]
pOpArg :: [Token] -> Err OpArg
pListOpArg :: [Token] -> Err [OpArg]
pBinders :: [Token] -> Err Binders
pScopedTerm :: [Token] -> Err ScopedTerm
pType :: [Token] -> Err Type
pType1 :: [Token] -> Err Type
pType2 :: [Token] -> Err Type
pListType :: [Token] -> Err [Type]
pTypeBinders :: [Token] -> Err TypeBinders
pScopedOpArgTyping :: [Token] -> Err ScopedOpArgTyping
pListScopedOpArgTyping :: [Token] -> Err [ScopedOpArgTyping]
pOpArgTyping :: [Token] -> Err OpArgTyping
pScopedType :: [Token] -> Err ScopedType
pListScopedType :: [Token] -> Err [ScopedType]


-- | Pretty-printer for Language.
module Language.SOAS.Syntax.Print

-- | The top-level printing method.
printTree :: Print a => a -> String
type Doc = [ShowS] -> [ShowS]
doc :: ShowS -> Doc
render :: Doc -> String
parenth :: Doc -> Doc
concatS :: [ShowS] -> ShowS
concatD :: [Doc] -> Doc
replicateS :: Int -> ShowS -> ShowS

-- | The printer class does the job.
class Print a
prt :: Print a => Int -> a -> Doc
printString :: String -> Doc
mkEsc :: Char -> Char -> ShowS
prPrec :: Int -> Int -> Doc -> Doc
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.Binders' a)
instance Language.SOAS.Syntax.Print.Print GHC.Types.Char
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.Constraint' a)
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.Context' a)
instance Language.SOAS.Syntax.Print.Print GHC.Types.Double
instance Language.SOAS.Syntax.Print.Print GHC.Num.Integer.Integer
instance Language.SOAS.Syntax.Print.Print a => Language.SOAS.Syntax.Print.Print [a]
instance Language.SOAS.Syntax.Print.Print GHC.Base.String
instance Language.SOAS.Syntax.Print.Print [Language.SOAS.Syntax.Abs.VarTyping' a]
instance Language.SOAS.Syntax.Print.Print [Language.SOAS.Syntax.Abs.MetaVarTyping' a]
instance Language.SOAS.Syntax.Print.Print [Language.SOAS.Syntax.Abs.Subst' a]
instance Language.SOAS.Syntax.Print.Print [Language.SOAS.Syntax.Abs.Term' a]
instance Language.SOAS.Syntax.Print.Print [Language.SOAS.Syntax.Abs.OpArg' a]
instance Language.SOAS.Syntax.Print.Print [Language.SOAS.Syntax.Abs.Type' a]
instance Language.SOAS.Syntax.Print.Print [Language.SOAS.Syntax.Abs.ScopedOpArgTyping' a]
instance Language.SOAS.Syntax.Print.Print [Language.SOAS.Syntax.Abs.ScopedType' a]
instance Language.SOAS.Syntax.Print.Print Language.SOAS.Syntax.Abs.MetaVarIdent
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.MetaVarTyping' a)
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.OpArg' a)
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.OpArgTyping' a)
instance Language.SOAS.Syntax.Print.Print Language.SOAS.Syntax.Abs.OpIdent
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.OpTyping' a)
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.ScopedOpArgTyping' a)
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.ScopedTerm' a)
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.ScopedType' a)
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.Subst' a)
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.Term' a)
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.TermTyping' a)
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.Type' a)
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.TypeBinders' a)
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.Unifier' a)
instance Language.SOAS.Syntax.Print.Print Language.SOAS.Syntax.Abs.VarIdent
instance Language.SOAS.Syntax.Print.Print (Language.SOAS.Syntax.Abs.VarTyping' a)

module Language.SOAS.Impl.Generated

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A scope-safe version of
--   <a>ScopedOpArgTyping'</a>.
type ScopedOpArgTyping' a (n :: S) = ScopedOpArgTyping'Sig a ScopedAST TypeBinders' a Type'Sig a n AST TypeBinders' a Type'Sig a n

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A signature based on
--   <a>ScopedOpArgTyping'</a>.
data ScopedOpArgTyping'Sig a scope term

-- | Corresponds to <a>ScopedOpArgTyping</a>.
[ScopedOpArgTypingSig] :: forall a scope term. a -> OpArgTyping'Sig a scope term -> ScopedOpArgTyping'Sig a scope term

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A scope-safe version of
--   <a>OpArgTyping'</a>.
type OpArgTyping' a (n :: S) = OpArgTyping'Sig a ScopedAST TypeBinders' a Type'Sig a n AST TypeBinders' a Type'Sig a n

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A signature based on
--   <a>OpArgTyping'</a>.
data OpArgTyping'Sig a scope term

-- | Corresponds to <a>OpArgTyping</a>.
[OpArgTypingSig] :: forall a term scope. a -> [term] -> term -> OpArgTyping'Sig a scope term

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A scoped (and scope-safe)
--   version of <a>Type'</a>.
type ScopedType' a = ScopedAST TypeBinders' a Type'Sig a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A scope-safe version of
--   <a>Type'</a>.
type Type' a = AST TypeBinders' a Type'Sig a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A signature based on
--   <a>Type'</a>.
data Type'Sig a scope term

-- | Corresponds to <a>TypeFun</a>.
[TypeFunSig] :: forall a term scope. a -> term -> term -> Type'Sig a scope term

-- | Corresponds to <a>TypeProduct</a>.
[TypeProductSig] :: forall a term scope. a -> term -> term -> Type'Sig a scope term

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A scope-safe version of
--   <a>OpArg'</a>.
type OpArg' a (n :: S) = OpArg'Sig a ScopedAST Binders' a Term'Sig a n AST Binders' a Term'Sig a n

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A signature based on
--   <a>OpArg'</a>.
data OpArg'Sig a scope term

-- | Corresponds to <a>OpArg</a>.
[OpArgSig] :: forall a scope term. a -> scope -> OpArg'Sig a scope term

-- | Corresponds to <a>PlainOpArg</a>.
[PlainOpArgSig] :: forall a term scope. a -> term -> OpArg'Sig a scope term

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A scoped (and scope-safe)
--   version of <a>Term'</a>.
type ScopedTerm' a = ScopedAST Binders' a Term'Sig a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A scope-safe version of
--   <a>Term'</a>.
type Term' a = AST Binders' a Term'Sig a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A signature based on
--   <a>Term'</a>.
data Term'Sig a scope term

-- | Corresponds to <a>Op</a>.
[OpSig] :: forall a scope term. a -> OpIdent -> [OpArg'Sig a scope term] -> Term'Sig a scope term

-- | Corresponds to <a>MetaVar</a>.
[MetaVarSig] :: forall a term scope. a -> MetaVarIdent -> [term] -> Term'Sig a scope term

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A binding type, scope-safe
--   version of <a>TypeBinders'</a>.
data TypeBinders' a (o :: S) (i :: S)

-- | Corresponds to <a>NoTypeBinders</a>.
[NoTypeBinders] :: forall a (o :: S). a -> TypeBinders' a o o

-- | Corresponds to <a>SomeTypeBinders</a>.
[SomeTypeBinders] :: forall a (o :: S) (i1 :: S) (i :: S). a -> NameBinder o i1 -> TypeBinders' a i1 i -> TypeBinders' a o i

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A binding type, scope-safe
--   version of <a>Binders'</a>.
data Binders' a (o :: S) (i :: S)

-- | Corresponds to <a>NoBinders</a>.
[NoBinders] :: forall a (o :: S). a -> Binders' a o o

-- | Corresponds to <a>SomeBinders</a>.
[SomeBinders] :: forall a (o :: S) (i1 :: S) (i :: S). a -> NameBinder o i1 -> Binders' a i1 i -> Binders' a o i

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A scope-safe version of
--   <a>TermTyping'</a>.
data TermTyping' a (o :: S)

-- | Corresponds to <a>TermTyping</a>.
[TermTyping] :: forall a (o :: S) (i :: S). a -> TypeBinders' a o i -> Context' a -> Term' a i -> Type' a i -> TermTyping' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A scope-safe version of
--   <a>VarTyping'</a>.
data VarTyping' a (o :: S)

-- | Corresponds to <a>VarTyping</a>.
[VarTyping] :: forall a (o :: S). a -> Name o -> Type' a o -> VarTyping' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A scope-safe version of
--   <a>Constraint'</a>.
data Constraint' a (o :: S)

-- | Corresponds to <a>ConstraintEq</a>.
[ConstraintEq] :: forall a (o :: S) (i :: S). a -> Binders' a o i -> Term' a i -> Term' a i -> Constraint' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A scope-safe version of
--   <a>OpTyping'</a>.
data OpTyping' a (o :: S)

-- | Corresponds to <a>OpTyping</a>.
[OpTyping] :: forall a (o :: S) (i :: S). a -> OpIdent -> TypeBinders' a o i -> [ScopedOpArgTyping' a i] -> Type' a i -> OpTyping' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A scope-safe version of
--   <a>MetaVarTyping'</a>.
data MetaVarTyping' a (o :: S)

-- | Corresponds to <a>MetaVarTyping</a>.
[MetaVarTyping] :: forall a (o :: S). a -> MetaVarIdent -> [Type' a o] -> Type' a o -> MetaVarTyping' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A scope-safe version of
--   <a>Subst'</a>.
data Subst' a (o :: S)

-- | Corresponds to <a>Subst</a>.
[Subst] :: forall a (o :: S) (i :: S). a -> MetaVarIdent -> Binders' a o i -> Term' a i -> Subst' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>ScopedOpArgTyping</a>.
pattern ScopedOpArgTyping :: forall a (o :: S). a -> OpArgTyping' a o -> ScopedOpArgTyping' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>OpArgTyping</a>.
pattern OpArgTyping :: forall a (o :: S). a -> [Type' a o] -> Type' a o -> OpArgTyping' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>TypeProduct</a>.
pattern TypeProduct :: a -> Type' a o -> Type' a o -> Type' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>TypeFun</a>.
pattern TypeFun :: a -> Type' a o -> Type' a o -> Type' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>PlainOpArg</a>.
pattern PlainOpArg :: forall a (o :: S). a -> Term' a o -> OpArg' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>OpArg</a>.
pattern OpArg :: forall a (o :: S) (i :: S). () => a -> Binders' a o i -> Term' a i -> OpArg' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>MetaVar</a>.
pattern MetaVar :: a -> MetaVarIdent -> [Term' a o] -> Term' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>Op</a>.
pattern Op :: a -> OpIdent -> [OpArg' a o] -> Term' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A helper used to convert from
--   scope-safe to raw representation.
fromTerm'Sig :: Term'Sig a (Binders' a, ScopedTerm' a) (Term' a) -> Term' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A helper used to convert from
--   scope-safe to raw representation.
fromOpArg'Sig :: OpArg'Sig a (Binders' a, ScopedTerm' a) (Term' a) -> OpArg' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert a scope-safe to a raw
--   binding.
fromBinders' :: forall a (o :: S) (i :: S). Binders' a o i -> Binders' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
fromOpArg' :: forall a (o :: S). OpArg' a o -> OpArg' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
fromTerm' :: forall a (o :: S). Term' a o -> Term' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A helper used to convert from
--   scope-safe to raw representation.
fromType'Sig :: Type'Sig a (TypeBinders' a, ScopedType' a) (Type' a) -> Type' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A helper used to convert from
--   scope-safe to raw representation.
fromOpArgTyping'Sig :: OpArgTyping'Sig a (TypeBinders' a, ScopedType' a) (Type' a) -> OpArgTyping' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A helper used to convert from
--   scope-safe to raw representation.
fromScopedOpArgTyping'Sig :: ScopedOpArgTyping'Sig a (TypeBinders' a, ScopedType' a) (Type' a) -> ScopedOpArgTyping' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert a scope-safe to a raw
--   binding.
fromTypeBinders' :: forall a (o :: S) (i :: S). TypeBinders' a o i -> TypeBinders' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
fromOpArgTyping' :: forall a (o :: S). OpArgTyping' a o -> OpArgTyping' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
fromScopedOpArgTyping' :: forall a (i :: S). ScopedOpArgTyping' a i -> ScopedOpArgTyping' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
fromType' :: forall a (o :: S). Type' a o -> Type' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
fromSubst' :: forall a (o :: S). Subst' a o -> Subst' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
fromMetaVarTyping' :: forall a (o :: S). MetaVarTyping' a o -> MetaVarTyping' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
fromOpTyping' :: forall a (o :: S). OpTyping' a o -> OpTyping' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
fromConstraint' :: forall a (o :: S). Constraint' a o -> Constraint' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
fromVarTyping' :: forall a (o :: S). VarTyping' a o -> VarTyping' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
fromTermTyping' :: forall a (o :: S). TermTyping' a o -> TermTyping' a

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A helper used to convert from
--   raw to scope-safe representation.
toTerm'Sig :: Term' a -> Either VarIdent (Term'Sig a (Binders' a, ScopedTerm' a) (Term' a))

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A helper used to convert from
--   raw to scope-safe representation.
toOpArg'Sig :: OpArg' a -> OpArg'Sig a (Binders' a, ScopedTerm' a) (Term' a)

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from raw to
--   scope-safe binding (CPS-style).
toBinders' :: forall (o :: S) a r. (Distinct o, Ord VarIdent) => Scope o -> Map VarIdent (Name o) -> Binders' a -> (forall (i :: S). DExt o i => Binders' a o i -> Map VarIdent (Name i) -> r) -> r

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
toOpArg' :: forall (o :: S) a. (Distinct o, Ord VarIdent) => Scope o -> Map VarIdent (Name o) -> OpArg' a -> OpArg' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
toTerm' :: forall (o :: S) a. (Distinct o, Ord VarIdent) => Scope o -> Map VarIdent (Name o) -> Term' a -> Term' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A helper used to convert from
--   raw to scope-safe representation.
toType'Sig :: Type' a -> Either VarIdent (Type'Sig a (TypeBinders' a, ScopedType' a) (Type' a))

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A helper used to convert from
--   raw to scope-safe representation.
toOpArgTyping'Sig :: OpArgTyping' a -> OpArgTyping'Sig a (TypeBinders' a, ScopedType' a) (Type' a)

-- | <i>Generated</i> with <a>mkFreeFoil</a>. A helper used to convert from
--   raw to scope-safe representation.
toScopedOpArgTyping'Sig :: ScopedOpArgTyping' a -> ScopedOpArgTyping'Sig a (TypeBinders' a, ScopedType' a) (Type' a)

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from raw to
--   scope-safe binding (CPS-style).
toTypeBinders' :: forall (o :: S) a r. (Distinct o, Ord VarIdent) => Scope o -> Map VarIdent (Name o) -> TypeBinders' a -> (forall (i :: S). DExt o i => TypeBinders' a o i -> Map VarIdent (Name i) -> r) -> r

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
toOpArgTyping' :: forall (o :: S) a. (Distinct o, Ord VarIdent) => Scope o -> Map VarIdent (Name o) -> OpArgTyping' a -> OpArgTyping' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
toScopedOpArgTyping' :: forall (i :: S) a. (Distinct i, Ord VarIdent) => Scope i -> Map VarIdent (Name i) -> ScopedOpArgTyping' a -> ScopedOpArgTyping' a i

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
toType' :: forall (o :: S) a. (Distinct o, Ord VarIdent) => Scope o -> Map VarIdent (Name o) -> Type' a -> Type' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
toSubst' :: forall (o :: S) a. (Distinct o, Ord VarIdent) => Scope o -> Map VarIdent (Name o) -> Subst' a -> Subst' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
toMetaVarTyping' :: forall (o :: S) a. (Distinct o, Ord VarIdent) => Scope o -> Map VarIdent (Name o) -> MetaVarTyping' a -> MetaVarTyping' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
toOpTyping' :: forall (o :: S) a. (Distinct o, Ord VarIdent) => Scope o -> Map VarIdent (Name o) -> OpTyping' a -> OpTyping' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
toConstraint' :: forall (o :: S) a. (Distinct o, Ord VarIdent) => Scope o -> Map VarIdent (Name o) -> Constraint' a -> Constraint' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
toVarTyping' :: forall (o :: S) a. (Distinct o, Ord VarIdent) => Scope o -> Map VarIdent (Name o) -> VarTyping' a -> VarTyping' a o

-- | <i>Generated</i> with <a>mkFreeFoil</a>. Convert from scope-safe to
--   raw representation.
toTermTyping' :: forall (o :: S) a. (Distinct o, Ord VarIdent) => Scope o -> Map VarIdent (Name o) -> TermTyping' a -> TermTyping' a o
unsafeParse :: ([Token] -> Either String a) -> String -> a
instance Data.Bifoldable.Bifoldable (Language.SOAS.Impl.Generated.OpArg'Sig a)
instance Data.Bifoldable.Bifoldable (Language.SOAS.Impl.Generated.OpArgTyping'Sig a)
instance Data.Bifoldable.Bifoldable (Language.SOAS.Impl.Generated.ScopedOpArgTyping'Sig a)
instance Data.Bifoldable.Bifoldable (Language.SOAS.Impl.Generated.Term'Sig a)
instance Data.Bifoldable.Bifoldable (Language.SOAS.Impl.Generated.Type'Sig a)
instance Data.Bifunctor.Bifunctor (Language.SOAS.Impl.Generated.OpArg'Sig a)
instance Data.Bifunctor.Bifunctor (Language.SOAS.Impl.Generated.OpArgTyping'Sig a)
instance Data.Bifunctor.Bifunctor (Language.SOAS.Impl.Generated.ScopedOpArgTyping'Sig a)
instance Data.Bifunctor.Bifunctor (Language.SOAS.Impl.Generated.Term'Sig a)
instance Data.Bifunctor.Bifunctor (Language.SOAS.Impl.Generated.Type'Sig a)
instance Data.Bitraversable.Bitraversable (Language.SOAS.Impl.Generated.OpArg'Sig a)
instance Data.Bitraversable.Bitraversable (Language.SOAS.Impl.Generated.OpArgTyping'Sig a)
instance Data.Bitraversable.Bitraversable (Language.SOAS.Impl.Generated.ScopedOpArgTyping'Sig a)
instance Data.Bitraversable.Bitraversable (Language.SOAS.Impl.Generated.Term'Sig a)
instance Data.Bitraversable.Bitraversable (Language.SOAS.Impl.Generated.Type'Sig a)
instance Control.Monad.Foil.Internal.CoSinkable (Language.SOAS.Impl.Generated.Binders' a)
instance Control.Monad.Foil.Internal.CoSinkable (Language.SOAS.Impl.Generated.TypeBinders' a)
instance Data.Foldable.Foldable (Language.SOAS.Impl.Generated.OpArg'Sig a scope)
instance Data.Foldable.Foldable (Language.SOAS.Impl.Generated.OpArgTyping'Sig a scope)
instance Data.Foldable.Foldable (Language.SOAS.Impl.Generated.ScopedOpArgTyping'Sig a scope)
instance Data.Foldable.Foldable (Language.SOAS.Impl.Generated.Term'Sig a scope)
instance Data.Foldable.Foldable (Language.SOAS.Impl.Generated.Type'Sig a scope)
instance GHC.Base.Functor (Language.SOAS.Impl.Generated.OpArg'Sig a scope)
instance GHC.Base.Functor (Language.SOAS.Impl.Generated.OpArgTyping'Sig a scope)
instance GHC.Base.Functor (Language.SOAS.Impl.Generated.ScopedOpArgTyping'Sig a scope)
instance GHC.Base.Functor (Language.SOAS.Impl.Generated.Term'Sig a scope)
instance GHC.Base.Functor (Language.SOAS.Impl.Generated.Type'Sig a scope)
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.Binders' a o)
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.Binders' a)
instance Generics.Kind.GenericK Language.SOAS.Impl.Generated.Binders'
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.Constraint' a)
instance Generics.Kind.GenericK Language.SOAS.Impl.Generated.Constraint'
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.OpArg'Sig a scope)
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.OpArg'Sig a)
instance Generics.Kind.GenericK Language.SOAS.Impl.Generated.OpArg'Sig
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.OpArgTyping'Sig a scope)
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.OpArgTyping'Sig a)
instance Generics.Kind.GenericK Language.SOAS.Impl.Generated.OpArgTyping'Sig
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.OpTyping' a)
instance Generics.Kind.GenericK Language.SOAS.Impl.Generated.OpTyping'
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.Subst' a)
instance Generics.Kind.GenericK Language.SOAS.Impl.Generated.Subst'
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.Term'Sig a scope)
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.Term'Sig a)
instance Generics.Kind.GenericK Language.SOAS.Impl.Generated.Term'Sig
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.Type'Sig a scope)
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.Type'Sig a)
instance Generics.Kind.GenericK Language.SOAS.Impl.Generated.Type'Sig
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.TypeBinders' a o)
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.TypeBinders' a)
instance Generics.Kind.GenericK Language.SOAS.Impl.Generated.TypeBinders'
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.Binders' a o i)
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.Constraint' a o)
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.OpArg'Sig a scope term)
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.OpArgTyping'Sig a scope term)
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.OpTyping' a o)
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.Subst' a o)
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.Term'Sig a scope term)
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.Type'Sig a scope term)
instance Generics.Kind.GenericK (Language.SOAS.Impl.Generated.TypeBinders' a o i)
instance GHC.Generics.Generic (Language.SOAS.Impl.Generated.OpArg'Sig a scope term)
instance GHC.Generics.Generic (Language.SOAS.Impl.Generated.OpArgTyping'Sig a scope term)
instance GHC.Generics.Generic (Language.SOAS.Impl.Generated.ScopedOpArgTyping'Sig a scope term)
instance GHC.Generics.Generic (Language.SOAS.Impl.Generated.Term'Sig a scope term)
instance GHC.Generics.Generic (Language.SOAS.Impl.Generated.Type'Sig a scope term)
instance Control.Monad.Foil.Internal.HasNameBinders (Language.SOAS.Impl.Generated.Binders' a)
instance Control.Monad.Foil.Internal.HasNameBinders (Language.SOAS.Impl.Generated.TypeBinders' a)
instance Data.String.IsString (Language.SOAS.Impl.Generated.Term' Language.SOAS.Syntax.Abs.BNFC'Position 'Control.Monad.Foil.Internal.VoidS)
instance Data.String.IsString (Language.SOAS.Impl.Generated.Type' Language.SOAS.Syntax.Abs.BNFC'Position 'Control.Monad.Foil.Internal.VoidS)
instance Data.String.IsString (Language.SOAS.Impl.Generated.Constraint' Language.SOAS.Syntax.Abs.BNFC'Position 'Control.Monad.Foil.Internal.VoidS)
instance Data.String.IsString (Language.SOAS.Impl.Generated.OpTyping' Language.SOAS.Syntax.Abs.BNFC'Position 'Control.Monad.Foil.Internal.VoidS)
instance Data.String.IsString (Language.SOAS.Impl.Generated.Subst' Language.SOAS.Syntax.Abs.BNFC'Position 'Control.Monad.Foil.Internal.VoidS)
instance GHC.Show.Show (Language.SOAS.Impl.Generated.Term' a n)
instance GHC.Show.Show (Language.SOAS.Impl.Generated.Type' a n)
instance GHC.Show.Show (Language.SOAS.Impl.Generated.Constraint' a n)
instance GHC.Show.Show (Language.SOAS.Impl.Generated.OpTyping' a n)
instance GHC.Show.Show (Language.SOAS.Impl.Generated.Subst' a n)
instance Control.Monad.Foil.Internal.SinkableK (Language.SOAS.Impl.Generated.Binders' a)
instance Control.Monad.Foil.Internal.SinkableK (Language.SOAS.Impl.Generated.TypeBinders' a)
instance Control.Monad.Foil.Internal.Sinkable (Language.SOAS.Impl.Generated.Constraint' a)
instance Control.Monad.Foil.Internal.Sinkable (Language.SOAS.Impl.Generated.OpTyping' a)
instance Control.Monad.Foil.Internal.Sinkable (Language.SOAS.Impl.Generated.Subst' a)
instance Data.Traversable.Traversable (Language.SOAS.Impl.Generated.OpArg'Sig a scope)
instance Data.Traversable.Traversable (Language.SOAS.Impl.Generated.OpArgTyping'Sig a scope)
instance Data.Traversable.Traversable (Language.SOAS.Impl.Generated.ScopedOpArgTyping'Sig a scope)
instance Data.Traversable.Traversable (Language.SOAS.Impl.Generated.Term'Sig a scope)
instance Data.Traversable.Traversable (Language.SOAS.Impl.Generated.Type'Sig a scope)
instance Control.Monad.Foil.Internal.UnifiablePattern (Language.SOAS.Impl.Generated.Binders' a)
instance Data.ZipMatchK.Generic.ZipMatchK a => Data.ZipMatchK.Generic.ZipMatchK (Language.SOAS.Impl.Generated.OpArg'Sig a)
instance Data.ZipMatchK.Generic.ZipMatchK a => Data.ZipMatchK.Generic.ZipMatchK (Language.SOAS.Impl.Generated.Term'Sig a)
instance Data.ZipMatchK.Generic.ZipMatchK a => Data.ZipMatchK.Generic.ZipMatchK (Language.SOAS.Impl.Generated.Type'Sig a)
instance Data.ZipMatchK.Generic.ZipMatchK Language.SOAS.Syntax.Abs.BNFC'Position
instance Data.ZipMatchK.Generic.ZipMatchK Language.SOAS.Syntax.Abs.MetaVarIdent
instance Data.ZipMatchK.Generic.ZipMatchK Language.SOAS.Syntax.Abs.OpIdent


-- | Functions over Second-Order Abstract Syntax (SOAS) represented using
--   scope-safe Haskell types (via Free Foil).
module Language.SOAS.Impl

-- | Standard terms with source code location annotations.
type Term = Term' BNFC'Position

-- | Standard types with source code location annotations.
type Type = Type' BNFC'Position

-- | Standard metavariable substitutions with source code location
--   annotations.
type Subst = Subst' BNFC'Position 'VoidS

-- | Standard unification constraints with source code location
--   annotations.
type Constraint = Constraint' BNFC'Position 'VoidS

-- | Standard operator typings with source code location annotations.
type OpTyping = OpTyping' BNFC'Position 'VoidS

-- | Lookup a substitution by its <a>MetaVarIdent</a>.
--   
--   <pre>
--   &gt;&gt;&gt; lookupSubst "?m" ["?n[] ↦ Zero()", "?m[x y] ↦ App(y, x)"]
--   Just ?m [x0 x1] ↦ App (x1, x0)
--   </pre>
lookupSubst :: MetaVarIdent -> [Subst] -> Maybe Subst

-- | Apply meta variable substitutions to a term.
--   
--   <pre>
--   &gt;&gt;&gt; applySubsts Foil.emptyScope ["?m[x y] ↦ Lam(z. App(z, App(x, y)))"] "Lam(x. ?m[App(x, ?m[x, x]), x])"
--   Lam (x0 . Lam (x2 . App (x2, App (App (x0, Lam (x2 . App (x2, App (x0, x0)))), x0))))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; applySubsts Foil.emptyScope ["?m[x y] ↦ App(y, x)"] "Lam(f. Lam(x. ?m[?m[x, f], f]))"
--   Lam (x0 . Lam (x1 . App (x0, App (x0, x1))))
--   </pre>
applySubsts :: forall (n :: S). Distinct n => Scope n -> [Subst] -> Term n -> Term n

-- | Check if a (simultaneous) substitution is a solution to a set of
--   constraints:
--   
--   <pre>
--   &gt;&gt;&gt; isSolutionFor ["?m[x y] ↦ App(y, x)"] ["∀ f x. ?m[?m[x, f], f] = App(f, App(f, x))"]
--   True
--   
--   &gt;&gt;&gt; isSolutionFor ["?m[x y] ↦ App(y, x)"] ["∀ f x y. ?m[?m[x, f], f] = App(f, App(f, y))"]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isSolutionFor ["?m[x] ↦ Lam(f. App(f, x))"] ["∀ x. ?m[?m[x]] = Lam(f. App(f, Lam(f. App(f, x))))"]
--   True
--   
--   &gt;&gt;&gt; isSolutionFor ["?m[x] ↦ Lam(f. App(f, x))"] ["∀ y x. ?m[?m[x]] = Lam(f. App(f, Lam(f. App(f, y))))"]
--   False
--   </pre>
isSolutionFor :: [Subst] -> [Constraint] -> Bool

-- | A SOAS interpreter implemented via the free foil.
defaultMain :: IO ()
