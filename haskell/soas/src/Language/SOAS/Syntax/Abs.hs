-- File generated by the BNF Converter (bnfc 2.9.5).

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language Syntax.

module Language.SOAS.Syntax.Abs where

import Prelude (String)
import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Functor, Foldable, Traversable
  , Int, Maybe(..)
  )
import qualified Data.String

import qualified Data.Data    as C (Data, Typeable)
import qualified GHC.Generics as C (Generic)

type TermTyping = TermTyping' BNFC'Position
data TermTyping' a
    = TermTyping a (TypeBinders' a) (Context' a) (ScopedTerm' a) (ScopedType' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Context = Context' BNFC'Position
data Context' a = Context a [MetaVarTyping' a] [VarTyping' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type VarTyping = VarTyping' BNFC'Position
data VarTyping' a = VarTyping a VarIdent (Type' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type MetaVarTyping = MetaVarTyping' BNFC'Position
data MetaVarTyping' a
    = MetaVarTyping a MetaVarIdent [Type' a] (Type' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type OpTyping = OpTyping' BNFC'Position
data OpTyping' a
    = OpTyping a OpIdent (TypeBinders' a) [ScopedOpArgTyping' a] (ScopedType' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Constraint = Constraint' BNFC'Position
data Constraint' a
    = ConstraintEq a (Binders' a) (ScopedTerm' a) (ScopedTerm' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Unifier = Unifier' BNFC'Position
data Unifier' a = Unifier a [Subst' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Subst = Subst' BNFC'Position
data Subst' a = Subst a MetaVarIdent (Binders' a) (ScopedTerm' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Term = Term' BNFC'Position
data Term' a
    = Var a VarIdent
    | Op a OpIdent [OpArg' a]
    | MetaVar a MetaVarIdent [Term' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type OpArg = OpArg' BNFC'Position
data OpArg' a
    = OpArg a (Binders' a) (ScopedTerm' a) | PlainOpArg a (Term' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Binders = Binders' BNFC'Position
data Binders' a = NoBinders a | SomeBinders a VarIdent (Binders' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type ScopedTerm = ScopedTerm' BNFC'Position
data ScopedTerm' a = ScopedTerm a (Term' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Type = Type' BNFC'Position
data Type' a
    = TypeFun a (Type' a) (Type' a)
    | TypeProduct a (Type' a) (Type' a)
    | TypeVar a VarIdent
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type TypeBinders = TypeBinders' BNFC'Position
data TypeBinders' a
    = NoTypeBinders a | SomeTypeBinders a VarIdent (TypeBinders' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type ScopedOpArgTyping = ScopedOpArgTyping' BNFC'Position
data ScopedOpArgTyping' a = ScopedOpArgTyping a (OpArgTyping' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type OpArgTyping = OpArgTyping' BNFC'Position
data OpArgTyping' a = OpArgTyping a [Type' a] (Type' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type ScopedType = ScopedType' BNFC'Position
data ScopedType' a = ScopedType a (Type' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

newtype VarIdent = VarIdent String
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

newtype OpIdent = OpIdent String
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

newtype MetaVarIdent = MetaVarIdent String
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition TermTyping where
  hasPosition = \case
    TermTyping p _ _ _ _ -> p

instance HasPosition Context where
  hasPosition = \case
    Context p _ _ -> p

instance HasPosition VarTyping where
  hasPosition = \case
    VarTyping p _ _ -> p

instance HasPosition MetaVarTyping where
  hasPosition = \case
    MetaVarTyping p _ _ _ -> p

instance HasPosition OpTyping where
  hasPosition = \case
    OpTyping p _ _ _ _ -> p

instance HasPosition Constraint where
  hasPosition = \case
    ConstraintEq p _ _ _ -> p

instance HasPosition Unifier where
  hasPosition = \case
    Unifier p _ -> p

instance HasPosition Subst where
  hasPosition = \case
    Subst p _ _ _ -> p

instance HasPosition Term where
  hasPosition = \case
    Var p _ -> p
    Op p _ _ -> p
    MetaVar p _ _ -> p

instance HasPosition OpArg where
  hasPosition = \case
    OpArg p _ _ -> p
    PlainOpArg p _ -> p

instance HasPosition Binders where
  hasPosition = \case
    NoBinders p -> p
    SomeBinders p _ _ -> p

instance HasPosition ScopedTerm where
  hasPosition = \case
    ScopedTerm p _ -> p

instance HasPosition Type where
  hasPosition = \case
    TypeFun p _ _ -> p
    TypeProduct p _ _ -> p
    TypeVar p _ -> p

instance HasPosition TypeBinders where
  hasPosition = \case
    NoTypeBinders p -> p
    SomeTypeBinders p _ _ -> p

instance HasPosition ScopedOpArgTyping where
  hasPosition = \case
    ScopedOpArgTyping p _ -> p

instance HasPosition OpArgTyping where
  hasPosition = \case
    OpArgTyping p _ _ -> p

instance HasPosition ScopedType where
  hasPosition = \case
    ScopedType p _ -> p

