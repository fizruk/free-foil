-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Language.SOAS.Syntax.Par
  ( happyError
  , myLexer
  , pTermTyping
  , pContext
  , pVarTyping
  , pListVarTyping
  , pMetaVarTyping
  , pListMetaVarTyping
  , pOpTyping
  , pConstraint
  , pUnifier
  , pSubst
  , pListSubst
  , pTerm
  , pListTerm
  , pOpArg
  , pListOpArg
  , pBinders
  , pScopedTerm
  , pTypeVarIdent
  , pType
  , pType1
  , pType2
  , pListType
  , pTypeBinders
  , pOpArgTyping
  , pListOpArgTyping
  , pScopedType
  ) where

import Prelude

import qualified Language.SOAS.Syntax.Abs
import Language.SOAS.Syntax.Lex

}

%name pTermTyping_internal TermTyping
%name pContext_internal Context
%name pVarTyping_internal VarTyping
%name pListVarTyping_internal ListVarTyping
%name pMetaVarTyping_internal MetaVarTyping
%name pListMetaVarTyping_internal ListMetaVarTyping
%name pOpTyping_internal OpTyping
%name pConstraint_internal Constraint
%name pUnifier_internal Unifier
%name pSubst_internal Subst
%name pListSubst_internal ListSubst
%name pTerm_internal Term
%name pListTerm_internal ListTerm
%name pOpArg_internal OpArg
%name pListOpArg_internal ListOpArg
%name pBinders_internal Binders
%name pScopedTerm_internal ScopedTerm
%name pTypeVarIdent_internal TypeVarIdent
%name pType_internal Type
%name pType1_internal Type1
%name pType2_internal Type2
%name pListType_internal ListType
%name pTypeBinders_internal TypeBinders
%name pOpArgTyping_internal OpArgTyping
%name pListOpArgTyping_internal ListOpArgTyping
%name pScopedType_internal ScopedType
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('            { PT _ (TS _ 1)           }
  ')'            { PT _ (TS _ 2)           }
  ','            { PT _ (TS _ 3)           }
  '.'            { PT _ (TS _ 4)           }
  ':'            { PT _ (TS _ 5)           }
  '='            { PT _ (TS _ 6)           }
  '['            { PT _ (TS _ 7)           }
  ']'            { PT _ (TS _ 8)           }
  '|'            { PT _ (TS _ 9)           }
  '×'            { PT _ (TS _ 10)          }
  '→'            { PT _ (TS _ 11)          }
  '↦'            { PT _ (TS _ 12)          }
  '∀'            { PT _ (TS _ 13)          }
  '⊢'            { PT _ (TS _ 14)          }
  L_VarIdent     { PT _ (T_VarIdent _)     }
  L_OpIdent      { PT _ (T_OpIdent _)      }
  L_MetaVarIdent { PT _ (T_MetaVarIdent _) }

%%

VarIdent :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.VarIdent) }
VarIdent  : L_VarIdent { (uncurry Language.SOAS.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.SOAS.Syntax.Abs.VarIdent (tokenText $1)) }

OpIdent :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.OpIdent) }
OpIdent  : L_OpIdent { (uncurry Language.SOAS.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.SOAS.Syntax.Abs.OpIdent (tokenText $1)) }

MetaVarIdent :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.MetaVarIdent) }
MetaVarIdent  : L_MetaVarIdent { (uncurry Language.SOAS.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.SOAS.Syntax.Abs.MetaVarIdent (tokenText $1)) }

TermTyping :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.TermTyping) }
TermTyping
  : '∀' TypeBinders '.' Context '⊢' ScopedTerm ':' Type { (uncurry Language.SOAS.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.SOAS.Syntax.Abs.TermTyping (uncurry Language.SOAS.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6) (snd $8)) }

Context :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.Context) }
Context
  : ListMetaVarTyping '|' ListVarTyping { (fst $1, Language.SOAS.Syntax.Abs.Context (fst $1) (snd $1) (snd $3)) }

VarTyping :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.VarTyping) }
VarTyping
  : VarIdent ':' Type { (fst $1, Language.SOAS.Syntax.Abs.VarTyping (fst $1) (snd $1) (snd $3)) }

ListVarTyping :: { (Language.SOAS.Syntax.Abs.BNFC'Position, [Language.SOAS.Syntax.Abs.VarTyping]) }
ListVarTyping
  : {- empty -} { (Language.SOAS.Syntax.Abs.BNFC'NoPosition, []) }
  | VarTyping { (fst $1, (:[]) (snd $1)) }
  | VarTyping ',' ListVarTyping { (fst $1, (:) (snd $1) (snd $3)) }

MetaVarTyping :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.MetaVarTyping) }
MetaVarTyping
  : MetaVarIdent ':' '[' ListType ']' Type { (fst $1, Language.SOAS.Syntax.Abs.MetaVarTyping (fst $1) (snd $1) (snd $4) (snd $6)) }

ListMetaVarTyping :: { (Language.SOAS.Syntax.Abs.BNFC'Position, [Language.SOAS.Syntax.Abs.MetaVarTyping]) }
ListMetaVarTyping
  : {- empty -} { (Language.SOAS.Syntax.Abs.BNFC'NoPosition, []) }
  | MetaVarTyping { (fst $1, (:[]) (snd $1)) }
  | MetaVarTyping ',' ListMetaVarTyping { (fst $1, (:) (snd $1) (snd $3)) }

OpTyping :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.OpTyping) }
OpTyping
  : OpIdent ':' '∀' TypeBinders '.' '(' ListOpArgTyping ')' '→' ScopedType { (fst $1, Language.SOAS.Syntax.Abs.OpTyping (fst $1) (snd $1) (snd $4) (snd $7) (snd $10)) }

Constraint :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.Constraint) }
Constraint
  : '∀' Binders '.' ScopedTerm '=' ScopedTerm { (uncurry Language.SOAS.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.SOAS.Syntax.Abs.ConstraintEq (uncurry Language.SOAS.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }

Unifier :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.Unifier) }
Unifier
  : '[' ListSubst ']' { (uncurry Language.SOAS.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.SOAS.Syntax.Abs.Unifier (uncurry Language.SOAS.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }

Subst :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.Subst) }
Subst
  : MetaVarIdent '[' Binders ']' '↦' ScopedTerm { (fst $1, Language.SOAS.Syntax.Abs.Subst (fst $1) (snd $1) (snd $3) (snd $6)) }

ListSubst :: { (Language.SOAS.Syntax.Abs.BNFC'Position, [Language.SOAS.Syntax.Abs.Subst]) }
ListSubst
  : {- empty -} { (Language.SOAS.Syntax.Abs.BNFC'NoPosition, []) }
  | Subst { (fst $1, (:[]) (snd $1)) }
  | Subst ',' ListSubst { (fst $1, (:) (snd $1) (snd $3)) }

Term :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.Term) }
Term
  : VarIdent { (fst $1, Language.SOAS.Syntax.Abs.Var (fst $1) (snd $1)) }
  | OpIdent '(' ListOpArg ')' { (fst $1, Language.SOAS.Syntax.Abs.Op (fst $1) (snd $1) (snd $3)) }
  | MetaVarIdent '[' ListTerm ']' { (fst $1, Language.SOAS.Syntax.Abs.MetaVar (fst $1) (snd $1) (snd $3)) }

ListTerm :: { (Language.SOAS.Syntax.Abs.BNFC'Position, [Language.SOAS.Syntax.Abs.Term]) }
ListTerm
  : {- empty -} { (Language.SOAS.Syntax.Abs.BNFC'NoPosition, []) }
  | Term { (fst $1, (:[]) (snd $1)) }
  | Term ',' ListTerm { (fst $1, (:) (snd $1) (snd $3)) }

OpArg :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.OpArg) }
OpArg
  : Binders '.' ScopedTerm { (fst $1, Language.SOAS.Syntax.Abs.OpArg (fst $1) (snd $1) (snd $3)) }

ListOpArg :: { (Language.SOAS.Syntax.Abs.BNFC'Position, [Language.SOAS.Syntax.Abs.OpArg]) }
ListOpArg
  : {- empty -} { (Language.SOAS.Syntax.Abs.BNFC'NoPosition, []) }
  | OpArg { (fst $1, (:[]) (snd $1)) }
  | OpArg ',' ListOpArg { (fst $1, (:) (snd $1) (snd $3)) }

Binders :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.Binders) }
Binders
  : {- empty -} { (Language.SOAS.Syntax.Abs.BNFC'NoPosition, Language.SOAS.Syntax.Abs.NoBinders Language.SOAS.Syntax.Abs.BNFC'NoPosition) }
  | VarIdent Binders { (fst $1, Language.SOAS.Syntax.Abs.SomeBinders (fst $1) (snd $1) (snd $2)) }

ScopedTerm :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.ScopedTerm) }
ScopedTerm
  : Term { (fst $1, Language.SOAS.Syntax.Abs.ScopedTerm (fst $1) (snd $1)) }

TypeVarIdent :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.TypeVarIdent) }
TypeVarIdent
  : VarIdent { (fst $1, Language.SOAS.Syntax.Abs.TypeVarIdent (fst $1) (snd $1)) }

Type :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.Type) }
Type
  : Type1 '→' Type1 { (fst $1, Language.SOAS.Syntax.Abs.TypeFun (fst $1) (snd $1) (snd $3)) }
  | Type1 { (fst $1, (snd $1)) }

Type1 :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.Type) }
Type1
  : Type1 '×' Type2 { (fst $1, Language.SOAS.Syntax.Abs.TypeProduct (fst $1) (snd $1) (snd $3)) }
  | Type2 { (fst $1, (snd $1)) }

Type2 :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.Type) }
Type2
  : TypeVarIdent { (fst $1, Language.SOAS.Syntax.Abs.TypeVar (fst $1) (snd $1)) }
  | '(' Type ')' { (uncurry Language.SOAS.Syntax.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

ListType :: { (Language.SOAS.Syntax.Abs.BNFC'Position, [Language.SOAS.Syntax.Abs.Type]) }
ListType
  : {- empty -} { (Language.SOAS.Syntax.Abs.BNFC'NoPosition, []) }
  | Type { (fst $1, (:[]) (snd $1)) }
  | Type ',' ListType { (fst $1, (:) (snd $1) (snd $3)) }

TypeBinders :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.TypeBinders) }
TypeBinders
  : {- empty -} { (Language.SOAS.Syntax.Abs.BNFC'NoPosition, Language.SOAS.Syntax.Abs.NoTypeBinders Language.SOAS.Syntax.Abs.BNFC'NoPosition) }
  | TypeVarIdent TypeBinders { (fst $1, Language.SOAS.Syntax.Abs.SomeTypeBinders (fst $1) (snd $1) (snd $2)) }

OpArgTyping :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.OpArgTyping) }
OpArgTyping
  : TypeBinders '.' ScopedType { (fst $1, Language.SOAS.Syntax.Abs.OpArgTyping (fst $1) (snd $1) (snd $3)) }

ListOpArgTyping :: { (Language.SOAS.Syntax.Abs.BNFC'Position, [Language.SOAS.Syntax.Abs.OpArgTyping]) }
ListOpArgTyping
  : {- empty -} { (Language.SOAS.Syntax.Abs.BNFC'NoPosition, []) }
  | OpArgTyping { (fst $1, (:[]) (snd $1)) }
  | OpArgTyping ',' ListOpArgTyping { (fst $1, (:) (snd $1) (snd $3)) }

ScopedType :: { (Language.SOAS.Syntax.Abs.BNFC'Position, Language.SOAS.Syntax.Abs.ScopedType) }
ScopedType
  : Type { (fst $1, Language.SOAS.Syntax.Abs.ScopedType (fst $1) (snd $1)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pTermTyping :: [Token] -> Err Language.SOAS.Syntax.Abs.TermTyping
pTermTyping = fmap snd . pTermTyping_internal

pContext :: [Token] -> Err Language.SOAS.Syntax.Abs.Context
pContext = fmap snd . pContext_internal

pVarTyping :: [Token] -> Err Language.SOAS.Syntax.Abs.VarTyping
pVarTyping = fmap snd . pVarTyping_internal

pListVarTyping :: [Token] -> Err [Language.SOAS.Syntax.Abs.VarTyping]
pListVarTyping = fmap snd . pListVarTyping_internal

pMetaVarTyping :: [Token] -> Err Language.SOAS.Syntax.Abs.MetaVarTyping
pMetaVarTyping = fmap snd . pMetaVarTyping_internal

pListMetaVarTyping :: [Token] -> Err [Language.SOAS.Syntax.Abs.MetaVarTyping]
pListMetaVarTyping = fmap snd . pListMetaVarTyping_internal

pOpTyping :: [Token] -> Err Language.SOAS.Syntax.Abs.OpTyping
pOpTyping = fmap snd . pOpTyping_internal

pConstraint :: [Token] -> Err Language.SOAS.Syntax.Abs.Constraint
pConstraint = fmap snd . pConstraint_internal

pUnifier :: [Token] -> Err Language.SOAS.Syntax.Abs.Unifier
pUnifier = fmap snd . pUnifier_internal

pSubst :: [Token] -> Err Language.SOAS.Syntax.Abs.Subst
pSubst = fmap snd . pSubst_internal

pListSubst :: [Token] -> Err [Language.SOAS.Syntax.Abs.Subst]
pListSubst = fmap snd . pListSubst_internal

pTerm :: [Token] -> Err Language.SOAS.Syntax.Abs.Term
pTerm = fmap snd . pTerm_internal

pListTerm :: [Token] -> Err [Language.SOAS.Syntax.Abs.Term]
pListTerm = fmap snd . pListTerm_internal

pOpArg :: [Token] -> Err Language.SOAS.Syntax.Abs.OpArg
pOpArg = fmap snd . pOpArg_internal

pListOpArg :: [Token] -> Err [Language.SOAS.Syntax.Abs.OpArg]
pListOpArg = fmap snd . pListOpArg_internal

pBinders :: [Token] -> Err Language.SOAS.Syntax.Abs.Binders
pBinders = fmap snd . pBinders_internal

pScopedTerm :: [Token] -> Err Language.SOAS.Syntax.Abs.ScopedTerm
pScopedTerm = fmap snd . pScopedTerm_internal

pTypeVarIdent :: [Token] -> Err Language.SOAS.Syntax.Abs.TypeVarIdent
pTypeVarIdent = fmap snd . pTypeVarIdent_internal

pType :: [Token] -> Err Language.SOAS.Syntax.Abs.Type
pType = fmap snd . pType_internal

pType1 :: [Token] -> Err Language.SOAS.Syntax.Abs.Type
pType1 = fmap snd . pType1_internal

pType2 :: [Token] -> Err Language.SOAS.Syntax.Abs.Type
pType2 = fmap snd . pType2_internal

pListType :: [Token] -> Err [Language.SOAS.Syntax.Abs.Type]
pListType = fmap snd . pListType_internal

pTypeBinders :: [Token] -> Err Language.SOAS.Syntax.Abs.TypeBinders
pTypeBinders = fmap snd . pTypeBinders_internal

pOpArgTyping :: [Token] -> Err Language.SOAS.Syntax.Abs.OpArgTyping
pOpArgTyping = fmap snd . pOpArgTyping_internal

pListOpArgTyping :: [Token] -> Err [Language.SOAS.Syntax.Abs.OpArgTyping]
pListOpArgTyping = fmap snd . pListOpArgTyping_internal

pScopedType :: [Token] -> Err Language.SOAS.Syntax.Abs.ScopedType
pScopedType = fmap snd . pScopedType_internal
}

